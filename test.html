<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Interaction Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #333;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="testCanvas"></canvas>

    <script>
        // --- CORE STATE & SETUP ---
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let objects = [];
        let selectedObjectId = null;
        let isDragging = false, isResizing = false, isRotating = false;
        let activeResizeHandle = null;
        let dragStartX, dragStartY, initialState = {};

        // --- SHAPE CLASS WITH CORRECTED LOGIC ---
        class Shape {
            constructor(config) {
                this.ctx = config.ctx;
                this.id = config.id;
                this.x = config.x;
                this.y = config.y;
                this.width = config.width;
                this.height = config.height;
                this.rotation = config.rotation || 0;
                this.color = config.color || 'royalblue';
                this.handleSize = 12;
                this.rotationHandleOffset = -40;
                this.rotationHandleRadius = 9;
                this.handles = ['top-left', 'top', 'top-right', 'left', 'right', 'bottom-left', 'bottom', 'bottom-right'];
            }

            // --- Core Math Helpers ---
            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }
            getRenderAngle() { return this.rotation * Math.PI / 180; }

            // --- Interaction & Hit Detection ---
            isPointInside(px, py) {
                const center = this.getCenter();
                const angle = -this.getRenderAngle();
                const dx = px - center.x;
                const dy = py - center.y;
                const local_dx = dx * Math.cos(angle) - dy * Math.sin(angle);
                const local_dy = dx * Math.sin(angle) + dy * Math.cos(angle);
                return (Math.abs(local_dx) <= this.width / 2 && Math.abs(local_dy) <= this.height / 2);
            }

            getHandleAtPoint(px, py) {
                // This unified function checks for all handles in world space
                const corners = this.getWorldCoordsOfCorners();
                const minX = Math.min(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                const minY = Math.min(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);
                const maxX = Math.max(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                const maxY = Math.max(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);

                // Rotation Handle Check
                const rotHandleX = (minX + maxX) / 2;
                const rotHandleY = minY + this.rotationHandleOffset;
                let dist = Math.sqrt(Math.pow(px - rotHandleX, 2) + Math.pow(py - rotHandleY, 2));
                if (dist <= this.rotationHandleRadius + 4) {
                    return { name: 'rotate', cursor: 'crosshair', type: 'rotation' };
                }

                // Resize Handle Check
                const h2 = this.handleSize / 2;
                const handlePositions = {
                    'top-left': { x: minX, y: minY }, 'top': { x: (minX + maxX) / 2, y: minY }, 'top-right': { x: maxX, y: minY },
                    'left': { x: minX, y: (minY + maxY) / 2 }, 'right': { x: maxX, y: (minY + maxY) / 2 },
                    'bottom-left': { x: minX, y: maxY }, 'bottom': { x: (minX + maxX) / 2, y: maxY }, 'bottom-right': { x: maxX, y: maxY }
                };
                for (const name of this.handles) {
                    const pos = handlePositions[name];
                    if (px >= pos.x - h2 && px <= pos.x + h2 && py >= pos.y - h2 && py <= pos.y + h2) {
                        return { name: name, cursor: 'pointer' }; // Simplified cursor for test
                    }
                }
                return null;
            }

            getWorldCoordsOfCorners() {
                const center = this.getCenter();
                const angle = this.getRenderAngle();
                const halfW = this.width / 2;
                const halfH = this.height / 2;
                const corners = {
                    tl: { x: -halfW, y: -halfH }, tr: { x: halfW, y: -halfH },
                    bl: { x: -halfW, y: halfH }, br: { x: halfW, y: halfH }
                };
                const rotatedCorners = {};
                for (const key in corners) {
                    const c = corners[key];
                    rotatedCorners[key] = {
                        x: c.x * Math.cos(angle) - c.y * Math.sin(angle) + center.x,
                        y: c.x * Math.sin(angle) + c.y * Math.cos(angle) + center.y
                    };
                }
                return rotatedCorners;
            }

            // --- Drawing ---
            draw() {
                this.ctx.save();
                const center = this.getCenter();
                this.ctx.translate(center.x, center.y);
                this.ctx.rotate(this.getRenderAngle());
                this.ctx.fillStyle = this.color;
                this.ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                this.ctx.restore();
            }

            drawSelectionUI() {
                const corners = this.getWorldCoordsOfCorners();
                const minX = Math.min(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                const minY = Math.min(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);
                const maxX = Math.max(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                const maxY = Math.max(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);

                this.ctx.strokeStyle = '#00f6ff';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                this.ctx.setLineDash([]);

                // Draw Handles
                const h2 = this.handleSize / 2;
                const handlePositions = {
                    'top-left': { x: minX, y: minY }, 'top': { x: (minX + maxX) / 2, y: minY }, 'top-right': { x: maxX, y: minY },
                    'left': { x: minX, y: (minY + maxY) / 2 }, 'right': { x: maxX, y: (minY + maxY) / 2 },
                    'bottom-left': { x: minX, y: maxY }, 'bottom': { x: (minX + maxX) / 2, y: maxY }, 'bottom-right': { x: maxX, y: maxY }
                };
                this.ctx.fillStyle = '#00f6ff';
                for (const name of this.handles) {
                    const pos = handlePositions[name];
                    this.ctx.fillRect(pos.x - h2, pos.y - h2, this.handleSize, this.handleSize);
                }

                // Draw Rotation Handle
                const rotHandleX = (minX + maxX) / 2;
                const rotHandleY = minY + this.rotationHandleOffset;
                this.ctx.beginPath();
                this.ctx.moveTo(rotHandleX, minY);
                this.ctx.lineTo(rotHandleX, rotHandleY);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.arc(rotHandleX, rotHandleY, this.rotationHandleRadius, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }

        // --- EVENT LISTENERS ---
        // In test.html, replace the entire canvas.addEventListener('mousedown', ...) function:

        canvas.addEventListener('mousedown', e => {
            const { clientX: x, clientY: y } = e;

            if (selectedObjectId !== null) {
                const selectedObject = objects.find(o => o.id === selectedObjectId);
                const handle = selectedObject.getHandleAtPoint(x, y);
                if (handle) {
                    activeResizeHandle = handle.name;
                    dragStartX = x;
                    dragStartY = y;

                    if (handle.type === 'rotation') {
                        isRotating = true;
                        const center = selectedObject.getCenter();
                        initialState = { startAngle: Math.atan2(y - center.y, x - center.x), initialObjectAngle: selectedObject.getRenderAngle() };
                    } else {
                        isResizing = true;
                        // For resizing, store the object's complete initial state
                        initialState = {
                            x: selectedObject.x, y: selectedObject.y,
                            width: selectedObject.width, height: selectedObject.height,
                            rotation: selectedObject.rotation,
                            center: selectedObject.getCenter()
                        };

                        // Also store the anchor point, which is the center for side-drags 
                        // and the opposite corner for corner-drags.
                        const corners = selectedObject.getWorldCoordsOfCorners();
                        const oppositeMap = {
                            'top-left': 'br', 'top-right': 'bl', 'bottom-left': 'tr', 'bottom-right': 'tl',
                            'top': 'bottom', 'bottom': 'top', 'left': 'right', 'right': 'left'
                        };
                        initialState.oppositeHandle = oppositeMap[activeResizeHandle];

                        if (activeResizeHandle.includes('-')) { // It's a corner
                            initialState.anchorPoint = corners[initialState.oppositeHandle];
                        } else { // It's a side
                            // For side drags, the "anchor" is more complex, so we'll handle it in mousemove
                        }
                    }
                    return;
                }
            }

            const hitObject = [...objects].reverse().find(obj => obj.isPointInside(x, y));
            if (hitObject) {
                selectedObjectId = hitObject.id;
                isDragging = true;
                dragStartX = x; dragStartY = y;
                initialState = { x: hitObject.x, y: hitObject.y };
            } else {
                selectedObjectId = null;
            }
            drawFrame();
        });;

        canvas.addEventListener('mousemove', e => {
        const { clientX: x, clientY: y } = e;
        const selectedObject = objects.find(o => o.id === selectedObjectId);

        // --- Rotation Logic ---
        if (isRotating && selectedObject) {
            const center = selectedObject.getCenter();
            const currentAngle = Math.atan2(y - center.y, x - center.x);
            const angleDelta = currentAngle - initialState.startAngle;
            selectedObject.rotation = (initialState.initialObjectAngle + angleDelta) * 180 / Math.PI;
        } 
        
        // --- Resizing Logic ---
        else if (isResizing && selectedObject) {
            const initial = initialState;
            
            // --- CORNER RESIZE LOGIC ---
            if (activeResizeHandle.includes('-')) {
                const anchorPoint = initial.anchorPoint;
                const angle = selectedObject.getRenderAngle();
                
                // 1. Calculate the new center and dimensions from the fixed anchor and moving mouse
                const newCenter = { x: (x + anchorPoint.x) / 2, y: (y + anchorPoint.y) / 2 };
                const vector = { x: x - anchorPoint.x, y: y - anchorPoint.y };
                const newWidth = Math.abs(vector.x * Math.cos(-angle) - vector.y * Math.sin(-angle));
                const newHeight = Math.abs(vector.x * Math.sin(-angle) + vector.y * Math.cos(-angle));

                // 2. Defensive Check: Prevent object from disappearing if math is unstable
                if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 10 || newHeight < 10) {
                    // Do nothing this frame to prevent disappearing
                } else {
                    selectedObject.width = newWidth;
                    selectedObject.height = newHeight;
                    
                    // 3. Calculate the new top-left position based on the new center and dimensions
                    const halfW = newWidth / 2;
                    const halfH = newHeight / 2;
                    const rotated_dx = -halfW * Math.cos(angle) - (-halfH) * Math.sin(angle);
                    const rotated_dy = -halfW * Math.sin(angle) + (-halfH) * Math.cos(angle);
                    selectedObject.x = newCenter.x + rotated_dx;
                    selectedObject.y = newCenter.y + rotated_dy;
                }
            } 
            // --- SIDE RESIZE LOGIC ---
            else {
                const angle = selectedObject.getRenderAngle();
                const dx = x - dragStartX;
                const dy = y - dragStartY;

                // Rotate mouse delta into the object's local coordinate system
                const local_dx = dx * Math.cos(-angle) - dy * Math.sin(-angle);
                const local_dy = dx * Math.sin(-angle) + dy * Math.cos(-angle);
                
                let shift_x_local = 0;
                let shift_y_local = 0;

                // Apply size and position changes based on the dragged handle
                if (activeResizeHandle === 'top') {
                    selectedObject.height = Math.max(10, initial.height - local_dy);
                    shift_y_local = (initial.height - selectedObject.height) / 2;
                } else if (activeResizeHandle === 'bottom') {
                    selectedObject.height = Math.max(10, initial.height + local_dy);
                    shift_y_local = (selectedObject.height - initial.height) / 2;
                } else if (activeResizeHandle === 'left') {
                    selectedObject.width = Math.max(10, initial.width - local_dx);
                    shift_x_local = (initial.width - selectedObject.width) / 2;
                } else if (activeResizeHandle === 'right') {
                    selectedObject.width = Math.max(10, initial.width + local_dx);
                    shift_x_local = (selectedObject.width - initial.width) / 2;
                }
                
                // Rotate the position shift back into world space
                const rotated_shift_x = shift_x_local * Math.cos(angle) - shift_y_local * Math.sin(angle);
                const rotated_shift_y = shift_x_local * Math.sin(angle) + shift_y_local * Math.cos(angle);

                selectedObject.x = initial.x - rotated_shift_x;
                selectedObject.y = initial.y - rotated_shift_y;
            }
        } 
        
        // --- Dragging Logic ---
        else if (isDragging && selectedObject) {
            const dx = x - dragStartX;
            const dy = y - dragStartY;
            selectedObject.x = initialState.x + dx;
            selectedObject.y = initialState.y + dy;
        } 
        
        // --- Cursor Update Logic ---
        else {
            let cursor = 'default';
            const topObject = [...objects].reverse().find(obj => obj.isPointInside(x, y));
            if(topObject) {
                const handle = topObject.getHandleAtPoint(x, y);
                if (selectedObjectId === topObject.id && handle) {
                    cursor = handle.cursor || 'pointer';
                } else if (selectedObjectId === topObject.id && !handle) {
                    cursor = 'move';
                } else {
                    cursor = 'pointer';
                }
            }
            canvas.style.cursor = cursor;
        }
        drawFrame();
    });

        canvas.addEventListener('mouseup', e => {
            isDragging = isResizing = isRotating = false;
            initialState = {};
            drawFrame();
        });

        // --- DRAW LOOP & INITIALIZATION ---
        function drawFrame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            objects.forEach(obj => obj.draw());
            if (selectedObjectId !== null) {
                const selectedObject = objects.find(o => o.id === selectedObjectId);
                if (selectedObject) selectedObject.drawSelectionUI();
            }
        }

        // Create the initial object
        objects.push(new Shape({
            ctx: ctx, id: 1,
            x: 250, y: 150,
            width: 150, height: 200,
            rotation: 20
        }));
        selectedObjectId = 1;
        drawFrame();

    </script>
</body>

</html>