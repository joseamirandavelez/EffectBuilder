<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRGB Interactive Effect Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        html, body { height: 100%; }
        #right-panel-top { display: flex; align-items: center; justify-content: center; flex-grow: 1; min-height: 0; padding: 1rem; overflow: hidden; box-sizing: border-box; }
        #canvas-container { position: relative; cursor: default; flex-shrink: 0; }
        #signalCanvas { display: block; width: 100%; height: 100%; }
    </style>
</head>

<body class="d-flex flex-column vh-100">
    <div class="container-fluid flex-grow-1 p-3">
        <div class="row h-100">
            <div id="left-panel" class="col-md-4 h-100 p-3 border-end bg-body-tertiary" style="overflow: auto;">
                <div class="h-100 d-flex flex-column">
                    <div class="flex-grow-1 overflow-auto pe-2">
                        <h4 class="text-body-emphasis">Controls</h4>
                        <form id="controls-form"></form>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-success w-100" id="add-object-btn"><i class="bi bi-plus-circle"></i> Add New Object</button>
                    </div>
                </div>
            </div>
            <div id="right-panel" class="col-md-8 d-flex flex-column h-100">
                <div id="right-panel-top">
                    <div id="canvas-container">
                        <canvas id="signalCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- START: KNOWN-GOOD JAVASCRIPT ---

        // --- util.js (with Shape Class) ---
        console.log("Known-Good Script Loaded");

        const FONT_DATA_4PX = { name: 'small', charWidth: 3, charHeight: 4, charSpacing: 1, lineSpacing: 2, map: { 'A':['010','101','111','101'],'B':['110','101','111','110'],'C':['011','100','100','011'],'D':['110','101','101','110'],'E':['111','100','110','111'],'F':['111','100','110','100'],'G':['011','100','101','011'],'H':['101','101','111','101'],'I':['111','010','010','111'],'J':['011','001','101','010'],'K':['101','110','110','101'],'L':['100','100','100','111'],'M':['101','111','101','101'],'N':['110','101','101','101'],'O':['010','101','101','010'],'P':['111','101','110','100'],'Q':['010','101','111','011'],'R':['110','101','110','101'],'S':['011','100','010','110'],'T':['111','010','010','010'],'U':['101','101','101','011'],'V':['101','101','010','010'],'W':['101','101','111','101'],'X':['101','010','010','101'],'Y':['101','010','010','010'],'Z':['111','001','010','111'],'0':['010','101','101','010'],'1':['010','110','010','010'],'2':['110','001','010','111'],'3':['111','010','101','010'],'4':['100','101','111','001'],'5':['111','100','011','110'],'6':['011','100','111','010'],'7':['111','001','010','010'],'8':['010','101','010','101'],'9':['010','111','001','110'],'.':['000','000','000','010'],',':['000','000','010','010'],'!':['010','010','000','010'],'?':['010','101','000','010'],"'":['010','010','000','000'],'"':['101','101','000','000'],':':['000','010','000','010'],';':['000','010','010','010'],'(':['010','100','100','010'],')':['100','010','010','100'],'-':['000','000','111','000'],'+':['000','010','111','010'],'=':['000','111','000','111'],'*':['101','010','101','000'],'/':['001','010','100','000'],'\\':['100','010','001','000'],' ':['000','000','000','000'] } };
        const FONT_DATA_5PX = { name: 'large', charWidth: 5, charHeight: 5, charSpacing: 1, lineSpacing: 1, map: { 'A':['01110','10001','11111','10001','10001'],'B':['11110','10001','11110','10001','11110'],'C':['01110','10000','10000','10000','01110'],'D':['11110','10001','10001','10001','11110'],'E':['11111','10000','11110','10000','11111'],'F':['11111','10000','11110','10000','10000'],'G':['01110','10000','10111','10001','01110'],'H':['10001','10001','11111','10001','10001'],'I':['11111','00100','00100','00100','11111'],'J':['00111','00001','00001','10001','01110'],'K':['10001','10010','11100','10010','10001'],'L':['10000','10000','10000','10000','11111'],'M':['10001','11011','10101','10001','10001'],'N':['10001','11001','10101','10011','10001'],'O':['01110','10001','10001','10001','01110'],'P':['11110','10001','11110','10000','10000'],'Q':['01110','10001','10101','10010','01101'],'R':['11110','10001','11110','10010','10001'],'S':['01110','10000','01110','00001','11110'],'T':['11111','00100','00100','00100','00100'],'U':['10001','10001','10001','10001','01110'],'V':['10001','10001','10001','01010','00100'],'W':['10001','10001','10101','11011','10001'],'X':['10001','01010','00100','01010','10001'],'Y':['10001','01010','00100','00100','00100'],'Z':['11111','00010','00100','01000','11111'],'0':['01110','10011','10101','11001','01110'],'1':['00100','01100','00100','00100','01110'],'2':['01110','10001','00110','01000','11111'],'3':['11111','00010','01100','00001','11110'],'4':['00110','01010','10010','11111','00010'],'5':['11111','10000','11110','00001','11110'],'6':['01110','10000','11110','10001','01110'],'7':['11111','00001','00010','00100','00100'],'8':['01110','10001','01110','10001','01110'],'9':['01110','10001','01111','00001','01110'],' ':['00000','00000','00000','00000','00000'],'.':['00000','00000','00000','01100','01100'],'!':['01100','01100','01100','00000','01100'],'?':['01110','10001','00110','00000','00100'] } };
        function drawPixelText(ctx, shape, textToRender) { const { x, y, width, height, pixelFont, fontSize, textAlign, textAnimation, scrollOffsetX, waveAngle, visibleCharCount } = shape; if (typeof textToRender !== 'string') return; const fontData = pixelFont === 'large' ? FONT_DATA_5PX : FONT_DATA_4PX; const { charWidth, charHeight, charSpacing, map } = fontData; const pixelSize = fontSize / 10; const animatedText = textToRender.toUpperCase().substring(0, Math.floor(visibleCharCount)); const lines = animatedText.split('\n'); ctx.save(); ctx.beginPath(); ctx.rect(x, y, width, height); ctx.clip(); lines.forEach((line, lineIndex) => { const lineWidth = line.length * (charWidth + charSpacing) * pixelSize - (charSpacing * pixelSize); let lineStartX = x; if (textAlign === 'center') { lineStartX = x + (width - lineWidth) / 2; } else if (textAlign === 'right') { lineStartX = x + width - lineWidth; } for (let i = 0; i < line.length; i++) { const charData = map[line[i]] || map['?']; if (!charData) continue; let dx = lineStartX + i * (charWidth + charSpacing) * pixelSize + scrollOffsetX; let dy = y + pixelSize + lineIndex * (charHeight + 1) * pixelSize; if (textAnimation === 'wave') { dy += Math.sin(waveAngle + i * 0.5) * (pixelSize * 2); } for (let r = 0; r < charHeight; r++) { for (let c = 0; c < charWidth; c++) { if (charData[r] && charData[r][c] === '1') { ctx.fillRect(dx + c * pixelSize, dy + r * pixelSize, pixelSize, pixelSize); } } } } }); ctx.restore(); }
        function lerpColor(a, b, amount) { const amt = Math.max(0, Math.min(1, amount)); const ah = parseInt(a.slice(1), 16), ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff, bh = parseInt(b.slice(1), 16), br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff, rr = Math.round(ar + amt * (br - ar)), rg = Math.round(ag + amt * (bg - ag)), rb = Math.round(ab + amt * (bb - ab)); return '#' + (rr << 16 | rg << 8 | rb).toString(16).padStart(6, '0'); }

        class Shape {
             constructor(props) {
                Object.assign(this, props);
                // Set defaults for any missing properties
                this.name = this.name || `Object ${this.id}`;
                this.shape = this.shape || 'rectangle';
                this.x = this.x || 0; this.y = this.y || 0; this.width = this.width || 200; this.height = this.height || 152;
                this.rotation = this.rotation || 0;
                this.gradType = this.gradType || 'solid';
                this.gradient = this.gradient || { color1: '#00ff00', color2: '#d400ff' };
                this.animationLinkMode = this.animationLinkMode || 'none';
                this.text = this.text || '';
                this.textAnimation = this.textAnimation || 'none';
                this.textAnimationSpeed = this.textAnimationSpeed || 10;
                this.fontSize = this.fontSize || 15;
                this.pixelFont = this.pixelFont || 'small';
                this.textAlign = this.textAlign || 'left';
                // Initialize internal state
                this.scrollOffsetX = 0;
                this.visibleCharCount = this.text.length;
                this.resetAnimationState();
            }

            resetAnimationState(newMode) {
                const mode = newMode !== undefined ? newMode : this.animationLinkMode;
                this.isAnimationActive = (mode === 'none');
                this.animationStartTime = -1;
                this.hasCompletedOneCycle = false;
                this.scrollOffset = 0;
                this.isReversing = false;
            }

            update(props) {
                 // The logic to reset state is now handled externally in main.js
                // This keeps the Shape class simpler.
                Object.assign(this, props);
                if (props.text !== undefined) {
                    this.visibleCharCount = this.text.length;
                }
            }

            updateAnimationState(audioData, sensorData, deltaTime = 0, allObjects = []) {
                if (!this.isAnimationActive) {
                    const currentTime = performance.now();
                    switch (this.animationLinkMode) {
                        case 'delay':
                            if (this.animationStartTime < 0) this.animationStartTime = currentTime;
                            if (currentTime - this.animationStartTime >= this.animationLinkDelay * 1000) this.isAnimationActive = true;
                            break;
                        case 'sequence':
                            const targetId = parseInt(this.animationLinkTarget, 10);
                            const leader = allObjects.find(o => o.id === targetId);
                            if (leader && leader.hasCompletedOneCycle) {
                                this.isAnimationActive = true;
                                leader.hasCompletedOneCycle = false;
                            }
                            break;
                    }
                }
                if (!this.isAnimationActive) return;

                const textAnimSpeed = (this.textAnimationSpeed || 0) * deltaTime;
                switch (this.textAnimation) {
                    case 'marquee':
                    case 'wave':
                        const fontData = this.pixelFont === 'large' ? FONT_DATA_5PX : FONT_DATA_4PX;
                        const pixelSize = this.fontSize / 10;
                        const textWidth = this.text.length * (fontData.charWidth + fontData.charSpacing) * pixelSize;
                        this.scrollOffsetX -= textAnimSpeed * 20;
                        if (this.scrollOffsetX < -textWidth) {
                            this.scrollOffsetX = this.width;
                            this.hasCompletedOneCycle = true;
                        }
                        if (this.textAnimation === 'wave') this.waveAngle = (this.waveAngle || 0) + textAnimSpeed * 0.5;
                        this.visibleCharCount = this.text.length;
                        break;
                    case 'typewriter':
                         if (!this.typewriterWaitTimer) this.typewriterWaitTimer = 0;
                         if (this.typewriterWaitTimer > 0) {
                            this.typewriterWaitTimer -= deltaTime * 60;
                            if (this.typewriterWaitTimer <= 0) this.visibleCharCount = 0;
                        } else {
                            this.visibleCharCount = (this.visibleCharCount || 0) + textAnimSpeed;
                            if (this.visibleCharCount >= this.text.length) {
                                this.visibleCharCount = this.text.length;
                                this.typewriterWaitTimer = 50;
                                this.hasCompletedOneCycle = true;
                            }
                        }
                        this.scrollOffsetX = 0;
                        break;
                }
            }
            draw(isSelected) {
                if (this.shape === 'rectangle') {
                    this.ctx.fillStyle = this.gradient.color1;
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                } else if (this.shape === 'text') {
                    this.ctx.fillStyle = this.gradient.color1;
                    drawPixelText(this.ctx, this, this.text);
                }
            }
            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }
            isPointInside(px, py) { return (px >= this.x && px <= this.x + this.width && py >= this.y && py <= this.y + this.height); }
        }

        // --- main.js ---
        const INITIAL_CONFIG_TEMPLATE = `
            <meta title="Untitled Effect" />
            <meta description="Built with Effect Builder" />
            <meta property="obj1_shape" label="Object 1: Shape" type="combobox" values="rectangle,text" default="text" />
            <meta property="obj1_x" label="Object 1: X" type="number" default="50" />
            <meta property="obj1_y" label="Object 1: Y" type="number" default="50" />
            <meta property="obj1_width" label="Object 1: Width" type="number" default="800" />
            <meta property="obj1_height" label="Object 1: Height" type="number" default="50" />
            <meta property="obj1_text" label="Object 1: Text" type="textfield" default="LEADER - I WILL COMPLETE ONE CYCLE..." />
            <meta property="obj1_textAnimation" label="Object 1: Text Animation" type="combobox" values="none,marquee,typewriter" default="marquee" />
            <meta property="obj1_textAnimationSpeed" label="Object 1: Text Anim Speed" type="number" default="15" />
            <meta property="obj1_fontSize" label="Object 1: Font Size" type="number" default="50" />
            <meta property="obj1_pixelFont" label="Object 1: Pixel Font" type="combobox" values="small,large" default="large" />
            <meta property="obj1_animationLinkMode" label="Object 1: Link Mode" type="combobox" default="none" values="none,sync,sequence,delay" />
            <meta property="obj1_animationLinkTarget" label="Object 1: Link Target" type="combobox" default="" values="" />
            <meta property="obj1_animationLinkDelay" label="Object 1: Start Delay (s)" type="number" default="1" />
        `;
        let configStore = [];
        let objects = [];
        const canvas = document.getElementById('signalCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1280; canvas.height = 800;
        const form = document.getElementById('controls-form');
        let then = performance.now();

        function parseMetaToConfig(metaElement) { const config = {}; for (const attr of metaElement.attributes) { config[attr.name] = attr.value; } return config; }
        function groupConfigs(flatConfig) { const grouped = { general: [], objects: {} }; flatConfig.forEach(config => { const key = config.property || config.name; if (key && key.startsWith('obj')) { const match = key.match(/^obj(\d+)_/); if (match) { const id = match[1]; if (!grouped.objects[id]) grouped.objects[id] = []; grouped.objects[id].push(config); } } else { grouped.general.push(config); } }); return grouped; }
        function createFormControl(config) { const { property, name, label, type, default: defaultValue, values } = config; const controlId = property || name; const formGroup = document.createElement('div'); formGroup.className = 'mb-3'; const labelEl = document.createElement('label'); labelEl.htmlFor = controlId; labelEl.className = 'form-label'; if (label) { const cleanLabel = label.includes(':') ? label.substring(label.indexOf(':') + 1).trim() : label; labelEl.textContent = cleanLabel; } formGroup.appendChild(labelEl); if (type === 'number') { const input = document.createElement('input'); input.id = controlId; input.className = 'form-control'; input.name = controlId; input.type = 'number'; input.value = defaultValue; formGroup.appendChild(input); } else if (type === 'combobox') { const select = document.createElement('select'); select.id = controlId; select.className = 'form-select'; select.name = controlId; values.split(',').forEach(val => { const option = document.createElement('option'); option.value = val; option.textContent = val.charAt(0).toUpperCase() + val.slice(1); if (val === defaultValue) option.selected = true; select.appendChild(option); }); formGroup.appendChild(select); } else if (type === 'textfield') { const input = document.createElement('input'); input.id = controlId; input.className = 'form-control'; input.name = controlId; input.type = 'text'; input.value = defaultValue; formGroup.appendChild(input); } return formGroup; }
        function getDefaultObjectConfig(newId) { const parser = new DOMParser(); const doc = parser.parseFromString(INITIAL_CONFIG_TEMPLATE.replace(/obj1/g, `obj${newId}`), 'text/html'); return Array.from(doc.querySelectorAll('meta')).map(parseMetaToConfig).filter(c => (c.property||"").startsWith(`obj${newId}`)); }
        function getFormValuesForObject(id) { const values = {}; const prefix = `obj${id}_`; const configs = configStore.filter(c => c.property && c.property.startsWith(prefix)); configs.forEach(conf => { const key = conf.property.replace(prefix, ''); const el = form.elements[conf.property]; if (el) { let value; if (el.type === 'number') { value = parseFloat(el.value); } else { value = el.value; } values[key] = value; } }); return values; }
        function updateObjectsFromForm() { objects.forEach(obj => { const newProps = getFormValuesForObject(obj.id); if (newProps.animationLinkMode !== undefined && newProps.animationLinkMode !== obj.animationLinkMode) { obj.resetAnimationState(newProps.animationLinkMode); } obj.update(newProps); }); }
        function createInitialObjects() { const grouped = groupConfigs(configStore); const ids = Object.keys(grouped.objects); objects = ids.map(id => { const config = { id: parseInt(id), ctx }; grouped.objects[id].forEach(conf => { const key = conf.property.replace(`obj${id}_`, ''); let value = conf.default; if (conf.type === 'number') value = parseFloat(value); config[key] = value; }); return new Shape(config); }); }
        function renderForm() { form.innerHTML = ''; const grouped = groupConfigs(configStore); objects.forEach(obj => { const id = obj.id; const objectConfigs = grouped.objects[id] || []; const fieldset = document.createElement('fieldset'); fieldset.className = 'border p-3 mb-3 rounded'; const legend = document.createElement('legend'); legend.className = 'fs-5'; legend.textContent = obj.name || `Object ${id}`; fieldset.appendChild(legend); const targetSelects = []; objectConfigs.forEach(conf => { const control = createFormControl(conf); fieldset.appendChild(control); if (conf.property.endsWith('_animationLinkTarget')) { targetSelects.push(control.querySelector('select')); } }); form.appendChild(fieldset); targetSelects.forEach(select => { objects.forEach(otherObj => { if (otherObj.id !== id) { const option = document.createElement('option'); option.value = otherObj.id; option.textContent = otherObj.name || `Object ${otherObj.id}`; select.appendChild(option); } }); }); }); }
        function init() { const parser = new DOMParser(); const doc = parser.parseFromString(INITIAL_CONFIG_TEMPLATE, 'text/html'); configStore = Array.from(doc.querySelectorAll('meta')).map(parseMetaToConfig); createInitialObjects(); renderForm(); updateObjectsFromForm(); requestAnimationFrame(animate); }
        document.getElementById('add-object-btn').addEventListener('click', () => { const newId = (objects.reduce((max, o) => Math.max(max, o.id), 0)) + 1; const newConfigs = getDefaultObjectConfig(newId); configStore.push(...newConfigs); createInitialObjects(); renderForm(); updateObjectsFromForm(); });
        form.addEventListener('input', () => { updateObjectsFromForm(); });
        function animate(timestamp) { const now = timestamp; const deltaTime = (now - then) / 1000.0; then = now; ctx.clearRect(0, 0, canvas.width, canvas.height); objects.forEach(obj => obj.updateAnimationState({}, {}, deltaTime, objects)); objects.forEach(obj => obj.draw()); requestAnimationFrame(animate); }
        init();
    </script>
</body>
</html>