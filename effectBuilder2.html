<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Effect Header Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <template id="initial-config">
        <meta property="enableAnimation" label="Enable Animation" type="boolean" default="true">
        <meta property="obj1_shape" label="Object 1: Shape" type="combobox" default="rectangle" values="rectangle,circle,ring">
        <meta property="obj1_x" label="Object 1: X Position" type="number" default="50" min="0" max="1280">
        <meta property="obj1_y" label="Object 1: Y Position" type="number" default="50" min="0" max="800">
        <meta property="obj1_width" label="Object 1: Width/Outer Diameter" type="number" default="640" min="10" max="1280">
        <meta property="obj1_height" label="Object 1: Height" type="number" default="400" min="10" max="800">
        <meta property="obj1_innerDiameter" label="Object 1: Inner Diameter" type="number" default="200" min="5" max="1270">
        <meta property="obj1_numberOfSegments" label="Object 1: Segments" type="number" default="12" min="1" max="50">
        <meta property="obj1_angularWidth" label="Object 1: Segment Angle" type="number" default="20" min="1" max="90">
        <meta property="obj1_rotationSpeed" label="Object 1: Rotation Speed" type="number" default="0" min="-100" max="100">
        <meta property="obj1_animationSpeed" label="Object 1: Animation Speed" type="number" default="2" min="1" max="50">
        <meta property="obj1_scrollDir" label="Object 1: Scroll Direction" type="combobox" default="right" values="right,left,up,down">
        <meta property="obj1_gradType" label="Object 1: Fill Type" type="combobox" default="linear" values="solid,linear,radial,alternating">
        <meta property="obj1_useSharpGradient" label="Object 1: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj1_gradientStop" label="Object 1: Gradient Stop %" type="number" default="50" min="0" max="100">
        <meta property="obj1_gradColor1" label="Object 1: Color 1" type="color" default="#ff0000">
        <meta property="obj1_gradColor2" label="Object 1: Color 2" type="color" default="#ffff00">
        <meta property="obj1_cycleColors" label="Object 1: Cycle Colors" type="boolean" default="false">
        <meta property="obj1_cycleSpeed" label="Object 1: Color Cycle Speed" type="number" default="1" min="1" max="10">
        <meta property="obj2_shape" label="Object 2: Shape" type="combobox" default="circle" values="rectangle,circle,ring">
        <meta property="obj2_x" label="Object 2: X Position" type="number" default="800" min="0" max="1280">
        <meta property="obj2_y" label="Object 2: Y Position" type="number" default="100" min="0" max="800">
        <meta property="obj2_width" label="Object 2: Width/Outer Diameter" type="number" default="200" min="10" max="1280">
        <meta property="obj2_height" label="Object 2: Height" type="number" default="200" min="10" max="800">
        <meta property="obj2_innerDiameter" label="Object 2: Inner Diameter" type="number" default="100" min="5" max="1270">
        <meta property="obj2_numberOfSegments" label="Object 2: Segments" type="number" default="12" min="1" max="50">
        <meta property="obj2_angularWidth" label="Object 2: Segment Angle" type="number" default="15" min="1" max="90">
        <meta property="obj2_rotationSpeed" label="Object 2: Rotation Speed" type="number" default="0" min="-100" max="100">
        <meta property="obj2_animationSpeed" label="Object 2: Animation Speed" type="number" default="5" min="1" max="50">
        <meta property="obj2_scrollDir" label="Object 2: Scroll Direction" type="combobox" default="left" values="right,left,up,down">
        <meta property="obj2_gradType" label="Object 2: Fill Type" type="combobox" default="radial" values="solid,linear,radial,alternating">
        <meta property="obj2_useSharpGradient" label="Object 2: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj2_gradientStop" label="Object 2: Gradient Stop %" type="number" default="50" min="0" max="100">
        <meta property="obj2_gradColor1" label="Object 2: Color 1" type="color" default="#800080">
        <meta property="obj2_gradColor2" label="Object 2: Color 2" type="color" default="#0000ff">
        <meta property="obj2_cycleColors" label="Object 2: Cycle Colors" type="boolean" default="true">
        <meta property="obj2_cycleSpeed" label="Object 2: Color Cycle Speed" type="number" default="5" min="1" max="10">
        <meta property="obj3_shape" label="Object 3: Shape" type="combobox" default="ring" values="rectangle,circle,ring">
        <meta property="obj3_x" label="Object 3: X Position" type="number" default="800" min="0" max="1280">
        <meta property="obj3_y" label="Object 3: Y Position" type="number" default="450" min="0" max="800">
        <meta property="obj3_width" label="Object 3: Width/Outer Diameter" type="number" default="300" min="10" max="1280">
        <meta property="obj3_height" label="Object 3: Height" type="number" default="300" min="10" max="800">
        <meta property="obj3_innerDiameter" label="Object 3: Inner Diameter" type="number" default="200" min="5" max="1270">
        <meta property="obj3_numberOfSegments" label="Object 3: Segments" type="number" default="12" min="1" max="50">
        <meta property="obj3_angularWidth" label="Object 3: Segment Angle" type="number" default="20" min="1" max="90">
        <meta property="obj3_rotationSpeed" label="Object 3: Rotation Speed" type="number" default="10" min="-100" max="100">
        <meta property="obj3_animationSpeed" label="Object 3: Animation Speed" type="number" default="2" min="1" max="50">
        <meta property="obj3_scrollDir" label="Object 3: Scroll Direction" type="combobox" default="down" values="up,down,left,right">
        <meta property="obj3_gradType" label="Object 3: Fill Type" type="combobox" default="alternating" values="solid,linear,radial,alternating">
        <meta property="obj3_useSharpGradient" label="Object 3: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj3_gradientStop" label="Object 3: Gradient Stop %" type="number" default="50" min="0" max="100">
        <meta property="obj3_gradColor1" label="Object 3: Color 1" type="color" default="#00ff00">
        <meta property="obj3_gradColor2" label="Object 3: Color 2" type="color" default="#00ffff">
        <meta property="obj3_cycleColors" label="Object 3: Cycle Colors" type="boolean" default="true">
        <meta property="obj3_cycleSpeed" label="Object 3: Color Cycle Speed" type="number" default="2" min="1" max="10">
    </template>

    <style>
        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
        }
        body {
            background-color: #1a1a1a;
            color: #f8f9fa;
        }
        .form-control, .form-select {
            background-color: #343a40;
            color: #f8f9fa;
            border-color: #495057;
        }
        .form-control:focus, .form-select:focus {
            background-color: #495057;
            color: #f8f9fa;
            border-color: #0d6efd;
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, .25);
        }
        #canvas-container {
            width: 100%;
            position: relative;
            background-color: #222;
            aspect-ratio: 1280 / 800; /* Main aspect ratio for the container */
            max-height: calc(100vh - 250px); /* Prevent canvas from being too tall */
        }
        #signalCanvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .output-panel {
            min-height: 200px; /* Ensure output panel has a minimum height */
        }
        #output-script {
            font-family: monospace;
            white-space: pre;
            background-color: #222;
            color: #f8f9fa;
        }
        .toast-container {
             z-index: 1090;
        }
        .legend-button {
            background: none;
            border: none;
            color: inherit;
            padding: 0;
            font-size: 1.2rem;
            font-weight: bold;
            width: 100%;
            text-align: left;
        }
        .legend-button:not(.collapsed)::after {
            transform: rotate(-180deg);
        }
        .legend-button::after {
            content: '\f282'; /* Bootstrap Icon Chevron Down */
            font-family: 'bootstrap-icons';
            display: inline-block;
            transition: transform 0.2s ease-in-out;
            float: right;
        }
    </style>
</head>
<body class="d-flex flex-column vh-100">

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Effect Builder</a>
            <div class="d-flex">
                <button class="btn btn-outline-primary me-2" id="save-ws-btn"><i class="bi bi-save"></i> Save</button>
                <button class="btn btn-outline-secondary" id="load-ws-btn"><i class="bi bi-folder2-open"></i> Load</button>
            </div>
        </div>
    </nav>

    <div class="container-fluid flex-grow-1 overflow-hidden">
        <div class="row h-100">

            <div class="col-lg-4 col-md-5 h-100 py-3 border-end border-secondary">
                 <div class="h-100 overflow-auto pe-2">
                    <h4>Controls</h4>
                    <form id="controls-form"></form>
                 </div>
            </div>

            <div class="col-lg-8 col-md-7 d-flex flex-column py-3 h-100">
                <div class="d-flex align-items-center justify-content-center">
                    <div id="canvas-container">
                        <canvas id="signalCanvas"></canvas>
                    </div>
                </div>
                <div class="mt-3 flex-grow-1 d-flex flex-column output-panel">
                    <h5>Generated Script Header</h5>
                    <textarea id="output-script" class="form-control flex-grow-1" readonly></textarea>
                    <button class="btn btn-primary mt-2" id="copy-btn">
                        <i class="bi bi-clipboard"></i> Copy to Clipboard
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 end-0 p-3">
      <div id="copy-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header bg-success text-white">
          <strong class="me-auto">Success</strong>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
          The script header has been copied to your clipboard!
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
    // --- Start of Provided Script Logic (Adapted for this app) ---
    class Shape {
        constructor({
            shape, x, y, width, height, gradient, gradientType,
            gradientDirection, scrollDirection, cycleColors, cycleSpeed, animationSpeed, ctx,
            innerDiameter, angularWidth, numberOfSegments, rotationSpeed, useSharpGradient, gradientStop
        }) {
            this.shape = shape; this.x = x; this.y = y; this.width = width; this.height = height;
            this.gradient = gradient; this.gradientType = gradientType;
            this.gradientDirection = gradientDirection; this.scrollDirection = scrollDirection;
            this.cycleColors = cycleColors; this.cycleSpeed = cycleSpeed;
            this.animationSpeed = animationSpeed;
            this.ctx = ctx; this.hue1 = 0; this.hue2 = 90; this.scrollOffset = 0;
            this.innerDiameter = innerDiameter;
            this.angularWidth = angularWidth;
            this.numberOfSegments = numberOfSegments;
            this.rotationSpeed = rotationSpeed;
            this.rotationAngle = 0;
            this.useSharpGradient = useSharpGradient;
            this.gradientStop = gradientStop;
        }

        updateAnimationState() {
            if (this.cycleColors) {
                this.hue1 += this.cycleSpeed;
                this.hue2 += this.cycleSpeed;
            }
            if (this.gradient && this.gradientType !== 'solid') {
                const directionMultiplier = (this.scrollDirection === 'left' || this.scrollDirection === 'up' ? -1 : 1);
                this.scrollOffset += this.animationSpeed * directionMultiplier;
            }
            this.rotationAngle += (this.rotationSpeed / 1000);
        }

        createFillStyle() {
            const c1 = this.cycleColors ? `hsl(${(this.hue1 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color1;
            const c2 = this.cycleColors ? `hsl(${(this.hue2 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color2;
            const isLinear = this.gradientType.includes('linear');
            const isRadial = this.gradientType.includes('radial');
            if (isLinear || isRadial) {
                let grad;
                if (isLinear) {
                    const patternCanvas = document.createElement('canvas');
                    const patternCtx = patternCanvas.getContext('2d');
                    if (this.gradientDirection === 'horizontal') {
                        patternCanvas.width = this.width > 0 ? this.width : 1;
                        patternCanvas.height = 1;
                        grad = patternCtx.createLinearGradient(0, 0, this.width, 0);
                    } else {
                        patternCanvas.width = 1;
                        patternCanvas.height = this.height > 0 ? this.height : 1;
                        grad = patternCtx.createLinearGradient(0, 0, 0, this.height);
                    }
                    grad.isPattern = true;
                    grad.patternCanvas = patternCanvas;
                    grad.patternCtx = patternCtx;
                } else {
                    const centerX = this.x + this.width / 2;
                    const centerY = this.y + this.height / 2;
                    const maxRadius = Math.max(this.width, this.height) / 2;
                    grad = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
                }
                if (this.useSharpGradient) {
                    const stopPoint = this.gradientStop / 100.0;
                    grad.addColorStop(0, c1);
                    grad.addColorStop(stopPoint, c1);
                    grad.addColorStop(stopPoint, c2);
                    grad.addColorStop(1, c2);
                } else {
                    if (isRadial) {
                        const animatedStop = (1 + Math.sin(this.scrollOffset)) / 2;
                        grad.addColorStop(0, c1);
                        grad.addColorStop(animatedStop, c2);
                        grad.addColorStop(1, c1);
                    } else {
                        grad.addColorStop(0, c1);
                        grad.addColorStop(0.5, c2);
                        grad.addColorStop(1, c1);
                    }
                }
                if (grad.isPattern) {
                    grad.patternCtx.fillStyle = grad;
                    grad.patternCtx.fillRect(0, 0, grad.patternCanvas.width, grad.patternCanvas.height);
                    return this.ctx.createPattern(grad.patternCanvas, 'repeat');
                }
                return grad;
            }
        }
        
        draw(enableAnimation) {
            this.ctx.save();
            if (enableAnimation) {
                this.updateAnimationState();
            }
            if (this.gradientType === 'solid') {
                this.ctx.fillStyle = this.cycleColors ? `hsl(${(this.hue1 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color1;
            } else if (this.gradientType !== 'alternating') {
                this.ctx.fillStyle = this.gradient ? this.createFillStyle() : 'black';
            }
            this.ctx.save();
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(this.rotationAngle);
            this.ctx.translate(-centerX, -centerY);
            switch (this.shape) {
                case 'rectangle':
                case 'circle': {
                    const isLinear = this.gradient && this.gradientType.includes('linear');
                    const transX = isLinear && this.gradientDirection === 'horizontal' ? this.scrollOffset % this.width : 0;
                    const transY = isLinear && this.gradientDirection === 'vertical' ? this.scrollOffset % this.height : 0;
                    this.ctx.save();
                    if (isLinear) { this.ctx.translate(transX, transY); }
                    if (this.shape === 'rectangle') {
                        this.ctx.fillRect(this.x - transX, this.y - transY, this.width, this.height);
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(this.x + this.width / 2 - transX, this.y + this.height / 2 - transY, this.width / 2, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                    this.ctx.restore();
                    break;
                }
                case 'ring': {
                    const outerRadius = this.width / 2;
                    const innerRadius = this.innerDiameter / 2;
                    if (innerRadius >= 0 && innerRadius < outerRadius && this.numberOfSegments > 0) {
                        const anglePerSlot = (Math.PI * 2) / this.numberOfSegments;
                        const segmentAngleRad = Math.min(this.angularWidth * (Math.PI / 180), anglePerSlot);
                        const angleOffset = (anglePerSlot - segmentAngleRad) / 2;
                        if (this.gradientType !== 'alternating') { this.ctx.beginPath(); }
                        for (let i = 0; i < this.numberOfSegments; i++) {
                            if (this.gradientType === 'alternating') {
                                this.ctx.fillStyle = (i % 2 === 0) ? this.gradient.color1 : this.gradient.color2;
                                this.ctx.beginPath();
                            }
                            const startAngle = (i * anglePerSlot) + angleOffset;
                            const endAngle = startAngle + segmentAngleRad;
                            this.ctx.moveTo(centerX + innerRadius * Math.cos(startAngle), centerY + innerRadius * Math.sin(startAngle));
                            this.ctx.arc(centerX, centerY, innerRadius, startAngle, endAngle);
                            this.ctx.lineTo(centerX + outerRadius * Math.cos(endAngle), centerY + outerRadius * Math.sin(endAngle));
                            this.ctx.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
                            this.ctx.closePath();
                            if (this.gradientType === 'alternating') { this.ctx.fill(); }
                        }
                        if (this.gradientType !== 'alternating') { this.ctx.fill(); }
                    }
                    break;
                }
            }
            this.ctx.restore();
            this.ctx.restore();
        }

        update(props) {
            for (const key in props) {
                if (props[key] !== undefined) {
                    if (key === 'gradient' && typeof props[key] === 'object' && props[key] !== null) {
                        if (props.gradient.color1 !== undefined) this.gradient.color1 = props.gradient.color1;
                        if (props.gradient.color2 !== undefined) this.gradient.color2 = props.gradient.color2;
                    } else if (this.hasOwnProperty(key)) {
                        this[key] = props[key];
                    }
                }
            }
        }
    }
    // --- End of Provided Script Logic ---


    // --- Application Controller ---
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('signalCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1280;
        canvas.height = 800;

        const form = document.getElementById('controls-form');
        const outputScriptArea = document.getElementById('output-script');
        const copyBtn = document.getElementById('copy-btn');
        const copyToastEl = document.getElementById('copy-toast');
        const copyToast = new bootstrap.Toast(copyToastEl);

        let configStore = []; // The single source of truth for all meta properties
        let objects = [];

        function parseMetaToConfig(metaElement) {
            const config = {};
            for (const attr of metaElement.attributes) {
                config[attr.name] = attr.value;
            }
            return config;
        }

        function groupConfigs(flatConfig) {
            const grouped = { general: [], objects: {} };
            flatConfig.forEach(config => {
                const prop = config.property;
                if(prop.startsWith('obj')) {
                    const match = prop.match(/^obj(\d+)_/);
                    const id = match[1];
                    if(!grouped.objects[id]) grouped.objects[id] = [];
                    grouped.objects[id].push(config);
                } else {
                    grouped.general.push(config);
                }
            });
            return grouped;
        }

        function createFormControl(config) {
             const { property, label, type, default: defaultValue, values, min, max } = config;

            const formGroup = document.createElement('div');
            formGroup.className = 'mb-2';
            
            const labelEl = document.createElement('label');
            labelEl.htmlFor = property;
            labelEl.className = 'form-label small';
            labelEl.textContent = label.substring(label.indexOf(':') + 1).trim(); // Clean up label
            formGroup.appendChild(labelEl);

            if (type === 'combobox') {
                const vals = values.split(',');
                const select = document.createElement('select');
                select.id = property;
                select.className = 'form-select form-select-sm';
                select.name = property;
                vals.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = val.charAt(0).toUpperCase() + val.slice(1);
                    if (val === defaultValue) option.selected = true;
                    select.appendChild(option);
                });
                formGroup.appendChild(select);
            } else if (type === 'boolean') {
                const check = document.createElement('input');
                check.id = property;
                check.type = 'checkbox';
                check.className = 'form-check-input ms-2';
                check.name = property;
                check.checked = (defaultValue === 'true');
                formGroup.appendChild(check);
            } else {
                const input = document.createElement('input');
                input.id = property;
                input.className = 'form-control form-control-sm';
                input.name = property;
                input.type = type;
                input.value = defaultValue;
                if (min) input.min = min;
                if (max) input.max = max;
                if (type === 'number') input.step = "1";
                formGroup.appendChild(input);
            }
            return formGroup;
        }

        function renderForm() {
            const grouped = groupConfigs(configStore);
            form.innerHTML = ''; // Clear the form

            // Render general controls
            const generalFieldset = document.createElement('fieldset');
            generalFieldset.className = 'border p-3 mb-3';
            const generalLegend = document.createElement('legend');
            generalLegend.className = 'float-none w-auto p-2 fs-6';
            generalLegend.textContent = 'General Settings';
            generalFieldset.appendChild(generalLegend);
            grouped.general.forEach(conf => generalFieldset.appendChild(createFormControl(conf)));
            form.appendChild(generalFieldset);

            // Render object controls
            Object.keys(grouped.objects).sort((a,b) => a - b).forEach(id => {
                const objectConfigs = grouped.objects[id];
                const fieldset = document.createElement('fieldset');
                fieldset.className = 'border p-2 mb-3';
                fieldset.dataset.objectId = id;

                const legendContainer = document.createElement('legend');
                legendContainer.className = 'float-none w-auto p-2 d-flex justify-content-between align-items-center';

                const collapseId = `collapse-obj-${id}`;
                const collapseButton = document.createElement('button');
                collapseButton.className = 'legend-button collapsed';
                collapseButton.type = 'button';
                collapseButton.dataset.bsToggle = 'collapse';
                collapseButton.dataset.bsTarget = `#${collapseId}`;
                collapseButton.setAttribute('aria-expanded', 'false');
                collapseButton.textContent = `Object ${id}`;

                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'btn-group btn-group-sm';

                const duplicateBtn = document.createElement('button');
                duplicateBtn.type = 'button';
                duplicateBtn.className = 'btn btn-outline-secondary btn-duplicate';
                duplicateBtn.innerHTML = '<i class="bi bi-copy"></i>';
                duplicateBtn.title = `Duplicate Object ${id}`;
                duplicateBtn.dataset.id = id;

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'btn btn-outline-danger btn-delete';
                deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                deleteBtn.title = `Delete Object ${id}`;
                deleteBtn.dataset.id = id;
                
                buttonGroup.appendChild(duplicateBtn);
                buttonGroup.appendChild(deleteBtn);
                
                legendContainer.appendChild(collapseButton);
                legendContainer.appendChild(buttonGroup);

                const collapseWrapper = document.createElement('div');
                collapseWrapper.id = collapseId;
                collapseWrapper.className = 'collapse p-2';

                objectConfigs.forEach(conf => collapseWrapper.appendChild(createFormControl(conf)));
                
                fieldset.appendChild(legendContainer);
                fieldset.appendChild(collapseWrapper);
                form.appendChild(fieldset);
            });
            
            // Re-apply values from the form to handle state after re-render
            setFormValues(getControlValues());
        }

        function reindexAndRender() {
            const currentValues = getControlValues();
            const grouped = groupConfigs(configStore);
            let newConfigStore = [...grouped.general];
            let newObjIndex = 1;
            Object.keys(grouped.objects).sort((a,b) => a - b).forEach(oldId => {
                grouped.objects[oldId].forEach(conf => {
                    const oldProp = conf.property;
                    const newProp = oldProp.replace(`obj${oldId}_`, `obj${newObjIndex}_`);
                    const oldLabel = conf.label;
                    const newLabel = oldLabel.replace(`Object ${oldId}:`, `Object ${newObjIndex}:`);

                    const newConf = {...conf, property: newProp, label: newLabel};
                    
                    // Try to carry over the value from the old property name
                    if(currentValues[oldProp] !== undefined) {
                        newConf.default = currentValues[oldProp];
                    }
                    newConfigStore.push(newConf);
                });
                newObjIndex++;
            });
            configStore = newConfigStore;
            renderForm();
            initializeObjectsAndAnimate();
        }

        function getControlValues() {
            const formData = new FormData(form);
            const data = {};
            // Use configStore to find all possible inputs, not just what FormData returns
            configStore.forEach(conf => {
                const key = conf.property;
                const el = form.elements[key];
                if (el) {
                    if (el.type === 'checkbox') {
                        data[key] = el.checked;
                    } else if (el.type === 'number') {
                        data[key] = parseFloat(formData.get(key) || el.value);
                    } else {
                        data[key] = formData.get(key) || el.value;
                    }
                }
            });
            return data;
        }

        function updateShapes() {
            const values = getControlValues();
            objects.forEach((shape, index) => {
                const id = index + 1;
                const prefix = `obj${id}_`;
                const get = (prop, def) => values[`${prefix}${prop}`] !== undefined ? values[`${prefix}${prop}`] : def;
                const gradType = get('gradType', shape.gradientType);
                const scrollDir = get('scrollDir', shape.scrollDirection);
                let speed = get('animationSpeed', 5);
                if (gradType.includes('radial')) { speed /= 100.0; } 
                else { speed = parseInt(speed); }
                shape.update({
                    x: parseInt(get('x', shape.x)),
                    y: parseInt(get('y', shape.y)),
                    width: parseInt(get('width', shape.width)),
                    height: parseInt(get('height', shape.height)),
                    shape: get('shape', shape.shape),
                    gradientType: gradType,
                    gradient: { color1: get('gradColor1', shape.gradient.color1), color2: get('gradColor2', shape.gradient.color2) },
                    animationSpeed: speed,
                    scrollDirection: scrollDir,
                    gradientDirection: (scrollDir === 'up' || scrollDir === 'down') ? 'vertical' : 'horizontal',
                    cycleColors: get('cycleColors', shape.cycleColors),
                    cycleSpeed: get('cycleSpeed', 1) / 100.0,
                    innerDiameter: parseInt(get('innerDiameter', shape.innerDiameter)),
                    angularWidth: parseInt(get('angularWidth', shape.angularWidth)),
                    numberOfSegments: parseInt(get('numberOfSegments', shape.numberOfSegments)),
                    rotationSpeed: parseInt(get('rotationSpeed', shape.rotationSpeed)),
                    useSharpGradient: get('useSharpGradient', shape.useSharpGradient),
                    gradientStop: parseInt(get('gradientStop', shape.gradientStop)),
                });
            });
        }
        
        function generateOutputScript() {
            const values = getControlValues();
            let scriptHTML = '';
            configStore.forEach(config => {
                const value = values[config.property];
                let line = `<meta property="${config.property}"`;
                Object.keys(config).forEach(attrName => {
                    if(attrName !== 'property' && attrName !== 'default' && attrName !== 'class') {
                        line += ` ${attrName}="${config[attrName]}"`;
                    }
                });
                line += ` default="${value}">\n`;
                scriptHTML += line;
            });
            outputScriptArea.value = scriptHTML.trim();
        }

        function animate() {
            const values = getControlValues();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const enableAnimation = values['enableAnimation'] === true;
            objects.forEach(obj => obj.draw(enableAnimation));
            requestAnimationFrame(animate);
        }

        function setFormValues(data) {
            for (const key in data) {
                const el = form.elements[key];
                if (el) {
                    if (el.type === 'checkbox') {
                        el.checked = data[key];
                    } else {
                        el.value = data[key];
                    }
                }
            }
            updateAll();
        }

        function buildStatesFromConfig() {
            const values = getControlValues();
            const grouped = groupConfigs(configStore);
            const finalStates = [];

            Object.keys(grouped.objects).forEach(id => {
                const config = { id: parseInt(id), gradient: {} };
                grouped.objects[id].forEach(conf => {
                    const key = conf.property.replace(`obj${id}_`, '');
                    let value = values[conf.property];
                    if (key.startsWith('gradColor')) {
                        config.gradient[key.replace('grad', '').toLowerCase()] = value;
                    } else if(key === 'scrollDir') {
                        config.scrollDirection = value;
                    } else {
                        config[key] = value;
                    }
                });
                // Processing
                config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                config.cycleSpeed = (config.cycleSpeed || 0) / 100.0;
                const speed = config.animationSpeed || 0;
                const gradType = config.gradType || 'solid';
                config.animationSpeed = (gradType.includes('radial')) ? speed / 100.0 : speed;
                if (config.shape === 'ring') {
                    config.height = config.width;
                }
                finalStates.push(config);
            });
            return finalStates;
        }

        function initializeObjectsAndAnimate() {
            const initialStates = buildStatesFromConfig();
            objects = initialStates.map(state => new Shape({ ...state, ctx }));
            updateAll();
        }

        function updateAll() {
            updateShapes();
            generateOutputScript();
        }

        // --- Event Listeners ---
        form.addEventListener('input', updateAll);

        form.addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.btn-delete');
            const duplicateBtn = e.target.closest('.btn-duplicate');

            if(deleteBtn) {
                const id = deleteBtn.dataset.id;
                configStore = configStore.filter(conf => !conf.property.startsWith(`obj${id}_`));
                reindexAndRender();
            }

            if(duplicateBtn) {
                const id = duplicateBtn.dataset.id;
                const values = getControlValues();
                const newId = Object.keys(groupConfigs(configStore).objects).length + 1;
                const configsToCopy = configStore.filter(conf => conf.property.startsWith(`obj${id}_`));
                
                const newConfigs = configsToCopy.map(conf => {
                    const newConf = {...conf}; // shallow copy
                    newConf.property = newConf.property.replace(`obj${id}_`, `obj${newId}_`);
                    newConf.label = newConf.label.replace(`Object ${id}:`, `Object ${newId}:`);
                    newConf.default = values[conf.property]; // Use current value as new default
                    return newConf;
                });

                configStore.push(...newConfigs);
                reindexAndRender();
            }
        });

        copyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(outputScriptArea.value).then(() => {
                copyToast.show();
            });
        });

        document.getElementById('save-ws-btn').addEventListener('click', () => {
            const values = getControlValues();
            localStorage.setItem('effectBuilderWorkspace', JSON.stringify(values));
            alert('Workspace saved!');
        });

        document.getElementById('load-ws-btn').addEventListener('click', () => {
            const savedData = localStorage.getItem('effectBuilderWorkspace');
            if (savedData) {
                const data = JSON.parse(savedData);
                // We need to rebuild the form based on the loaded data's structure
                const loadedConfig = [];
                Object.keys(data).forEach(prop => {
                    // This is a simplified load; it assumes the base structure hasn't changed drastically
                    // A more robust solution would store the configStore itself
                    const originalConf = configStore.find(c => c.property === prop) || {};
                    loadedConfig.push({...originalConf, property: prop, default: data[prop]});
                });
                configStore = loadedConfig;
                reindexAndRender();
                alert('Workspace loaded!');
            } else {
                alert('No saved workspace found.');
            }
        });
        
        // --- Initialization ---
        function init() {
            const template = document.getElementById('initial-config');
            const metaElements = Array.from(template.content.querySelectorAll('meta'));
            configStore = metaElements.map(parseMetaToConfig);
            
            renderForm();
            initializeObjectsAndAnimate();
            animate();
        }

        init();
    });
    </script>

</body>
</html>