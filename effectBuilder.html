<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignalRGB Effect Meta Tag Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .controls-column::-webkit-scrollbar { width: 8px; }
        .controls-column::-webkit-scrollbar-track { background: #1f2937; }
        .controls-column::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .controls-column::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        #output-code::-webkit-scrollbar { height: 8px; }
        #output-code::-webkit-scrollbar-track { background: #111827; }
        #output-code::-webkit-scrollbar-thumb { background: #374151; border-radius: 4px; }
        #output-code::-webkit-scrollbar-thumb:hover { background: #4b5563; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        /* Custom styles for the range slider track and thumb */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
            margin-top: -6px; /* You need to specify a margin in Chrome, but not in Firefox */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="app" class="flex flex-col md:flex-row h-screen">

        <div class="w-full md:w-1/3 lg:w-1/4 p-4 md:p-6 overflow-y-auto controls-column">
            <header class="mb-6">
                <h1 class="text-2xl font-bold text-white">Effect Controls</h1>
                <p class="text-gray-400 mt-1">Add and configure objects below.</p>
            </header>

            <div id="objects-container" class="space-y-6">
                </div>

            <button onclick="addObject()" class="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                + Add New Object
            </button>
        </div>
        
        <div class="w-full md:w-1/3 lg:w-1/2 bg-gray-800 p-4 md:p-6 flex flex-col h-full border-l border-r border-gray-700">
            <h2 class="text-xl font-semibold text-white mb-4 text-center">Live Preview</h2>
            <div class="relative w-full h-full bg-gray-900 rounded-lg overflow-hidden">
                <canvas id="previewCanvas" class="w-full h-full"></canvas>
            </div>
        </div>

        <div class="w-full md:w-1/3 lg:w-1/4 bg-gray-800 p-4 md:p-6 flex flex-col h-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-white">Generated Meta Tags</h2>
                <button onclick="copyMetaTags()" id="copy-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                    Copy
                </button>
            </div>
            <div class="bg-gray-900 rounded-lg p-4 flex-grow h-0">
                <pre class="h-full overflow-auto"><code id="output-code" class="text-sm text-yellow-300 whitespace-pre"></code></pre>
            </div>
            <p id="copy-feedback" class="text-center text-green-400 mt-2 opacity-0 transition-opacity duration-500">Copied!</p>
        </div>
    </div>

    <script>
        // ===================================================================================
        // THE FULL SHAPE CLASS (Copied from the working effect)
        // ===================================================================================
        class Shape {
            constructor({
                shape, x, y, width, height, gradient, gradientType,
                gradientDirection, scrollDirection, cycleColors, cycleSpeed, animationSpeed, ctx,
                innerDiameter, angularWidth, numberOfSegments, rotationSpeed, useSharpGradient, gradientStop
            }) {
                this.shape = shape; this.x = x; this.y = y; this.width = width; this.height = height;
                this.gradient = gradient; this.gradientType = gradientType;
                this.gradientDirection = gradientDirection; this.scrollDirection = scrollDirection;
                this.cycleColors = cycleColors; this.cycleSpeed = cycleSpeed;
                this.animationSpeed = animationSpeed;
                this.ctx = ctx; this.hue1 = 0; this.hue2 = 90; this.scrollOffset = 0;
                this.innerDiameter = innerDiameter;
                this.angularWidth = angularWidth;
                this.numberOfSegments = numberOfSegments;
                this.rotationSpeed = rotationSpeed;
                this.rotationAngle = 0;
                this.useSharpGradient = useSharpGradient;
                this.gradientStop = gradientStop;
            }
            updateAnimationState() {
                if (this.cycleColors) {
                    this.hue1 += this.cycleSpeed;
                    this.hue2 += this.cycleSpeed;
                }
                if (this.gradient && this.gradientType !== 'solid') {
                    const directionMultiplier = (this.scrollDirection === 'left' || this.scrollDirection === 'up' ? -1 : 1);
                    this.scrollOffset += this.animationSpeed * directionMultiplier;
                }
                this.rotationAngle += (this.rotationSpeed / 1000);
            }
            createFillStyle() {
                const c1 = this.cycleColors ? `hsl(${(this.hue1 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color1;
                const c2 = this.cycleColors ? `hsl(${(this.hue2 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color2;
                const isLinear = this.gradientType.includes('linear');
                const isRadial = this.gradientType.includes('radial');
                if (isLinear || isRadial) {
                    let grad;
                    if (isLinear) {
                        const patternCanvas = document.createElement('canvas');
                        const patternCtx = patternCanvas.getContext('2d');
                        if (this.gradientDirection === 'horizontal') {
                            patternCanvas.width = this.width > 0 ? this.width : 1;
                            patternCanvas.height = 1;
                            grad = patternCtx.createLinearGradient(0, 0, this.width, 0);
                        } else {
                            patternCanvas.width = 1;
                            patternCanvas.height = this.height > 0 ? this.height : 1;
                            grad = patternCtx.createLinearGradient(0, 0, 0, this.height);
                        }
                        grad.isPattern = true;
                        grad.patternCanvas = patternCanvas;
                        grad.patternCtx = patternCtx;
                    } else {
                        const centerX = this.x + this.width / 2;
                        const centerY = this.y + this.height / 2;
                        const maxRadius = Math.max(this.width, this.height) / 2;
                        grad = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
                    }
                    if (this.useSharpGradient) {
                        const stopPoint = isRadial ? (1 + Math.sin(this.scrollOffset)) / 2 : this.gradientStop / 100.0;
                        grad.addColorStop(0, c1);
                        grad.addColorStop(stopPoint, c1);
                        grad.addColorStop(stopPoint, c2);
                        grad.addColorStop(1, c2);
                    } else {
                        if (isRadial) {
                             const animatedStop = (1 + Math.sin(this.scrollOffset)) / 2;
                             grad.addColorStop(0, c1);
                             grad.addColorStop(animatedStop, c1);
                             grad.addColorStop(1, c2);
                        } else {
                             grad.addColorStop(0, c1);
                             grad.addColorStop(0.5, c2);
                             grad.addColorStop(1, c1);
                        }
                    }
                    if (grad.isPattern) {
                        grad.patternCtx.fillStyle = grad;
                        grad.patternCtx.fillRect(0, 0, grad.patternCanvas.width, grad.patternCanvas.height);
                        return this.ctx.createPattern(grad.patternCanvas, 'repeat');
                    }
                    return grad;
                }
            }
            draw() {
                this.ctx.save();
                this.updateAnimationState();
                if (this.gradientType === 'solid') {
                    this.ctx.fillStyle = this.cycleColors ? `hsl(${(this.hue1 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color1;
                } else if (this.gradientType !== 'alternating') {
                    this.ctx.fillStyle = this.gradient ? this.createFillStyle() : 'black';
                }
                this.ctx.save();
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(this.rotationAngle);
                this.ctx.translate(-centerX, -centerY);
                switch (this.shape) {
                    case 'rectangle':
                    case 'circle': {
                        const isLinear = this.gradient && this.gradientType.includes('linear');
                        const transX = isLinear && this.gradientDirection === 'horizontal' ? this.scrollOffset : 0;
                        const transY = isLinear && this.gradientDirection === 'vertical' ? this.scrollOffset : 0;
                        this.ctx.save();
                        if (isLinear) {
                            this.ctx.translate(transX, transY);
                        }
                        if (this.shape === 'rectangle') {
                            this.ctx.fillRect(this.x - transX, this.y - transY, this.width, this.height);
                        } else {
                            this.ctx.beginPath();
                            this.ctx.arc(this.x + this.width / 2 - transX, this.y + this.height / 2 - transY, this.width / 2, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                        this.ctx.restore();
                        break;
                    }
                    case 'ring': {
                        const outerRadius = this.width / 2;
                        const innerRadius = this.innerDiameter / 2;
                        if (innerRadius >= 0 && innerRadius < outerRadius && this.numberOfSegments > 0) {
                            const anglePerSlot = (Math.PI * 2) / this.numberOfSegments;
                            const segmentAngleRad = Math.min(this.angularWidth * (Math.PI / 180), anglePerSlot);
                            const angleOffset = (anglePerSlot - segmentAngleRad) / 2;
                            if (this.gradientType !== 'alternating') {
                               this.ctx.beginPath();
                            }
                            for (let i = 0; i < this.numberOfSegments; i++) {
                                if (this.gradientType === 'alternating') {
                                    this.ctx.fillStyle = (i % 2 === 0) ? this.gradient.color1 : this.gradient.color2;
                                    this.ctx.beginPath();
                                }
                                const startAngle = (i * anglePerSlot) + angleOffset;
                                const endAngle = startAngle + segmentAngleRad;
                                this.ctx.moveTo(centerX + innerRadius * Math.cos(startAngle), centerY + innerRadius * Math.sin(startAngle));
                                this.ctx.arc(centerX, centerY, innerRadius, startAngle, endAngle);
                                this.ctx.lineTo(centerX + outerRadius * Math.cos(endAngle), centerY + outerRadius * Math.sin(endAngle));
                                this.ctx.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
                                this.ctx.closePath();
                                if (this.gradientType === 'alternating') {
                                    this.ctx.fill();
                                }
                            }
                            if (this.gradientType !== 'alternating') {
                                this.ctx.fill();
                            }
                        }
                        break;
                    }
                }
                this.ctx.restore();
                this.ctx.restore();
            }
        }
        
        // ===================================================================================
        // UI STATE & GENERATOR LOGIC
        // ===================================================================================
        let objects = [];
        let previewShapes = [];
        let nextObjectId = 1;

        const defaultObjectState = {
            label: 'New Object', shape: 'rectangle', x: 50, y: 50, width: 300, height: 200,
            gradient: { color1: "#ff0000", color2: "#ffff00" }, gradType: 'linear',
            scrollDirection: 'right', animationSpeed: 2, cycleColors: false, cycleSpeed: 1,
            rotationSpeed: 0, useSharpGradient: false, gradientStop: 50, innerDiameter: 150,
            angularWidth: 20, numberOfSegments: 12
        };

        // Initialize objects based on the provided meta tags
        const initialObjectConfigurations = [
            {
                label: "Object 1",
                shape: "rectangle", x: 50, y: 50, width: 640, height: 400,
                innerDiameter: 200, numberOfSegments: 12, angularWidth: 20, rotationSpeed: 0,
                animationSpeed: 2, scrollDirection: "right", gradType: "linear",
                useSharpGradient: false, gradientStop: 50, gradient: { color1: "#ff0000", color2: "#ffff00" },
                cycleColors: false, cycleSpeed: 1
            },
            {
                label: "Object 2",
                shape: "circle", x: 800, y: 100, width: 200, height: 200,
                innerDiameter: 100, numberOfSegments: 12, angularWidth: 15, rotationSpeed: 0,
                animationSpeed: 5, scrollDirection: "left", gradType: "radial",
                useSharpGradient: false, gradientStop: 50, gradient: { color1: "#800080", color2: "#0000ff" },
                cycleColors: true, cycleSpeed: 5
            },
            {
                label: "Object 3",
                shape: "ring", x: 800, y: 450, width: 300, height: 300,
                innerDiameter: 200, numberOfSegments: 12, angularWidth: 20, rotationSpeed: 10,
                animationSpeed: 2, scrollDirection: "down", gradType: "alternating",
                useSharpGradient: false, gradientStop: 50, gradient: { color1: "#00ff00", color2: "#00ffff" },
                cycleColors: true, cycleSpeed: 2
            }
        ];

        function addObject(config = null) {
            const newObject = config ? 
                { ...JSON.parse(JSON.stringify(config)), id: nextObjectId } :
                { ...JSON.parse(JSON.stringify(defaultObjectState)), id: nextObjectId, label: `Object ${nextObjectId}` };
            
            objects.push(newObject);
            nextObjectId++;
            render();
        }

        function removeObject(id) {
            objects = objects.filter(obj => obj.id !== id);
            render();
        }
        
        function updateObject(id, key, value) {
            const object = objects.find(obj => obj.id === id);
            if (!object) return;
            
            const target = event.target;
            
            if(target.type === 'checkbox') {
                value = target.checked;
            } else if (target.type === 'number' || target.type === 'range') {
                value = parseFloat(value) || 0;
            }

            if (key.startsWith('gradColor')) {
                object.gradient[key.replace('gradColor','color')] = value;
            } else {
                object[key] = value;
            }
            if (key === 'shape') {
                renderObjectControls();
            }
            renderMetaTags();
        }

        function copyMetaTags() {
            const codeElement = document.getElementById('output-code');
            const textToCopy = codeElement.innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = textToCopy;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);
            const feedback = document.getElementById('copy-feedback');
            feedback.style.opacity = '1';
            setTimeout(() => {
                feedback.style.opacity = '0';
            }, 2000);
        }

        function render() {
            renderObjectControls();
            renderMetaTags();
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            previewShapes = objects.map(o => new Shape({ ...o, ctx }));
        }

        function renderObjectControls() {
            const container = document.getElementById('objects-container');
            container.innerHTML = ''; 
            objects.forEach(obj => {
                const isRing = obj.shape === 'ring';
                const isRectangle = obj.shape === 'rectangle';

                const card = document.createElement('div');
                card.className = 'bg-gray-800 p-4 rounded-lg border border-gray-700';
                card.innerHTML = `
                    <div class="flex justify-between items-center mb-4">
                        <input type="text" value="${obj.label}" oninput="updateObject(${obj.id}, 'label', this.value)" 
                               class="text-lg font-bold text-white bg-gray-700 w-2/3 focus:outline-none rounded-md px-2 py-1 placeholder-gray-400"
                               placeholder="Object Label">
                        <button onclick="removeObject(${obj.id})" class="text-gray-400 hover:text-white px-3 py-1 rounded-md hover:bg-red-800/50 transition-colors">&times; Remove</button>
                    </div>
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                            ${createSelectControl(obj, 'shape', 'Shape', 'rectangle,circle,ring')}
                            ${createSelectControl(obj, 'gradType', 'Fill Type', 'solid,linear,radial,alternating')}
                        </div>
                        <hr class="border-gray-700"/>
                        ${createSliderControl(obj, 'x', 'X Position', { min: 0, max: 1280 })}
                        ${createSliderControl(obj, 'y', 'Y Position', { min: 0, max: 800 })}
                        ${createSliderControl(obj, 'width', isRing ? 'Outer Diameter' : 'Width', { min: 10, max: 1280 })}
                        ${isRectangle ? createSliderControl(obj, 'height', 'Height', { min: 10, max: 800 }) : ''}
                        ${isRing ? createSliderControl(obj, 'innerDiameter', 'Inner Diameter', { min: 5, max: 1270 }) : ''}
                        ${isRing ? createSliderControl(obj, 'numberOfSegments', 'Segments', { min: 1, max: 50 }) : ''}
                        ${isRing ? createSliderControl(obj, 'angularWidth', 'Segment Angle', { min: 1, max: 90 }) : ''}
                        <hr class="border-gray-700"/>
                        <div class="grid grid-cols-2 gap-4">
                            ${createColorControl(obj, 'gradColor1', 'Color 1')}
                            ${createColorControl(obj, 'gradColor2', 'Color 2')}
                        </div>
                        ${createSliderControl(obj, 'rotationSpeed', 'Rotation Speed', { min: -100, max: 100, step: 1 })}
                        ${createSliderControl(obj, 'animationSpeed', 'Animation Speed', { min: 1, max: 50 })}
                        ${createSelectControl(obj, 'scrollDirection', 'Scroll Direction', 'right,left,up,down')}
                        <hr class="border-gray-700"/>
                        <div class="grid grid-cols-2 gap-4">
                            ${createCheckboxControl(obj, 'useSharpGradient', 'Use Sharp Gradient')}
                            ${createSliderControl(obj, 'gradientStop', 'Gradient Stop %', { min: 0, max: 100 })}
                        </div>
                           <div class="grid grid-cols-2 gap-4">
                            ${createCheckboxControl(obj, 'cycleColors', 'Cycle Colors')}
                            ${createSliderControl(obj, 'cycleSpeed', 'Color Cycle Speed', { min: 1, max: 10 })}
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });
        }
        
        function createSliderControl(obj, key, label, {min, max, step = 1}) {
            const sliderId = `obj${obj.id}_${key}_slider`;
            const numberId = `obj${obj.id}_${key}_number`;
            const currentValue = key.startsWith('gradColor') ? obj.gradient[key.replace('gradColor', 'color')] : obj[key];
            return `
                <div>
                    <label for="${sliderId}" class="block text-sm font-medium text-gray-300">${label}</label>
                    <div class="flex items-center space-x-2 mt-1">
                        <input type="range" id="${sliderId}" name="${key}" value="${currentValue}" min="${min}" max="${max}" step="${step}" 
                               oninput="document.getElementById('${numberId}').value = this.value; updateObject(${obj.id}, '${key}', this.value)"
                               class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <input type="number" id="${numberId}" value="${currentValue}" min="${min}" max="${max}" step="${step}" 
                               oninput="document.getElementById('${sliderId}').value = this.value; updateObject(${obj.id}, '${key}', this.value)"
                               class="w-20 bg-gray-900 border border-gray-600 rounded-md py-1 px-2 text-white text-center">
                    </div>
                </div>
            `;
        }
        function createSelectControl(obj, key, label, options) {
            const optionElements = options.split(',').map(opt => `<option value="${opt}" ${obj[key] === opt ? 'selected' : ''}>${opt.charAt(0).toUpperCase() + opt.slice(1)}</option>`).join('');
            return `
                <div>
                    <label class="block text-sm font-medium text-gray-300">${label}</label>
                    <select onchange="updateObject(${obj.id}, '${key}', this.value)"
                            class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        ${optionElements}
                    </select>
                </div>
            `;
        }
        function createColorControl(obj, key, label) {
             return `
                 <div class="flex items-center justify-between">
                     <label class="block text-sm font-medium text-gray-300">${label}</label>
                     <input type="color" value="${obj.gradient[key.replace('gradColor','color')]}" oninput="updateObject(${obj.id}, '${key}', this.value)"
                            class="w-10 h-10 p-1 bg-gray-700 border border-gray-600 rounded-md cursor-pointer">
                 </div>
             `;
        }
        function createCheckboxControl(obj, key, label) {
            return `
                <div class="flex items-center mt-2">
                    <input type="checkbox" ${obj[key] ? 'checked' : ''} onchange="updateObject(${obj.id}, '${key}', this.checked, true)"
                           class="h-4 w-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500">
                    <label class="ml-2 block text-sm text-gray-300">${label}</label>
                </div>
            `;
        }
        function renderMetaTags() {
            const outputElement = document.getElementById('output-code');
            let metaString = '<meta property="enableAnimation" label="Enable Animation" type="boolean" default="true">\n\n';

            objects.forEach(obj => {
                const prefix = `obj${obj.id}_`;
                metaString += `\n`;
                metaString += `<meta property="${prefix}shape" label="${obj.label}: Shape" type="combobox" default="${obj.shape}" values="rectangle,circle,ring">\n`;
                metaString += `<meta property="${prefix}x" label="${obj.label}: X Position" type="number" default="${obj.x}" min="0" max="1280">\n`;
                metaString += `<meta property="${prefix}y" label="${obj.label}: Y Position" type="number" default="${obj.y}" min="0" max="800">\n`;
                metaString += `<meta property="${prefix}width" label="${obj.label}: Width/Outer Diameter" type="number" default="${obj.width}" min="10" max="1280">\n`;
                metaString += `<meta property="${prefix}height" label="${obj.label}: Height" type="number" default="${obj.height}" min="10" max="800">\n`;
                metaString += `<meta property="${prefix}innerDiameter" label="${obj.label}: Inner Diameter" type="number" default="${obj.innerDiameter}" min="5" max="1270">\n`;
                metaString += `<meta property="${prefix}numberOfSegments" label="${obj.label}: Segments" type="number" default="${obj.numberOfSegments}" min="1" max="50">\n`;
                metaString += `<meta property="${prefix}angularWidth" label="${obj.label}: Segment Angle" type="number" default="${obj.angularWidth}" min="1" max="90">\n`;
                metaString += `<meta property="${prefix}rotationSpeed" label="${obj.label}: Rotation Speed" type="number" default="${obj.rotationSpeed}" min="-100" max="100">\n`;
                metaString += `<meta property="${prefix}animationSpeed" label="${obj.label}: Animation Speed" type="number" default="${obj.animationSpeed}" min="1" max="50">\n`;
                metaString += `<meta property="${prefix}scrollDir" label="${obj.label}: Scroll Direction" type="combobox" default="${obj.scrollDirection}" values="right,left,up,down">\n`;
                metaString += `<meta property="${prefix}gradType" label="${obj.label}: Fill Type" type="combobox" default="${obj.gradType}" values="solid,linear,radial,alternating">\n`;
                metaString += `<meta property="${prefix}useSharpGradient" label="${obj.label}: Use Sharp Gradient" type="boolean" default="${obj.useSharpGradient}">\n`;
                metaString += `<meta property="${prefix}gradientStop" label="${obj.label}: Gradient Stop %" type="number" default="${obj.gradientStop}" min="0" max="100">\n`;
                metaString += `<meta property="${prefix}gradColor1" label="${obj.label}: Color 1" type="color" default="${obj.gradient.color1}" min="0" max="360">\n`;
                metaString += `<meta property="${prefix}gradColor2" label="${obj.label}: Color 2" type="color" default="${obj.gradient.color2}" min="0" max="360">\n`;
                metaString += `<meta property="${prefix}cycleColors" label="${obj.label}: Cycle Colors" type="boolean" default="${obj.cycleColors}">\n`;
                metaString += `<meta property="${prefix}cycleSpeed" label="${obj.label}: Color Cycle Speed" type="number" default="${obj.cycleSpeed}" min="1" max="10">\n\n`;
            });
            outputElement.textContent = metaString;
        }
           function runPreview() {
            const canvas = document.getElementById('previewCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
            }
            
            function animatePreview() {
                resizeCanvas();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                previewShapes.forEach((shape, index) => {
                    const config = objects[index];
                    
                    const gradType = config.gradType;
                    let speed = config.animationSpeed;
                     if (gradType.includes('radial')) {
                        speed = speed / 100.0;
                    }
                    
                    shape.x = config.x;
                    shape.y = config.y;
                    shape.width = config.width;
                    shape.height = config.height;
                    shape.shape = config.shape;
                    shape.gradientType = gradType;
                    shape.gradient = config.gradient;
                    shape.animationSpeed = speed;
                    shape.scrollDirection = config.scrollDirection;
                    shape.cycleColors = config.cycleColors;
                    shape.cycleSpeed = config.cycleSpeed / 100.0;
                    shape.rotationSpeed = config.rotationSpeed;
                    shape.innerDiameter = config.innerDiameter;
                    shape.angularWidth = config.angularWidth;
                    shape.numberOfSegments = config.numberOfSegments;
                    shape.useSharpGradient = config.useSharpGradient;
                    shape.gradientStop = config.gradientStop;
                    shape.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    
                    shape.draw();
                });

                requestAnimationFrame(animatePreview);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            animatePreview();
        }

        window.onload = () => {
            initialObjectConfigurations.forEach(config => addObject(config));
            runPreview();
        };

    </script>
</body>
</html>