<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Effect Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

    <template id="initial-config">
        <title>Effect Builder</title>
        <meta description="Built with Effect Builder (https://joseamirandavelez.github.io/EffectBuilder/), by Jose Miranda" />
        <meta publisher="Jose Miranda" />
        <meta property="enableAnimation" label="Enable Animation" type="boolean" default="true">
        <meta property="obj1_shape" label="Object 1: Shape" type="combobox" values="rectangle,circle,ring" default="rectangle">
        <meta property="obj1_x" label="Object 1: X Position" type="number" min="0" max="1280" default="0">
        <meta property="obj1_y" label="Object 1: Y Position" type="number" min="0" max="800" default="400">
        <meta property="obj1_width" label="Object 1: Width/Outer Diameter" type="number" min="10" max="1280" default="640">
        <meta property="obj1_height" label="Object 1: Height" type="number" min="10" max="800" default="400">
        <meta property="obj1_innerDiameter" label="Object 1: Inner Diameter" type="number" min="5" max="1270" default="200">
        <meta property="obj1_numberOfSegments" label="Object 1: Segments" type="number" min="1" max="50" default="12">
        <meta property="obj1_angularWidth" label="Object 1: Segment Angle" type="number" min="1" max="90" default="20">
        <meta property="obj1_rotationSpeed" label="Object 1: Rotation Speed" type="number" min="-100" max="100" default="0">
        <meta property="obj1_animationSpeed" label="Object 1: Animation Speed" type="number" min="1" max="50" default="10">
        <meta property="obj1_scrollDir" label="Object 1: Scroll Direction" type="combobox" values="right,left,up,down" default="right">
        <meta property="obj1_gradType" label="Object 1: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="random">
        <meta property="obj1_useSharpGradient" label="Object 1: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj1_gradientStop" label="Object 1: Gradient Stop %" type="number" min="0" max="100" default="50">
        <meta property="obj1_gradColor1" label="Object 1: Color 1" type="color" default="#00ff00">
        <meta property="obj1_gradColor2" label="Object 1: Color 2" type="color" default="#d400ff">
        <meta property="obj1_cycleColors" label="Object 1: Cycle Colors" type="boolean" default="false">
        <meta property="obj1_cycleSpeed" label="Object 1: Color Cycle Speed" type="number" min="1" max="10" default="10">
        <meta property="obj1_numberOfRows" label="Object 1: Number of Rows" type="number" min="1" max="100" default="16">
        <meta property="obj1_numberOfColumns" label="Object 1: Number of Columns" type="number" min="1" max="100" default="16">
        <meta property="obj1_phaseOffset" label="Object 1: Phase Offset" type="number" min="0" max="100" default="10">
        <meta property="obj2_shape" label="Object 2: Shape" type="combobox" values="rectangle,circle,ring" default="ring">
        <meta property="obj2_x" label="Object 2: X Position" type="number" min="0" max="1280" default="966">
        <meta property="obj2_y" label="Object 2: Y Position" type="number" min="0" max="800" default="7">
        <meta property="obj2_width" label="Object 2: Width/Outer Diameter" type="number" min="10" max="1280" default="300">
        <meta property="obj2_height" label="Object 2: Height" type="number" min="10" max="800" default="300">
        <meta property="obj2_innerDiameter" label="Object 2: Inner Diameter" type="number" min="5" max="1270" default="200">
        <meta property="obj2_numberOfSegments" label="Object 2: Segments" type="number" min="1" max="50" default="6">
        <meta property="obj2_angularWidth" label="Object 2: Segment Angle" type="number" min="1" max="90" default="40">
        <meta property="obj2_rotationSpeed" label="Object 2: Rotation Speed" type="number" min="-100" max="100" default="10">
        <meta property="obj2_animationSpeed" label="Object 2: Animation Speed" type="number" min="1" max="50" default="2">
        <meta property="obj2_scrollDir" label="Object 2: Scroll Direction" type="combobox" values="right,left,up,down" default="down">
        <meta property="obj2_gradType" label="Object 2: Fill Type" type="combobox" values="solid,linear,radial,alternating" default="alternating">
        <meta property="obj2_useSharpGradient" label="Object 2: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj2_gradientStop" label="Object 2: Gradient Stop %" type="number" min="0" max="100" default="51">
        <meta property="obj2_gradColor1" label="Object 2: Color 1" type="color" default="#00ff00">
        <meta property="obj2_gradColor2" label="Object 2: Color 2" type="color" default="#d400ff">
        <meta property="obj2_cycleColors" label="Object 2: Cycle Colors" type="boolean" default="false">
        <meta property="obj2_cycleSpeed" label="Object 2: Color Cycle Speed" type="number" min="1" max="10" default="10">
        <meta property="obj2_numberOfRows" label="Object 2: Number of Rows" type="number" min="1" max="100" default="1">
        <meta property="obj2_numberOfColumns" label="Object 2: Number of Columns" type="number" min="1" max="100" default="1">
        <meta property="obj2_phaseOffset" label="Object 2: Phase Offset" type="number" min="0" max="100" default="10">
        <meta property="obj3_shape" label="Object 3: Shape" type="combobox" values="rectangle,circle,ring" default="circle">
        <meta property="obj3_x" label="Object 3: X Position" type="number" min="0" max="1280" default="1060">
        <meta property="obj3_y" label="Object 3: Y Position" type="number" min="0" max="800" default="101">
        <meta property="obj3_width" label="Object 3: Width/Outer Diameter" type="number" min="10" max="1280" default="112">
        <meta property="obj3_height" label="Object 3: Height" type="number" min="10" max="800" default="112">
        <meta property="obj3_innerDiameter" label="Object 3: Inner Diameter" type="number" min="5" max="1270" default="100">
        <meta property="obj3_numberOfSegments" label="Object 3: Segments" type="number" min="1" max="50" default="12">
        <meta property="obj3_angularWidth" label="Object 3: Segment Angle" type="number" min="1" max="90" default="15">
        <meta property="obj3_rotationSpeed" label="Object 3: Rotation Speed" type="number" min="-100" max="100" default="0">
        <meta property="obj3_animationSpeed" label="Object 3: Animation Speed" type="number" min="1" max="50" default="5">
        <meta property="obj3_scrollDir" label="Object 3: Scroll Direction" type="combobox" values="right,left,up,down" default="left">
        <meta property="obj3_gradType" label="Object 3: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="radial">
        <meta property="obj3_useSharpGradient" label="Object 3: Use Sharp Gradient" type="boolean" default="true">
        <meta property="obj3_gradientStop" label="Object 3: Gradient Stop %" type="number" min="0" max="100" default="100">
        <meta property="obj3_gradColor1" label="Object 3: Color 1" type="color" default="#00ff00">
        <meta property="obj3_gradColor2" label="Object 3: Color 2" type="color" default="#d400ff">
        <meta property="obj3_cycleColors" label="Object 3: Cycle Colors" type="boolean" default="false">
        <meta property="obj3_cycleSpeed" label="Object 3: Color Cycle Speed" type="number" min="1" max="10" default="10">
        <meta property="obj3_numberOfRows" label="Object 3: Number of Rows" type="number" min="1" max="100" default="1">
        <meta property="obj3_numberOfColumns" label="Object 3: Number of Columns" type="number" min="1" max="100" default="1">
        <meta property="obj3_phaseOffset" label="Object 3: Phase Offset" type="number" min="0" max="100" default="10">
        <meta property="obj4_shape" label="Object 4: Shape" type="combobox" values="rectangle,circle,ring" default="ring">
        <meta property="obj4_x" label="Object 4: X Position" type="number" min="0" max="1280" default="958">
        <meta property="obj4_y" label="Object 4: Y Position" type="number" min="0" max="800" default="350">
        <meta property="obj4_width" label="Object 4: Width/Outer Diameter" type="number" min="10" max="1280" default="300">
        <meta property="obj4_height" label="Object 4: Height" type="number" min="10" max="800" default="300">
        <meta property="obj4_innerDiameter" label="Object 4: Inner Diameter" type="number" min="5" max="1270" default="200">
        <meta property="obj4_numberOfSegments" label="Object 4: Segments" type="number" min="1" max="50" default="6">
        <meta property="obj4_angularWidth" label="Object 4: Segment Angle" type="number" min="1" max="90" default="40">
        <meta property="obj4_rotationSpeed" label="Object 4: Rotation Speed" type="number" min="-100" max="100" default="-10">
        <meta property="obj4_animationSpeed" label="Object 4: Animation Speed" type="number" min="1" max="50" default="2">
        <meta property="obj4_scrollDir" label="Object 4: Scroll Direction" type="combobox" values="right,left,up,down" default="down">
        <meta property="obj4_gradType" label="Object 4: Fill Type" type="combobox" values="solid,linear,radial,alternating" default="alternating">
        <meta property="obj4_useSharpGradient" label="Object 4: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj4_gradientStop" label="Object 4: Gradient Stop %" type="number" min="0" max="100" default="51">
        <meta property="obj4_gradColor1" label="Object 4: Color 1" type="color" default="#00ff00">
        <meta property="obj4_gradColor2" label="Object 4: Color 2" type="color" default="#d400ff">
        <meta property="obj4_cycleColors" label="Object 4: Cycle Colors" type="boolean" default="false">
        <meta property="obj4_cycleSpeed" label="Object 4: Color Cycle Speed" type="number" min="1" max="10" default="10">
        <meta property="obj4_numberOfRows" label="Object 4: Number of Rows" type="number" min="1" max="100" default="1">
        <meta property="obj4_numberOfColumns" label="Object 4: Number of Columns" type="number" min="1" max="100" default="1">
        <meta property="obj4_phaseOffset" label="Object 4: Phase Offset" type="number" min="0" max="100" default="10">
        <meta property="obj5_shape" label="Object 5: Shape" type="combobox" values="rectangle,circle,ring" default="circle">
        <meta property="obj5_x" label="Object 5: X Position" type="number" min="0" max="1280" default="1052">
        <meta property="obj5_y" label="Object 5: Y Position" type="number" min="0" max="800" default="444">
        <meta property="obj5_width" label="Object 5: Width/Outer Diameter" type="number" min="10" max="1280" default="112">
        <meta property="obj5_height" label="Object 5: Height" type="number" min="10" max="800" default="112">
        <meta property="obj5_innerDiameter" label="Object 5: Inner Diameter" type="number" min="5" max="1270" default="100">
        <meta property="obj5_numberOfSegments" label="Object 5: Segments" type="number" min="1" max="50" default="12">
        <meta property="obj5_angularWidth" label="Object 5: Segment Angle" type="number" min="1" max="90" default="15">
        <meta property="obj5_rotationSpeed" label="Object 5: Rotation Speed" type="number" min="-100" max="100" default="0">
        <meta property="obj5_animationSpeed" label="Object 5: Animation Speed" type="number" min="1" max="50" default="5">
        <meta property="obj5_scrollDir" label="Object 5: Scroll Direction" type="combobox" values="right,left,up,down" default="left">
        <meta property="obj5_gradType" label="Object 5: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="radial">
        <meta property="obj5_useSharpGradient" label="Object 5: Use Sharp Gradient" type="boolean" default="true">
        <meta property="obj5_gradientStop" label="Object 5: Gradient Stop %" type="number" min="0" max="100" default="100">
        <meta property="obj5_gradColor1" label="Object 5: Color 1" type="color" default="#00ff00">
        <meta property="obj5_gradColor2" label="Object 5: Color 2" type="color" default="#d400ff">
        <meta property="obj5_cycleColors" label="Object 5: Cycle Colors" type="boolean" default="false">
        <meta property="obj5_cycleSpeed" label="Object 5: Color Cycle Speed" type="number" min="1" max="10" default="10">
        <meta property="obj5_numberOfRows" label="Object 5: Number of Rows" type="number" min="1" max="100" default="1">
        <meta property="obj5_numberOfColumns" label="Object 5: Number of Columns" type="number" min="1" max="100" default="1">
        <meta property="obj5_phaseOffset" label="Object 5: Phase Offset" type="number" min="0" max="100" default="10">
        <meta property="obj6_shape" label="Object 6: Shape" type="combobox" values="rectangle,circle,ring" default="rectangle">
        <meta property="obj6_x" label="Object 6: X Position" type="number" min="0" max="1280" default="0">
        <meta property="obj6_y" label="Object 6: Y Position" type="number" min="0" max="800" default="0">
        <meta property="obj6_width" label="Object 6: Width/Outer Diameter" type="number" min="10" max="1280" default="640">
        <meta property="obj6_height" label="Object 6: Height" type="number" min="10" max="800" default="400">
        <meta property="obj6_innerDiameter" label="Object 6: Inner Diameter" type="number" min="5" max="1270" default="200">
        <meta property="obj6_numberOfSegments" label="Object 6: Segments" type="number" min="1" max="50" default="8">
        <meta property="obj6_angularWidth" label="Object 6: Segment Angle" type="number" min="1" max="90" default="20">
        <meta property="obj6_rotationSpeed" label="Object 6: Rotation Speed" type="number" min="-100" max="100" default="0">
        <meta property="obj6_animationSpeed" label="Object 6: Animation Speed" type="number" min="1" max="50" default="23">
        <meta property="obj6_scrollDir" label="Object 6: Scroll Direction" type="combobox" values="right,left,up,down" default="right">
        <meta property="obj6_gradType" label="Object 6: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="linear">
        <meta property="obj6_useSharpGradient" label="Object 6: Use Sharp Gradient" type="boolean" default="true">
        <meta property="obj6_gradientStop" label="Object 6: Gradient Stop %" type="number" min="0" max="100" default="50">
        <meta property="obj6_gradColor1" label="Object 6: Color 1" type="color" default="#00ff00">
        <meta property="obj6_gradColor2" label="Object 6: Color 2" type="color" default="#d400ff">
        <meta property="obj6_cycleColors" label="Object 6: Cycle Colors" type="boolean" default="false">
        <meta property="obj6_cycleSpeed" label="Object 6: Color Cycle Speed" type="number" min="1" max="10" default="10">
        <meta property="obj6_numberOfRows" label="Object 6: Number of Rows" type="number" min="1" max="100" default="8">
        <meta property="obj6_numberOfColumns" label="Object 6: Number of Columns" type="number" min="1" max="100" default="1">
        <meta property="obj6_phaseOffset" label="Object 6: Phase Offset" type="number" min="0" max="100" default="10">
    </template>

    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background-color: #1a1a1a;
            color: #f8f9fa;
        }

        .form-control,
        .form-select,
        .form-control:disabled {
            background-color: #2d3748;
            color: #e2e8f0;
            border-color: #4a5568;
            transition: all 0.2s ease;
        }

        .form-control:focus,
        .form-select:focus {
            background-color: #4a5568;
            color: #e2e8f0;
            border-color: #3182ce;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.3);
        }

        .form-control-color {
            width: 80px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #4a5568;
            cursor: pointer;
        }

        .form-control-color::-webkit-color-swatch {
            border-radius: 6px;
            border: none;
        }

        .input-group .form-control[type="number"] {
            width: 100px;
            border-radius: 8px 0 0 8px;
            background-color: #2d3748;
            border-right: none;
        }

        .input-group .form-range {
            background-color: transparent;
            border: none;
            padding: 0 10px;
            accent-color: #3182ce;
        }

        .input-group .form-range::-webkit-slider-thumb {
            background-color: #3182ce;
            border: 2px solid #e2e8f0;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
        }

        .form-select {
            border-radius: 8px;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23e2e8f0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
        }

        .form-check-input {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background-color: #2d3748;
            border: 2px solid #4a5568;
            cursor: pointer;
        }

        .form-check-input:checked {
            background-color: #3182ce;
            border-color: #3182ce;
        }

        #canvas-container {
            position: relative;
            background-color: #222;
            aspect-ratio: 1280 / 800;
            cursor: default;

            /* New sizing logic for robust aspect ratio scaling */
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
        }

        #signalCanvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .output-panel {
            /* The min-height property is now controlled by the splitter */
        }

        #output-script {
            font-family: monospace;
            white-space: pre;
            background-color: #222;
            color: #f8f9fa;
        }

        .toast-container,
        .modal {
            z-index: 1090;
        }

        .legend-button {
            background: none;
            border: none;
            color: #e2e8f0;
            padding: 0;
            font-size: 1.2rem;
            font-weight: 600;
            width: 100%;
            text-align: left;
            transition: color 0.2s ease;
        }

        .legend-button:hover {
            color: #3182ce;
        }

        .legend-button:not(.collapsed)::after {
            transform: rotate(-180deg);
        }

        .legend-button::after {
            content: '\f282';
            font-family: 'bootstrap-icons';
            display: inline-block;
            transition: transform 0.2s ease-in-out;
            float: right;
        }

        .toolbar {
            background-color: #212529;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toolbar .btn {
            color: #e2e8f0;
            border-radius: 6px;
            transition: background-color 0.2s ease;
        }

        .toolbar .btn:hover {
            background-color: #4a5568;
        }

        .object-name {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            background-color: #2d3748;
            transition: background-color 0.2s ease;
        }

        .object-name:focus {
            background-color: #4a5568;
            outline: none;
            box-shadow: 0 0 0 2px #3182ce;
        }

        #load-project-list .list-group-item {
            cursor: pointer;
            background-color: #2d3748;
            border-color: #4a5568;
            transition: background-color 0.2s ease;
        }

        #load-project-list .list-group-item:hover {
            background-color: #4a5568;
        }

        .gutter {
            background-color: #4a5568;
            background-repeat: no-repeat;
            background-position: 50%;
        }

        .gutter.gutter-horizontal {
            cursor: ew-resize;
        }

        .gutter.gutter-vertical {
            cursor: ns-resize;
        }

        #main-split {
            display: flex;
            flex-direction: row;
        }

        .generated-script-header {
            margin-bottom: 5px;
        }
    </style>
</head>

<body class="d-flex flex-column vh-100">

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Interactive Effect Builder</a>
            <div class="d-flex">
                <div class="d-flex">
                    <button class="btn btn-outline-primary me-2" id="save-ws-btn" data-bs-toggle="tooltip" title="Save Workspace to Browser Storage"><i class="bi bi-save"></i> Save</button>
                    <button class="btn btn-outline-secondary me-2" id="load-ws-btn" data-bs-toggle="tooltip" title="Load Workspace from Browser Storage"><i class="bi bi-folder2-open"></i> Load</button>
                    <button class="btn btn-outline-success" id="export-btn" data-bs-toggle="tooltip" title="Export complete HTML file"><i class="bi bi-download"></i> Export</button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid flex-grow-1 overflow-hidden">
        <div class="h-100" id="main-split">
            <div id="left-panel" class="h-100 py-3 border-end border-secondary" style="overflow: auto;">
                <div class="h-100 d-flex flex-column">
                    <div class="flex-grow-1 overflow-auto pe-2">
                        <h4 class="text-gray-100">Controls</h4>
                        <form id="controls-form"></form>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-success w-100" id="add-object-btn" data-bs-toggle="tooltip" title="Add a new default object to the scene"><i class="bi bi-plus-circle"></i> Add New
                            Object</button>
                    </div>
                </div>
            </div>

            <div id="right-panel" class="d-flex flex-column h-100">
                <div id="right-panel-top" class="d-flex flex-column" style="overflow: auto; min-height: 0;">
                    <div class="p-3">
                        <div id="toolbar" class="toolbar d-flex flex-wrap">
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-primary" id="constrain-btn" data-bs-toggle="tooltip" title="Toggle Constrain to Canvas"><i class="bi bi-magnet-fill"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-left" data-bs-toggle="tooltip" title="Align Left to Screen"><i class="bi bi-align-start"></i></button>
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-h-center" data-bs-toggle="tooltip" title="Align Horizontal Center to Screen"><i class="bi bi-align-center"></i></button>
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-right" data-bs-toggle="tooltip" title="Align Right to Screen"><i class="bi bi-align-end"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-top" data-bs-toggle="tooltip" title="Align Top to Screen"><i class="bi bi-align-top"></i></button>
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-v-center" data-bs-toggle="tooltip" title="Align Vertical Center to Screen"><i class="bi bi-align-middle"></i></button>
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-bottom" data-bs-toggle="tooltip" title="Align Bottom to Screen"><i class="bi bi-align-bottom"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-outline-warning" data-action="match-width" data-bs-toggle="tooltip" title="Match Width of First Selected"><i class="bi bi-arrows-expand-vertical"></i> W</button>
                                <button type="button" class="btn btn-outline-warning" data-action="match-height" data-bs-toggle="tooltip" title="Match Height of First Selected"><i class="bi bi-arrows-expand"></i> H</button>
                                <button type="button" class="btn btn-outline-warning" data-action="match-both" data-bs-toggle="tooltip" title="Match Size of First Selected"><i class="bi bi-fullscreen"></i></button>
                                <button type="button" class="btn btn-outline-info" data-action="fit-canvas" data-bs-toggle="tooltip" title="Fit to Canvas"><i class="bi bi-arrows-fullscreen"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm ms-auto mb-1" role="group">
                                <button type="button" class="btn btn-outline-secondary" id="collapse-code-btn" data-bs-toggle="tooltip" title="Toggle Code Panel">
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="flex-grow-1 p-3" style="min-height: 0; position: relative;">
                        <div id="canvas-container">
                            <canvas id="signalCanvas"></canvas>
                        </div>
                    </div>
                </div>
                <div id="right-panel-bottom" class="output-panel d-flex flex-column p-3 border-top border-secondary">
                    <h5 class="text-gray-100 generated-script-header">Generated Script Header</h5>
                    <textarea id="output-script" class="form-control flex-grow-1" readonly></textarea>
                    <button class="btn btn-primary mt-2" id="copy-btn" data-bs-toggle="tooltip" title="Copy the generated meta tags to your clipboard"> <i class="bi bi-clipboard"></i> Copy to
                        Clipboard </button>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="copy-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-autohide="true" data-bs-delay="5000">
            <div class="toast-header bg-success text-white">
                <strong class="me-auto">Success</strong>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body">
                Script header copied to clipboard!
            </div>
        </div>
    </div>

    <div class="modal fade" id="load-project-modal" tabindex="-1" aria-labelledby="loadProjectModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-white">
                <div class="modal-header">
                    <h5 class="modal-title" id="loadProjectModalLabel">Load Project</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Select a project to load. This will overwrite your current workspace.</p>
                    <ul class="list-group" id="load-project-list"></ul>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/split.js/dist/split.min.js"></script>

    <script>
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function lerpColor(a, b, amount) {
            const amt = Math.max(0, Math.min(1, amount));
            const ah = parseInt(a.slice(1), 16),
                ar = ah >> 16,
                ag = (ah >> 8) & 0xff,
                ab = ah & 0xff,
                bh = parseInt(b.slice(1), 16),
                br = bh >> 16,
                bg = (bh >> 8) & 0xff,
                bb = bh & 0xff,
                rr = Math.round(ar + amt * (br - ar)),
                rg = Math.round(ag + amt * (bg - ag)),
                rb = Math.round(ab + amt * (bb - ab));
            return '#' + (rr << 16 | rg << 8 | rb).toString(16).padStart(6, '0');
        }

        function getPatternColor(t, c1, c2) {
            t = (t % 1.0 + 1.0) % 1.0;
            const isHsl = c1.startsWith('hsl');
            if (isHsl) {
                const hue1 = parseFloat(c1.match(/hsl\((\d+\.?\d*)/)[1]);
                const hue2 = parseFloat(c2.match(/hsl\((\d+\.?\d*)/)[1]);
                let finalHue;
                if (t < 0.5) {
                    finalHue = hue1 + (t / 0.5) * (hue2 - hue1);
                } else {
                    finalHue = hue2 + ((t - 0.5) / 0.5) * (hue1 - hue2);
                }
                return `hsl(${finalHue % 360}, 100%, 50%)`;
            } else {
                if (t < 0.5) return lerpColor(c1, c2, t / 0.5);
                else return lerpColor(c2, c1, (t - 0.5) / 0.5);
            }
        }

        class Shape {
            constructor({
                id, name, shape, x, y, width, height, gradient, gradType,
                gradientDirection, scrollDirection, cycleColors, cycleSpeed, animationSpeed, ctx,
                innerDiameter, angularWidth, numberOfSegments, rotationSpeed, useSharpGradient, gradientStop, locked,
                numberOfRows, numberOfColumns, phaseOffset
            }) {
                this.id = id;
                this.name = name || `Object ${id}`;
                this.shape = shape;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.gradient = gradient || { color1: '#000000', color2: '#000000' };
                this.gradType = gradType || 'solid';
                this.gradientDirection = gradientDirection || 'horizontal';
                this.scrollDirection = scrollDirection || 'right';
                this.cycleColors = cycleColors || false;
                this.cycleSpeed = cycleSpeed || 0;
                this.animationSpeed = animationSpeed || 0;
                this.ctx = ctx;
                this.hue1 = 0;
                this.hue2 = 90;
                this.scrollOffset = 0;
                this.innerDiameter = innerDiameter;
                this.angularWidth = angularWidth;
                this.numberOfSegments = numberOfSegments;
                this.rotationSpeed = rotationSpeed || 0;
                this.rotationAngle = 0;
                this.useSharpGradient = useSharpGradient !== undefined ? useSharpGradient : false;
                this.gradientStop = gradientStop !== undefined ? parseFloat(gradientStop) : 50;
                this.locked = locked || false;
                this.numberOfRows = numberOfRows || 1;
                this.numberOfColumns = numberOfColumns || 1;
                this.phaseOffset = phaseOffset || 10;
                this.handleSize = 8;
                this.handles = [
                    { name: 'top-left', cursor: 'nwse-resize' }, { name: 'top', cursor: 'ns-resize' }, { name: 'top-right', cursor: 'nesw-resize' },
                    { name: 'left', cursor: 'ew-resize' }, { name: 'right', cursor: 'ew-resize' },
                    { name: 'bottom-left', cursor: 'nesw-resize' }, { name: 'bottom', cursor: 'ns-resize' }, { name: 'bottom-right', cursor: 'nwse-resize' }
                ];
                this.randomColorTimer = 0;
                this.cellColors = [];
            }

            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }

            getHandlePositions() {
                const h2 = this.handleSize / 2;
                return {
                    'top-left': { x: this.x - h2, y: this.y - h2 },
                    'top': { x: this.x + this.width / 2 - h2, y: this.y - h2 },
                    'top-right': { x: this.x + this.width - h2, y: this.y - h2 },
                    'left': { x: this.x - h2, y: this.y + this.height / 2 - h2 },
                    'right': { x: this.x + this.width - h2, y: this.y + this.height / 2 - h2 },
                    'bottom-left': { x: this.x - h2, y: this.y + this.height - h2 },
                    'bottom': { x: this.x + this.width / 2 - h2, y: this.y + this.height - h2 },
                    'bottom-right': { x: this.x + this.width - h2, y: this.y + this.height - h2 }
                };
            }

            getHandleAtPoint(px, py) {
                const handlePositions = this.getHandlePositions();
                if (this.shape === 'ring') {
                    for (const handle of this.handles) {
                        const pos = handlePositions[handle.name];
                        if (px >= pos.x && px <= pos.x + this.handleSize && py >= pos.y && py <= pos.y + this.handleSize) {
                            return handle;
                        }
                    }
                    return null;
                }
                const localPoint = this.getLocalPoint(px, py);
                for (const handle of this.handles) {
                    const pos = handlePositions[handle.name];
                    if (localPoint.x >= pos.x && localPoint.x <= pos.x + this.handleSize && localPoint.y >= pos.y && localPoint.y <= pos.y + this.handleSize) {
                        return handle;
                    }
                }
                return null;
            }

            getLocalPoint(px, py) {
                const center = this.getCenter();
                const angle = -this.rotationAngle;
                const s = Math.sin(angle);
                const c = Math.cos(angle);
                let tempX = px - center.x;
                let tempY = py - center.y;
                const rotatedX = tempX * c - tempY * s;
                const rotatedY = tempX * s + tempY * c;
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            }

            getWorldCoordsOfCorner(handleName) {
                const handlePositions = this.getHandlePositions();
                const h2 = this.handleSize / 2;
                const localCorner = { x: handlePositions[handleName].x + h2, y: handlePositions[handleName].y + h2 };

                if (this.shape === 'ring') {
                    return localCorner;
                }

                const center = this.getCenter();
                const angle = this.rotationAngle;
                const s = Math.sin(angle);
                const c = Math.cos(angle);
                let tempX = localCorner.x - center.x;
                let tempY = localCorner.y - center.y;
                const rotatedX = tempX * c - tempY * s;
                const rotatedY = tempX * s + tempY * c;
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            }

            updateAnimationState() {
                if (this.cycleColors) {
                    this.hue1 += this.cycleSpeed;
                    this.hue2 += this.cycleSpeed;
                }
                if (this.gradType !== 'solid' && this.gradType !== 'alternating' && this.gradType !== 'random') {
                    const directionMultiplier = this.gradType.includes('radial') ? 1 : ((this.scrollDirection === 'left' || this.scrollDirection === 'up') ? 1 : -1);
                    this.scrollOffset += this.animationSpeed * directionMultiplier * 0.01;
                    this.scrollOffset = (this.scrollOffset % 1.0 + 1.0) % 1.0;
                }
                this.rotationAngle += (this.rotationSpeed / 1000);
            }

            createFillStyle(phase = 0) {
                const phaseIncrement = this.phaseOffset / 100.0;
                const effectiveScrollOffset = (this.scrollOffset + phase * phaseIncrement) % 1.0;
                const c1 = this.cycleColors ? `hsl(${(this.hue1 + phase * this.phaseOffset) % 360}, 100%, 50%)` : this.gradient.color1;
                const c2 = this.cycleColors ? `hsl(${(this.hue2 + phase * this.phaseOffset) % 360}, 100%, 50%)` : this.gradient.color2;
                const isLinear = this.gradType && this.gradType.includes('linear');
                const isRadial = this.gradType && this.gradType.includes('radial');

                if (this.gradType === 'alternating') {
                    return c2;
                }

                if (isLinear) {
                    let grad;
                    if (this.gradientDirection === 'horizontal') {
                        grad = this.ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
                    } else { // vertical
                        grad = this.ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                    }

                    const p = effectiveScrollOffset;

                    if (this.useSharpGradient) {
                        const stopRatio = this.gradientStop / 100.0;
                        const p1 = p;
                        const p2 = (p + stopRatio) % 1.0;

                        if (p2 > p1) { // Normal case, no wrapping
                            grad.addColorStop(0, c2);
                            grad.addColorStop(p1, c2);
                            grad.addColorStop(p1, c1);
                            grad.addColorStop(p2, c1);
                            grad.addColorStop(p2, c2);
                            grad.addColorStop(1, c2);
                        } else { // Wrapped case
                            grad.addColorStop(0, c1);
                            grad.addColorStop(p2, c1);
                            grad.addColorStop(p2, c2);
                            grad.addColorStop(p1, c2);
                            grad.addColorStop(p1, c1);
                            grad.addColorStop(1, c1);
                        }
                    } else {
                        // Smooth gradient logic
                        const stops = [];
                        stops.push({ pos: 0, color: getPatternColor(0 - p, c1, c2) });
                        for (let i = -2; i <= 2; i++) {
                            const c1_pos = i + p;
                            const c2_pos = i + 0.5 + p;
                            if (c1_pos > 0 && c1_pos < 1) stops.push({ pos: c1_pos, color: c1 });
                            if (c2_pos > 0 && c2_pos < 1) stops.push({ pos: c2_pos, color: c2 });
                        }
                        stops.push({ pos: 1, color: getPatternColor(1 - p, c1, c2) });

                        const uniqueStops = stops.sort((a, b) => a.pos - b.pos).filter((stop, index, self) => index === 0 || stop.pos > self[index - 1].pos);
                        uniqueStops.forEach(stop => grad.addColorStop(stop.pos, stop.color));
                    }
                    return grad;

                } else if (isRadial) {
                    const centerX = this.x + this.width / 2;
                    const centerY = this.y + this.height / 2;
                    const maxRadius = Math.max(this.width, this.height) / 2;
                    const grad = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
                    const wave = 1 - Math.abs(2 * effectiveScrollOffset - 1);

                    if (this.useSharpGradient) {
                        const stopPoint = (this.gradientStop / 100) * wave;
                        grad.addColorStop(0, c1);
                        grad.addColorStop(stopPoint, c1);
                        grad.addColorStop(Math.min(1, stopPoint + 0.001), c2);
                        grad.addColorStop(1, c2);
                    } else {
                        const gradientStopPosition = this.gradientStop / 100.0;
                        const midPoint = gradientStopPosition * wave;
                        grad.addColorStop(0, c1);
                        grad.addColorStop(midPoint, c2);
                        grad.addColorStop(1, c1);
                    }
                    return grad;
                }
                return c1 || 'black';
            }

            draw(enableAnimation, isSelected) {
                this.ctx.save(); // Initial save
                if (enableAnimation) {
                    this.updateAnimationState();
                }

                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                this.ctx.save(); // Save for rotation
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(this.rotationAngle);
                this.ctx.translate(-centerX, -centerY);

                // Handle ring and grid rectangles as special cases
                if (this.shape === 'ring') {
                    const outerRadius = this.width / 2;
                    const innerRadius = this.innerDiameter / 2;
                    const angleStep = (2 * Math.PI) / this.numberOfSegments;
                    const segmentAngleRad = (this.angularWidth * Math.PI) / 180;

                    if (innerRadius >= 0 && innerRadius < outerRadius && this.numberOfSegments > 0) {
                        const isAlternating = this.gradType === 'alternating';
                        const c1 = this.cycleColors ? `hsl(${this.hue1 % 360}, 100%, 50%)` : this.gradient.color1;
                        const c2 = this.cycleColors ? `hsl(${this.hue2 % 360}, 100%, 50%)` : this.gradient.color2;
                        const genericFill = isAlternating ? null : this.createFillStyle();

                        for (let i = 0; i < this.numberOfSegments; i++) {
                            this.ctx.beginPath();
                            const startAngle = i * angleStep;
                            const endAngle = startAngle + segmentAngleRad;

                            this.ctx.moveTo(centerX + Math.cos(startAngle) * outerRadius, centerY + Math.sin(startAngle) * outerRadius);
                            this.ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
                            this.ctx.lineTo(centerX + Math.cos(endAngle) * innerRadius, centerY + Math.sin(endAngle) * innerRadius);
                            this.ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
                            this.ctx.closePath();

                            if (isAlternating) {
                                this.ctx.fillStyle = (i % 2 === 0) ? c1 : c2;
                            } else {
                                this.ctx.fillStyle = genericFill;
                            }
                            this.ctx.fill();
                        }
                    }
                } else if (this.shape === 'rectangle' && (this.numberOfRows > 1 || this.numberOfColumns > 1)) {
                    const cellWidth = this.width / this.numberOfColumns;
                    const cellHeight = this.height / this.numberOfRows;
                    const isRandom = this.gradType === 'random';

                    const c1 = this.cycleColors ? `hsl(${this.hue1 % 360}, 100%, 50%)` : this.gradient.color1;
                    const c2 = this.cycleColors ? `hsl(${this.hue2 % 360}, 100%, 50%)` : this.gradient.color2;

                    if (isRandom) {
                        this.randomColorTimer -= 1; // Decrement the timer by a fixed amount each frame.
                        if (this.randomColorTimer <= 0) {
                            this.cellColors = [];
                            // Reset the timer based on the cycle speed. Higher speed = shorter timer.
                            const rawSpeed = this.animationSpeed * 25; // Revert scaling to get 1-10 value
                            this.randomColorTimer = Math.max(1, 200 / rawSpeed);
                        }
                    }

                    for (let row = 0; row < this.numberOfRows; row++) {
                        for (let col = 0; col < this.numberOfColumns; col++) {
                            const cellX = this.x + col * cellWidth;
                            const cellY = this.y + row * cellHeight;
                            const cellIndex = row * this.numberOfColumns + col;

                            if (isRandom) {
                                if (!this.cellColors[cellIndex]) {
                                    this.cellColors[cellIndex] = Math.random() < 0.5 ? c1 : c2;
                                }
                                this.ctx.fillStyle = this.cellColors[cellIndex];
                                this.ctx.fillRect(cellX, cellY, cellWidth, cellHeight);
                            } else {
                                this.ctx.save();
                                this.ctx.beginPath();
                                this.ctx.rect(cellX, cellY, cellWidth, cellHeight);
                                this.ctx.clip();
                                this.ctx.fillStyle = this.createFillStyle(cellIndex);
                                this.ctx.fillRect(this.x, this.y, this.width, this.height);
                                this.ctx.restore();
                            }
                        }
                    }
                } else {
                    // Default drawing for simple rectangles and circles
                    this.ctx.beginPath();
                    switch (this.shape) {
                        case 'rectangle':
                            this.ctx.rect(this.x, this.y, this.width, this.height);
                            break;
                        case 'circle':
                            this.ctx.arc(centerX, centerY, this.width / 2, 0, 2 * Math.PI);
                            break;
                    }
                    this.ctx.fillStyle = this.createFillStyle();
                    this.ctx.fill();
                }

                this.ctx.restore(); // Restore from rotation

                // --- Selection Handles & Lock Icon ---
                if (isSelected && !this.locked) {
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(this.rotationAngle);
                    this.ctx.translate(-centerX, -centerY);
                    this.ctx.strokeStyle = '#00f6ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(this.x, this.y, this.width, this.height);
                    this.ctx.setLineDash([]);
                    this.ctx.fillStyle = '#00f6ff';
                    const handlePositions = this.getHandlePositions();
                    for (const handle of this.handles) {
                        const pos = handlePositions[handle.name];
                        this.ctx.fillRect(pos.x, pos.y, this.handleSize, this.handleSize);
                    }
                    this.ctx.restore();
                }

                if (this.locked) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.5;
                    this.ctx.fillStyle = 'gray';
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('ðŸ”’', centerX, centerY);
                    this.ctx.restore();
                }

                this.ctx.restore(); // Final restore
            }

            isPointInside(px, py) {
                const localPoint = this.getLocalPoint(px, py);
                return (localPoint.x >= this.x && localPoint.x <= this.x + this.width && localPoint.y >= this.y && localPoint.y <= this.y + this.height);
            }

            update(props) {
                for (const key in props) {
                    if (props[key] !== undefined) {
                        if (key === 'gradient' && typeof props[key] === 'object' && props[key] !== null) {
                            if (props.gradient.color1 !== undefined) this.gradient.color1 = props.gradient.color1;
                            if (props.gradient.color2 !== undefined) this.gradient.color2 = props.gradient.color2;
                        } else if (this.hasOwnProperty(key)) {
                            this[key] = props[key];
                        }
                    }
                }
            }
        }
        document.addEventListener('DOMContentLoaded', function () {
            // --- Canvas and DOM element references ---
            const canvas = document.getElementById('signalCanvas');
            const canvasContainer = document.getElementById('canvas-container');
            const ctx = canvas.getContext('2d');
            canvas.width = 1280;
            canvas.height = 800;

            const form = document.getElementById('controls-form');
            const outputScriptArea = document.getElementById('output-script');
            const copyBtn = document.getElementById('copy-btn');
            const copyToastEl = document.getElementById('copy-toast');
            const copyToast = new bootstrap.Toast(copyToastEl);
            const toolbar = document.getElementById('toolbar');
            const addObjectBtn = document.getElementById('add-object-btn');
            const constrainBtn = document.getElementById('constrain-btn');
            const loadProjectModalEl = document.getElementById('load-project-modal');
            const loadProjectModal = new bootstrap.Modal(loadProjectModalEl);
            const loadProjectList = document.getElementById('load-project-list');
            const collapseCodeBtn = document.getElementById('collapse-code-btn');
            const exportBtn = document.getElementById('export-btn');

            // --- State Variables ---
            let configStore = [];
            let objects = [];
            let selectedObjectIds = [];

            let isDragging = false;
            let isResizing = false;
            let activeResizeHandle = null;
            let dragStartX, dragStartY;
            let initialDragState = [];
            let constrainToCanvas = true;
            const projectPrefix = 'effectBuilderProject_';
            let verticalSplit, horizontalSplit;
            let lastHSizes, lastVSizes;
            let isCodePanelCollapsed = false;

            // --- Helper Functions ---
            function parseMetaToConfig(metaElement) {
                const config = {};
                const tagName = metaElement.tagName.toLowerCase();

                // Handle the new, simpler tag formats
                if (metaElement.hasAttribute('description')) {
                    config.name = 'description';
                    config.label = 'Description';
                    config.type = 'text';
                    config.default = metaElement.getAttribute('description');
                } else if (metaElement.hasAttribute('publisher')) {
                    config.name = 'publisher';
                    config.label = 'Developer Name';
                    config.type = 'text';
                    config.default = metaElement.getAttribute('publisher');
                } else if (tagName === 'title') {
                    config.name = 'title';
                    config.label = 'Title';
                    config.type = 'text';
                    config.default = metaElement.textContent;
                }
                // Handle the standard property tags
                else {
                    for (const attr of metaElement.attributes) {
                        config[attr.name] = attr.value;
                    }
                }
                return config;
            }

            function groupConfigs(flatConfig) {
                const grouped = { general: [], objects: {} };
                flatConfig.forEach(config => {
                    const key = config.property || config.name;
                    if (key.startsWith('obj')) {
                        const match = key.match(/^obj(\d+)_/);
                        const id = match[1];
                        if (!grouped.objects[id]) grouped.objects[id] = [];
                        grouped.objects[id].push(config);
                    } else {
                        grouped.general.push(config);
                    }
                });
                return grouped;
            }

            function createFormControl(config) {
                const { property, name, label, type, default: defaultValue, values, min, max } = config;
                const controlId = property || name;
                const formGroup = document.createElement('div');
                formGroup.className = 'mb-3';
                const labelEl = document.createElement('label');
                labelEl.htmlFor = controlId;
                labelEl.className = 'block text-sm font-medium text-gray-300';
                labelEl.textContent = label.substring(label.indexOf(':') + 1).trim() || label;
                labelEl.dataset.bsToggle = 'tooltip';
                labelEl.title = `Controls the ${label.toLowerCase()}`;
                formGroup.appendChild(labelEl);

                if (type === 'number') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'flex items-center space-x-2';
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control w-24 bg-gray-700 text-gray-200 border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500';
                    input.name = controlId;
                    input.type = 'number';
                    input.value = defaultValue;
                    if (min) input.min = min;
                    if (max) input.max = max;
                    input.step = '1';
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.className = 'form-range flex-1 bg-transparent';
                    slider.id = `${controlId}_slider`;
                    slider.name = `${controlId}_slider`;
                    if (min) slider.min = min;
                    if (max) slider.max = max;
                    slider.value = defaultValue;
                    inputGroup.appendChild(input);
                    inputGroup.appendChild(slider);
                    formGroup.appendChild(inputGroup);
                } else if (type === 'text') {
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control w-full bg-gray-700 text-gray-200 border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500';
                    input.name = controlId;
                    input.type = 'text';
                    input.value = defaultValue;
                    formGroup.appendChild(input);
                } else if (type === 'combobox') {
                    const vals = values.split(',');
                    const select = document.createElement('select');
                    select.id = controlId;
                    select.className = 'form-select w-full bg-gray-700 text-gray-200 border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500';
                    select.name = controlId;
                    vals.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val.charAt(0).toUpperCase() + val.slice(1);
                        if (val === defaultValue) option.selected = true;
                        select.appendChild(option);
                    });
                    formGroup.appendChild(select);
                } else if (type === 'boolean') {
                    const checkGroup = document.createElement('div');
                    checkGroup.className = 'form-check form-switch';
                    const check = document.createElement('input');
                    check.id = controlId;
                    check.type = 'checkbox';
                    check.className = 'form-check-input';
                    check.name = controlId;
                    check.checked = (defaultValue === 'true');
                    const checkLabel = document.createElement('label');
                    checkLabel.className = 'form-check-label';
                    checkLabel.htmlFor = controlId;
                    checkLabel.textContent = label.substring(label.indexOf(':') + 1).trim() || label;
                    checkGroup.appendChild(check);
                    checkGroup.appendChild(checkLabel);
                    formGroup.appendChild(checkGroup);
                } else if (type === 'color') {
                    const colorGroup = document.createElement('div');
                    colorGroup.className = 'd-flex align-items-center';
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control form-control-color';
                    input.name = controlId;
                    input.type = 'color';
                    input.value = defaultValue;
                    const hexInput = document.createElement('input');
                    hexInput.type = 'text';
                    hexInput.className = 'form-control ms-2';
                    hexInput.style.width = '100px';
                    hexInput.value = defaultValue;
                    hexInput.id = `${controlId}_hex`;
                    hexInput.name = `${controlId}_hex`;
                    colorGroup.appendChild(input);
                    colorGroup.appendChild(hexInput);
                    formGroup.appendChild(colorGroup);
                }
                return formGroup;
            }

            function renderForm() {
                const existingTooltips = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                existingTooltips.forEach(el => {
                    const tooltip = bootstrap.Tooltip.getInstance(el);
                    if (tooltip) tooltip.dispose();
                });

                const grouped = groupConfigs(configStore);
                form.innerHTML = '';

                const generalFieldset = document.createElement('fieldset');
                generalFieldset.className = 'border border-gray-600 p-4 mb-4 rounded-lg';
                const generalLegend = document.createElement('legend');
                generalLegend.className = 'float-none w-auto px-2 text-lg font-semibold text-gray-100';
                generalLegend.textContent = 'General Settings';
                generalFieldset.appendChild(generalLegend);
                grouped.general.forEach(conf => generalFieldset.appendChild(createFormControl(conf)));
                form.appendChild(generalFieldset);

                Object.keys(grouped.objects).sort((a, b) => a - b).forEach(id => {
                    const objectForName = objects.find(o => o.id == id);
                    const objectName = objectForName ? objectForName.name : `Object ${id}`;
                    const objectConfigs = grouped.objects[id];
                    const fieldset = document.createElement('fieldset');
                    fieldset.className = 'border border-gray-600 p-3 mb-4 rounded-lg';
                    fieldset.dataset.objectId = id;

                    const legendContainer = document.createElement('legend');
                    legendContainer.className = 'float-none w-auto px-2 d-flex justify-content-between align-items-center w-100';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'object-name text-lg font-semibold text-gray-100 flex-grow-1 me-2';
                    nameSpan.style.minWidth = '0';
                    nameSpan.contentEditable = true;
                    nameSpan.dataset.id = id;
                    nameSpan.textContent = objectName;
                    legendContainer.appendChild(nameSpan);

                    const controlsGroup = document.createElement('div');
                    controlsGroup.className = 'd-flex align-items-center flex-shrink-0';

                    const lockButton = document.createElement('button');
                    const isLocked = objectForName ? objectForName.locked : false;
                    lockButton.className = `btn btn-sm btn-lock ${isLocked ? 'btn-warning' : 'btn-outline-secondary'} d-flex align-items-center justify-content-center p-0 ms-2`;
                    lockButton.style.width = '28px';
                    lockButton.style.height = '28px';
                    lockButton.type = 'button';
                    lockButton.dataset.id = id;
                    lockButton.dataset.bsToggle = 'tooltip';
                    lockButton.title = isLocked ? 'Unlock Object' : 'Lock Object';
                    lockButton.innerHTML = `<i class="bi ${isLocked ? 'bi-lock-fill' : 'bi-unlock-fill'}"></i>`;
                    controlsGroup.appendChild(lockButton);

                    const dropdown = document.createElement('div');
                    dropdown.className = 'dropdown';
                    dropdown.innerHTML = `<button class="btn btn-sm btn-outline-secondary d-flex align-items-center justify-content-center p-0" style="width: 28px; height: 28px;" type="button" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-list fs-5"></i></button><ul class="dropdown-menu dropdown-menu-dark"><li><a class="dropdown-item btn-duplicate" href="#" data-id="${id}"><i class="bi bi-copy me-2"></i>Duplicate</a></li><li><a class="dropdown-item btn-delete text-danger" href="#" data-id="${id}"><i class="bi bi-trash me-2"></i>Delete</a></li></ul>`;
                    controlsGroup.appendChild(dropdown);

                    const collapseId = `collapse-obj-${id}`;
                    const collapseButton = document.createElement('button');
                    collapseButton.className = 'btn btn-sm btn-outline-secondary ms-2 legend-button collapsed d-flex align-items-center justify-content-center p-0';
                    collapseButton.style.width = '28px';
                    collapseButton.style.height = '28px';
                    collapseButton.type = 'button';
                    collapseButton.dataset.bsToggle = 'collapse';
                    collapseButton.dataset.bsTarget = `#${collapseId}`;
                    collapseButton.setAttribute('aria-expanded', 'false');
                    controlsGroup.appendChild(collapseButton);
                    legendContainer.appendChild(controlsGroup);

                    const collapseWrapper = document.createElement('div');
                    collapseWrapper.id = collapseId;
                    collapseWrapper.className = 'collapse p-3';

                    const groups = {
                        'Shape & Position': ['shape', 'x', 'y', 'width', 'height'],
                        'Ring Properties': ['innerDiameter', 'numberOfSegments', 'angularWidth'],
                        'Subdivision Properties': ['numberOfRows', 'numberOfColumns', 'phaseOffset'],
                        'Fill & Color': ['gradType', 'useSharpGradient', 'gradientStop', 'gradColor1', 'gradColor2'],
                        'Animation': ['rotationSpeed', 'animationSpeed', 'scrollDir', 'cycleColors', 'cycleSpeed']
                    };

                    for (const groupName in groups) {
                        const groupContainer = document.createElement('div');
                        groupContainer.className = 'control-group mb-4';
                        const groupHeader = document.createElement('h6');
                        groupHeader.className = 'text-gray-400 text-sm font-bold border-bottom border-gray-600 pb-1 mb-3';
                        groupHeader.textContent = groupName;
                        groupContainer.appendChild(groupHeader);

                        const propsInGroup = groups[groupName];
                        objectConfigs
                            .filter(conf => {
                                const propName = conf.property.substring(conf.property.indexOf('_') + 1);
                                return propsInGroup.includes(propName);
                            })
                            .forEach(conf => groupContainer.appendChild(createFormControl(conf)));

                        if (groupContainer.children.length > 1) {
                            collapseWrapper.appendChild(groupContainer);
                        }
                    }

                    fieldset.appendChild(legendContainer);
                    fieldset.appendChild(collapseWrapper);
                    form.appendChild(fieldset);
                });

                setFormValues(getControlValues());
                new bootstrap.Tooltip(document.body, { selector: "[data-bs-toggle='tooltip']", trigger: 'hover' });
            }

            function rebuildFromState() {
                const grouped = groupConfigs(configStore);
                const newConfigStore = [...grouped.general];
                let newId = 1;
                const newObjects = [];
                Object.keys(grouped.objects).sort((a, b) => a - b).forEach(oldId => {
                    const configsForOldId = grouped.objects[oldId];
                    const oldObject = objects.find(o => o.id == oldId);
                    if (oldObject) { oldObject.id = newId; newObjects.push(oldObject); }
                    configsForOldId.forEach(conf => {
                        const newConf = { ...conf };
                        const propOrName = newConf.property || newConf.name;
                        newConf[propOrName.startsWith('obj') ? 'property' : 'name'] = propOrName.replace(/obj\d+_/, `obj${newId}_`);
                        newConf.label = conf.label.replace(/Object \d+/, `Object ${newId}`);
                        newConfigStore.push(newConf);
                    });
                    newId++;
                });
                configStore = newConfigStore;
                objects = newObjects;
                renderForm();
                updateAll();
                drawFrame(); // Ensure canvas is updated
            }

            function getControlValues() {
                const formData = new FormData(form);
                const data = {};
                configStore.forEach(conf => {
                    const key = conf.property || conf.name;
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            data[key] = el.checked;
                        } else if (el.type === 'number') {
                            data[key] = parseFloat(formData.get(key) || el.value);
                        } else {
                            data[key] = formData.get(key) || el.value;
                        }
                    }
                });
                return data;
            }

            function setFormValues(data) {
                for (const key in data) {
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = data[key];
                        } else {
                            el.value = data[key];
                        }
                    }
                }
                updateAll();
            }

            function buildStatesFromConfig() {
                const values = getControlValues();
                const grouped = groupConfigs(configStore);
                const finalStates = [];
                Object.keys(grouped.objects).forEach(id => {
                    const existingObject = objects.find(o => o.id == id);
                    const config = {
                        id: parseInt(id),
                        gradient: {},
                        name: existingObject ? existingObject.name : `Object ${id}`,
                        locked: existingObject ? existingObject.locked : false
                    };
                    grouped.objects[id].forEach(conf => {
                        let key = conf.property.replace(`obj${id}_`, '');
                        let value = values[conf.property];
                        const type = conf.type;
                        if (type === 'number') value = parseFloat(value);
                        else if (type === 'boolean') value = (value === true || value === 'true');

                        if (key.startsWith('gradColor')) {
                            config.gradient[key.replace('grad', '').toLowerCase()] = value;
                        } else if (key === 'scrollDir') {
                            config.scrollDirection = value;
                        } else {
                            config[key] = value;
                        }
                    });
                    config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    config.cycleSpeed = (config.cycleSpeed || 0) / 50.0;
                    const speed = config.animationSpeed || 0;
                    config.animationSpeed = speed / 10.0;
                    if (config.shape === 'ring') {
                        config.height = config.width;
                    }
                    finalStates.push(config);
                });
                return finalStates;
            }

            function generateOutputScript() {
                const values = getControlValues();
                let scriptHTML = '';
                configStore.forEach(config => {
                    const propOrName = config.property || config.name;
                    const value = values[propOrName];
                    let line = '';

                    // Handle the simple tag formats
                    if (propOrName === 'title') {
                        line = `<title>${value}</title>\n`;
                    } else if (propOrName === 'description') {
                        line = `<meta description="${value}" />\n`;
                    } else if (propOrName === 'publisher') {
                        line = `<meta publisher="${value}" />\n`;
                    }
                    // Handle the standard property/name tags
                    else {
                        // UPDATED LOGIC: Always use 'property' for 'obj...' OR 'enableAnimation'
                        const attrType = (propOrName.startsWith('obj') || propOrName === 'enableAnimation') ? 'property' : 'name';
                        line = `<meta ${attrType}="${propOrName}"`;

                        Object.keys(config).forEach(attrName => {
                            if (attrName !== 'property' && attrName !== 'name' && attrName !== 'default' && attrName !== 'class') {
                                line += ` ${attrName}="${config[attrName]}"`;
                            }
                        });
                        line += ` default="${value}">\n`;
                    }
                    scriptHTML += line;
                });
                outputScriptArea.value = scriptHTML.trim();
            }
            function getCanvasCoordinates(event) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                return { x, y };
            }

            function updateToolbarState() {
                const multiSelectButtons = toolbar.querySelectorAll('[data-action^="match-"]');
                const singleSelectButtons = toolbar.querySelectorAll('[data-action^="align-screen-"], [data-action="fit-canvas"]');
                singleSelectButtons.forEach(btn => btn.disabled = selectedObjectIds.length === 0);
                multiSelectButtons.forEach(btn => btn.disabled = selectedObjectIds.length < 2);
            }

            function updateFormFromShapes() {
                objects.forEach(obj => {
                    const prefix = `obj${obj.id}_`;
                    const fields = ['x', 'y', 'width', 'height'];
                    fields.forEach(field => {
                        const input = form.elements[`${prefix}${field}`];
                        if (input) {
                            input.value = Math.round(obj[field]);
                            const slider = form.elements[`${prefix}${field}_slider`];
                            if (slider) { slider.value = Math.round(obj[field]); }
                        }
                    });
                });
                generateOutputScript();
            }

            function drawFrame() {
                const values = getControlValues();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const enableAnimation = values['enableAnimation'] === true;
                objects.forEach(obj => {
                    const isSelected = selectedObjectIds.includes(obj.id);
                    obj.draw(enableAnimation, isSelected);
                });
            }

            function animate() {
                const values = getControlValues();
                if (values.enableAnimation || isDragging || isResizing) {
                    drawFrame();
                }
                requestAnimationFrame(animate);
            }

            function updateShapesFromForm() {
                const newStates = buildStatesFromConfig();
                const newObjects = [];
                newStates.forEach(state => {
                    const existingObj = objects.find(o => o.id === state.id);
                    if (existingObj) {
                        existingObj.update(state);
                        newObjects.push(existingObj);
                    } else {
                        newObjects.push(new Shape({ ...state, ctx }));
                    }
                });
                objects = newObjects;
            }

            function updateAll() {
                updateShapesFromForm();
                generateOutputScript();
            }

            function syncPanelsWithSelection() {
                const allCollapses = form.querySelectorAll('.collapse');
                allCollapses.forEach(el => {
                    const instance = bootstrap.Collapse.getInstance(el) || new bootstrap.Collapse(el, { toggle: false });
                    const fieldset = el.closest('fieldset');
                    if (!fieldset) return;
                    const id = parseInt(fieldset.dataset.objectId, 10);
                    if (selectedObjectIds.length === 1 && selectedObjectIds[0] === id) {
                        instance.show();
                    } else {
                        instance.hide();
                    }
                });
            }

            function createInitialObjects() {
                const grouped = groupConfigs(configStore);
                const initialStates = [];
                Object.keys(grouped.objects).forEach(id => {
                    const config = { id: parseInt(id), gradient: {} };
                    grouped.objects[id].forEach(conf => {
                        const key = conf.property.replace(`obj${id}_`, '');
                        let value = conf.default;
                        const type = conf.type;
                        if (type === 'number') value = parseFloat(value);
                        else if (type === 'boolean') value = (value === 'true');
                        if (key.startsWith('gradColor')) {
                            config.gradient[key.replace('grad', '').toLowerCase()] = value;
                        } else if (key === 'scrollDir') {
                            config.scrollDirection = value;
                        } else {
                            config[key] = value;
                        }
                    });
                    config.gradType = config.gradType || 'solid';
                    config.gradient = config.gradient.color1 ? config.gradient : { color1: '#000000', color2: '#000000' };
                    config.useSharpGradient = config.useSharpGradient !== undefined ? config.useSharpGradient : false;
                    config.gradientStop = config.gradientStop !== undefined ? parseFloat(config.gradientStop) : 50;
                    config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    config.cycleSpeed = (config.cycleSpeed || 0) / 100.0;
                    const speed = config.animationSpeed || 0;
                    config.animationSpeed = speed / 10.0;
                    if (config.shape === 'ring') {
                        config.height = config.width;
                    }
                    initialStates.push(config);
                });
                objects = initialStates.map(state => new Shape({ ...state, ctx }));
            }

            function loadWorkspace(workspace) {
                configStore = workspace.configs;
                createInitialObjects();
                if (workspace.objects) {
                    workspace.objects.forEach(savedObj => {
                        const obj = objects.find(o => o.id === savedObj.id);
                        if (obj) {
                            obj.name = savedObj.name;
                            obj.locked = savedObj.locked || false;
                        }
                    });
                }
                renderForm();
                for (const config of configStore) {
                    const key = config.property || config.name;
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = config.default === 'true' || config.default === true;
                        } else {
                            el.value = config.default;
                        }
                        if (el.type === 'number') {
                            const slider = document.getElementById(`${el.id}_slider`);
                            if (slider) slider.value = el.value;
                        }
                    }
                }
                updateAll();
                drawFrame();
            }

            function getOppositeHandle(handleName) {
                let opposite = handleName;
                if (handleName.includes('top')) {
                    opposite = opposite.replace('top', 'bottom');
                } else if (handleName.includes('bottom')) {
                    opposite = opposite.replace('bottom', 'top');
                }
                if (handleName.includes('left')) {
                    opposite = opposite.replace('left', 'right');
                } else if (handleName.includes('right')) {
                    opposite = opposite.replace('right', 'left');
                }
                return opposite;
            }

            function getDefaultObjectConfig(newId) {
                return [
                    { property: `obj${newId}_shape`, label: `Object ${newId}: Shape`, type: 'combobox', default: 'rectangle', values: 'rectangle,circle,ring' },
                    { property: `obj${newId}_x`, label: `Object ${newId}: X Position`, type: 'number', default: '10', min: '0', max: '1280' },
                    { property: `obj${newId}_y`, label: `Object ${newId}: Y Position`, type: 'number', default: '10', min: '0', max: '800' },
                    { property: `obj${newId}_width`, label: `Object ${newId}: Width/Outer Diameter`, type: 'number', default: '200', min: '10', max: '1280' },
                    { property: `obj${newId}_height`, label: `Object ${newId}: Height`, type: 'number', default: '150', min: '10', max: '800' },
                    { property: `obj${newId}_innerDiameter`, label: `Object ${newId}: Inner Diameter`, type: 'number', default: '100', min: '5', max: '1270' },
                    { property: `obj${newId}_numberOfSegments`, label: `Object ${newId}: Segments`, type: 'number', default: '12', min: '1', max: '50' },
                    { property: `obj${newId}_angularWidth`, label: `Object ${newId}: Segment Angle`, type: 'number', default: '20', min: '1', max: '90' },
                    { property: `obj${newId}_rotationSpeed`, label: `Object ${newId}: Rotation Speed`, type: 'number', default: '0', min: '-100', max: '100' },
                    { property: `obj${newId}_animationSpeed`, label: `Object ${newId}: Animation Speed`, type: 'number', default: '2', min: '1', max: '50' },
                    { property: `obj${newId}_scrollDir`, label: `Object ${newId}: Scroll Direction`, type: 'combobox', default: 'right', values: 'right,left,up,down' },
                    { property: `obj${newId}_gradType`, label: `Object ${newId}: Fill Type`, type: 'combobox', default: 'linear', values: 'solid,linear,radial,alternating,random' },
                    { property: `obj${newId}_useSharpGradient`, label: `Object ${newId}: Use Sharp Gradient`, type: 'boolean', default: 'false' },
                    { property: `obj${newId}_gradientStop`, label: `Object ${newId}: Gradient Stop %`, type: 'number', default: '50', min: '0', max: '100' },
                    { property: `obj${newId}_gradColor1`, label: `Object ${newId}: Color 1`, type: 'color', default: '#cccccc' },
                    { property: `obj${newId}_gradColor2`, label: `Object ${newId}: Color 2`, type: 'color', default: '#888888' },
                    { property: `obj${newId}_cycleColors`, label: `Object ${newId}: Cycle Colors`, type: 'boolean', default: 'false' },
                    { property: `obj${newId}_cycleSpeed`, label: `Object ${newId}: Color Cycle Speed`, type: 'number', default: '1', min: '1', max: '10' },
                    { property: `obj${newId}_numberOfRows`, label: `Object ${newId}: Number of Rows`, type: 'number', default: '1', min: '1', max: '100' },
                    { property: `obj${newId}_numberOfColumns`, label: `Object ${newId}: Number of Columns`, type: 'number', default: '1', min: '1', max: '100' },
                    { property: `obj${newId}_phaseOffset`, label: `Object ${newId}: Phase Offset`, type: 'number', default: '10', min: '0', max: '100' }
                ];
            }

            async function exportFile() {
                const exportButton = document.getElementById('export-btn');
                exportButton.disabled = true;
                exportButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exporting...';

                const templateUrl = 'https://raw.githubusercontent.com/joseamirandavelez/EffectBuilder/refs/heads/UI-Improvements/index.html';

                try {
                    const response = await fetch(templateUrl);
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.statusText}`);
                    }
                    const templateHtml = await response.text();
                    const newMetaBlock = document.getElementById('output-script').value;
                    const headRegex = /<head>([\s\S]*?)<\/head>/;

                    // The newMetaBlock already contains the correct <title> tag from the UI.
                    // We can directly replace the entire head content.
                    const newHeadContent = `<head>\n\nÂ  Â  ${newMetaBlock}\n\n</head>`;
                    const finalHtml = templateHtml.replace(headRegex, newHeadContent);

                    const blob = new Blob([finalHtml], { type: 'text/html' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);

                    // Use the current title from the UI for the filename.
                    const effectTitle = getControlValues()['title'] || 'MyEffect';
                    link.download = `${effectTitle.replace(/ /g, '_')}.html`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                } catch (error) {
                    console.error('Export failed:', error);
                    alert(`Export failed: ${error.message}`);
                } finally {
                    exportButton.disabled = false;
                    exportButton.innerHTML = '<i class="bi bi-download"></i> Export';
                }
            }

            // --- Event Listeners ---

            form.addEventListener('input', (e) => {
                const target = e.target;
                if (target.type === 'number' && document.getElementById(`${target.id}_slider`)) {
                    document.getElementById(`${target.id}_slider`).value = target.value;
                } else if (target.type === 'range' && target.id.endsWith('_slider')) {
                    const numberInputId = target.id.replace('_slider', '');
                    document.getElementById(numberInputId).value = target.value;
                }

                if (target.type === 'color' && document.getElementById(`${target.id}_hex`)) {
                    document.getElementById(`${target.id}_hex`).value = target.value;
                }
                if (target.type === 'text' && target.id.endsWith('_hex')) {
                    const colorPickerId = target.id.replace('_hex', '');
                    const colorPicker = document.getElementById(colorPickerId);
                    if (colorPicker && /^#[0-9A-F]{6}$/i.test(target.value)) {
                        colorPicker.value = target.value;
                    }
                }

                if (target.name && target.name.includes('_shape')) {
                    const objectId = target.name.match(/obj(\d+)_/)[1];
                    const shapeValue = target.value;
                    const fieldset = form.querySelector(`fieldset[data-object-id="${objectId}"]`);
                    if (fieldset) {
                        const ringControls = fieldset.querySelector('.control-group:nth-of-type(2)');
                        const subdivisionControls = fieldset.querySelector('.control-group:nth-of-type(3)');
                        const heightControl = fieldset.querySelector(`[id*="obj${objectId}_height"]`).closest('.mb-3');
                        if (ringControls) ringControls.style.display = shapeValue === 'ring' ? '' : 'none';
                        if (subdivisionControls) subdivisionControls.style.display = shapeValue === 'rectangle' ? '' : 'none';
                        if (heightControl) heightControl.style.display = shapeValue === 'rectangle' || shapeValue === 'strimer' ? '' : 'none';
                    }
                }

                updateAll();
            });

            form.addEventListener('click', (e) => {
                const fieldset = e.target.closest('fieldset[data-object-id]');
                const isInteractive = e.target.closest('button, a, input, [contenteditable="true"]');

                if (fieldset && !isInteractive) {
                    const idToSelect = parseInt(fieldset.dataset.objectId, 10);
                    if (!(selectedObjectIds.length === 1 && selectedObjectIds[0] === idToSelect)) {
                        selectedObjectIds = [idToSelect];
                        updateToolbarState();
                        syncPanelsWithSelection();
                        drawFrame();
                    }
                }

                if (e.target.classList.contains('object-name')) {
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }
                const deleteBtn = e.target.closest('.btn-delete');
                const duplicateBtn = e.target.closest('.btn-duplicate');
                const lockBtn = e.target.closest('.btn-lock');

                if (lockBtn) {
                    e.preventDefault();
                    const id = parseInt(lockBtn.dataset.id, 10);
                    const obj = objects.find(o => o.id === id);
                    if (obj) {
                        obj.locked = !obj.locked;
                        const icon = lockBtn.querySelector('i');
                        lockBtn.classList.toggle('btn-warning', obj.locked);
                        lockBtn.classList.toggle('btn-outline-secondary', !obj.locked);
                        icon.className = `bi ${obj.locked ? 'bi-lock-fill' : 'bi-unlock-fill'}`;
                        const tooltip = bootstrap.Tooltip.getInstance(lockBtn);
                        if (tooltip) {
                            tooltip.setContent({ '.tooltip-inner': obj.locked ? 'Unlock Object' : 'Lock Object' });
                        }
                        drawFrame();
                    }
                }

                if (deleteBtn) {
                    e.preventDefault();
                    const idToDelete = parseInt(deleteBtn.dataset.id, 10);
                    selectedObjectIds = selectedObjectIds.filter(id => id !== idToDelete);
                    updateToolbarState();
                    configStore = configStore.filter(conf => !(conf.property || conf.name).startsWith(`obj${idToDelete}_`));
                    objects = objects.filter(o => o.id !== idToDelete);
                    rebuildFromState();
                }
                if (duplicateBtn) {
                    e.preventDefault();

                    const values = getControlValues();
                    configStore = configStore.map(conf => {
                        const key = conf.property || conf.name;
                        if (values[key] !== undefined) {
                            if (conf.type === 'boolean') {
                                conf.default = String(values[key]);
                            } else {
                                conf.default = values[key];
                            }
                        }
                        return conf;
                    });

                    const newId = (objects.reduce((maxId, o) => Math.max(maxId, o.id), 0)) + 1;
                    const idToCopy = duplicateBtn.dataset.id;
                    const configsToCopy = configStore.filter(conf => (conf.property || conf.name).startsWith(`obj${idToCopy}_`));
                    const newConfigs = configsToCopy.map(conf => {
                        const newConf = { ...conf };
                        const propOrName = conf.property || conf.name;
                        newConf.property = propOrName.replace(`obj${idToCopy}_`, `obj${newId}_`);
                        newConf.label = newConf.label.replace(/Object \d+/, `Object ${newId}`);
                        return newConf;
                    });

                    configStore.push(...newConfigs);
                    renderForm();
                    updateAll();
                }
            });

            form.addEventListener('blur', (e) => {
                if (e.target.classList.contains('object-name')) {
                    const id = parseInt(e.target.dataset.id, 10);
                    const newName = e.target.textContent || 'Unnamed';
                    const obj = objects.find(o => o.id === id);
                    if (obj) { obj.name = newName; }
                }
            }, true);

            copyBtn.addEventListener('click', () => { navigator.clipboard.writeText(outputScriptArea.value).then(() => { copyToast.show(); }); });
            document.getElementById('save-ws-btn').addEventListener('click', () => {
                const name = prompt("Enter a name for your project:");
                if (!name) return;
                const key = `${projectPrefix}${name}`;
                if (localStorage.getItem(key)) {
                    if (!confirm(`A project named "${name}" already exists. Overwrite?`)) { return; }
                }
                const workspace = {
                    configs: configStore.map(c => ({ ...c, default: getControlValues()[c.property || c.name] })),
                    objects: objects.map(o => ({ id: o.id, name: o.name, locked: o.locked }))
                };
                localStorage.setItem(key, JSON.stringify(workspace));
                alert(`Project "${name}" saved!`);
            });
            document.getElementById('load-ws-btn').addEventListener('click', () => {
                loadProjectList.innerHTML = '';
                let hasProjects = false;
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(projectPrefix)) {
                        hasProjects = true;
                        const projectName = key.replace(projectPrefix, '');
                        const li = document.createElement('li');
                        li.className = 'list-group-item bg-dark text-white d-flex justify-content-between align-items-center';
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = projectName;
                        nameSpan.style.cursor = "pointer";
                        nameSpan.onclick = () => {
                            const savedData = localStorage.getItem(key);
                            if (savedData) {
                                loadWorkspace(JSON.parse(savedData));
                                loadProjectModal.hide();
                            }
                        };
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-sm btn-outline-danger';
                        deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            if (confirm(`Are you sure you want to delete project "${projectName}"?`)) {
                                localStorage.removeItem(key);
                                document.getElementById('load-ws-btn').click();
                            }
                        };
                        li.appendChild(nameSpan);
                        li.appendChild(deleteBtn);
                        loadProjectList.appendChild(li);
                    }
                }
                if (!hasProjects) {
                    loadProjectList.innerHTML = '<li class="list-group-item bg-dark text-white-50">No saved projects found.</li>';
                }
                loadProjectModal.show();
            });
            toolbar.addEventListener('click', e => {
                const button = e.target.closest('button');
                if (!button || button.disabled || button.id === 'constrain-btn') return;
                const action = button.dataset.action;
                if (!action || selectedObjectIds.length === 0) return;
                const selected = selectedObjectIds.map(id => objects.find(o => o.id === id)).filter(o => o);
                if (selected.length === 0) return;
                const anchor = selected[0];
                switch (action) {
                    case 'align-screen-left': selected.forEach(o => o.x = 0); break;
                    case 'align-screen-right': selected.forEach(o => o.x = canvas.width - o.width); break;
                    case 'align-screen-h-center': selected.forEach(o => o.x = (canvas.width - o.width) / 2); break;
                    case 'align-screen-top': selected.forEach(o => o.y = 0); break;
                    case 'align-screen-bottom': selected.forEach(o => o.y = canvas.height - o.height); break;
                    case 'align-screen-v-center': selected.forEach(o => o.y = (canvas.height - o.height) / 2); break;
                    case 'match-width': selected.slice(1).forEach(o => o.width = anchor.width); break;
                    case 'match-height': selected.slice(1).forEach(o => o.height = anchor.height); break;
                    case 'match-both': selected.slice(1).forEach(o => { o.width = anchor.width; o.height = anchor.height; }); break;
                    case 'fit-canvas':
                        selected.forEach(o => {
                            o.x = 0;
                            o.y = 0;
                            o.width = canvas.width;
                            o.height = canvas.height;
                        });
                        break;
                }
                updateFormFromShapes();
            });
            addObjectBtn.addEventListener('click', () => {
                const newId = (objects.reduce((maxId, o) => Math.max(maxId, o.id), 0)) + 1;
                const templateConf = configStore.filter(c => c.property && c.property.startsWith('obj1_'));
                let newConfigs;
                if (templateConf.length === 0) {
                    newConfigs = getDefaultObjectConfig(newId);
                } else {
                    const values = getControlValues();
                    newConfigs = templateConf.map(conf => {
                        const newConf = { ...conf };
                        newConf.property = newConf.property.replace('obj1_', `obj${newId}_`);
                        newConf.label = newConf.label.replace(/Object \d+/, `Object ${newId}`);
                        switch (newConf.property) {
                            case `obj${newId}_x`: newConf.default = '10'; break;
                            case `obj${newId}_y`: newConf.default = '10'; break;
                            case `obj${newId}_width`: newConf.default = '200'; break;
                            case `obj${newId}_height`: newConf.default = '150'; break;
                            case `obj${newId}_shape`: newConf.default = 'rectangle'; break;
                            case `obj${newId}_gradColor1`: newConf.default = '#cccccc'; break;
                            case `obj${newId}_gradColor2`: newConf.default = '#888888'; break;
                            default: newConf.default = values[conf.property];
                        }
                        return newConf;
                    });
                }
                configStore.push(...newConfigs);
                renderForm();
                updateAll();
            });
            constrainBtn.addEventListener('click', () => {
                constrainToCanvas = !constrainToCanvas;
                constrainBtn.classList.toggle('btn-primary', constrainToCanvas);
                constrainBtn.classList.toggle('btn-outline-secondary', !constrainToCanvas);
            });
            canvasContainer.addEventListener('mousedown', e => {
                const { x, y } = getCanvasCoordinates(e);
                if (selectedObjectIds.length === 1) {
                    const selectedObject = objects.find(o => o.id === selectedObjectIds[0]);
                    if (selectedObject && !selectedObject.locked) {
                        const handle = selectedObject.getHandleAtPoint(x, y);
                        if (handle) {
                            isResizing = true;
                            isDragging = false;
                            activeResizeHandle = handle.name;
                            const oppositeHandleName = getOppositeHandle(handle.name);
                            initialDragState = [{ id: selectedObject.id, x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, rotationAngle: selectedObject.rotationAngle, anchorPoint: selectedObject.getWorldCoordsOfCorner(oppositeHandleName), oppositeHandleName: oppositeHandleName }];
                            return;
                        }
                    }
                }
                let hitObject = null;
                for (let i = objects.length - 1; i >= 0; i--) {
                    if (objects[i].isPointInside(x, y) && !objects[i].locked) {
                        hitObject = objects[i];
                        break;
                    }
                }
                if (hitObject) {
                    isDragging = true;
                    const hitObjectId = hitObject.id;
                    if (e.shiftKey || e.ctrlKey || e.metaKey) {
                        if (selectedObjectIds.includes(hitObjectId)) {
                            selectedObjectIds = selectedObjectIds.filter(id => id !== hitObjectId);
                        } else {
                            selectedObjectIds.push(hitObjectId);
                        }
                    } else {
                        if (!selectedObjectIds.includes(hitObjectId)) {
                            selectedObjectIds = [hitObjectId];
                        }
                    }
                } else {
                    selectedObjectIds = [];
                }
                if (isDragging && selectedObjectIds.length > 0) {
                    dragStartX = x;
                    dragStartY = y;
                    initialDragState = selectedObjectIds.map(id => {
                        const obj = objects.find(o => o.id === id);
                        return { id, x: obj.x, y: obj.y };
                    });
                } else {
                    isDragging = false;
                }
                updateToolbarState();
                syncPanelsWithSelection();
            });
            canvasContainer.addEventListener('mousemove', e => {
                e.preventDefault();
                const { x, y } = getCanvasCoordinates(e);
                if (isResizing) {
                    const obj = objects.find(o => o.id === selectedObjectIds[0]);
                    const initial = initialDragState[0];
                    const dx = x - dragStartX;
                    const dy = y - dragStartY;

                    let localDx = dx;
                    let localDy = dy;

                    if (obj.shape !== 'ring') {
                        const angle = initial.rotationAngle;
                        const s = Math.sin(angle);
                        const c = Math.cos(angle);
                        localDx = dx * c + dy * s;
                        localDy = -dx * s + dy * c;
                    }

                    if (activeResizeHandle.includes('right')) {
                        obj.width = Math.max(50, initial.width + localDx);
                    }
                    if (activeResizeHandle.includes('left')) {
                        obj.width = Math.max(50, initial.width - localDx);
                    }
                    if (activeResizeHandle.includes('bottom')) {
                        obj.height = Math.max(50, initial.height + localDy);
                    }
                    if (activeResizeHandle.includes('top')) {
                        obj.height = Math.max(50, initial.height - localDy);
                    }
                    if (obj.shape === 'circle' || obj.shape === 'ring') {
                        obj.height = obj.width;
                    }
                    const newAnchorPoint = obj.getWorldCoordsOfCorner(initial.oppositeHandleName);
                    const offsetX = initial.anchorPoint.x - newAnchorPoint.x;
                    const offsetY = initial.anchorPoint.y - newAnchorPoint.y;
                    obj.x += offsetX;
                    obj.y += offsetY;
                    updateFormFromShapes();
                } else if (isDragging) {
                    initialDragState.forEach(initial => {
                        const obj = objects.find(o => o.id === initial.id);
                        if (obj) {
                            const dx = x - dragStartX;
                            const dy = y - dragStartY;
                            let newX = initial.x + dx;
                            let newY = initial.y + dy;
                            if (constrainToCanvas) {
                                newX = Math.max(0, Math.min(newX, canvas.width - obj.width));
                                newY = Math.max(0, Math.min(newY, canvas.height - obj.height));
                            }
                            obj.x = newX;
                            obj.y = newY;
                        }
                    });
                    updateFormFromShapes();
                } else {
                    canvasContainer.style.cursor = 'default';
                    if (selectedObjectIds.length === 1) {
                        const selectedObject = objects.find(o => o.id === selectedObjectIds[0]);
                        if (selectedObject && !selectedObject.locked) {
                            const handle = selectedObject.getHandleAtPoint(x, y);
                            if (handle) {
                                canvasContainer.style.cursor = handle.cursor;
                            } else if (selectedObject.isPointInside(x, y)) {
                                canvasContainer.style.cursor = 'move';
                            }
                        }
                    }
                }
            });
            canvasContainer.addEventListener('mouseup', () => {
                if (isResizing) { updateAll(); }
                isDragging = false;
                isResizing = false;
                activeResizeHandle = null;
            });
            canvasContainer.addEventListener('mouseleave', () => {
                isDragging = false;
                isResizing = false;
                activeResizeHandle = null;
                canvasContainer.style.cursor = 'default';
            });

            collapseCodeBtn.addEventListener('click', () => {
                isCodePanelCollapsed = !isCodePanelCollapsed;
                const icon = collapseCodeBtn.querySelector('i');
                if (isCodePanelCollapsed) {
                    verticalSplit.collapse(1);
                    icon.className = 'bi bi-chevron-up';
                } else {
                    verticalSplit.setSizes(lastHSizes);
                    icon.className = 'bi bi-chevron-down';
                }
            });

            exportBtn.addEventListener('click', exportFile);

            function init() {
                const template = document.getElementById('initial-config');
                const metaElements = Array.from(template.content.querySelectorAll('meta, title'));
                configStore = metaElements.map(parseMetaToConfig);

                createInitialObjects();
                renderForm();
                updateAll();
                new bootstrap.Tooltip(document.body, { selector: "[data-bs-toggle='tooltip']", trigger: 'hover' });
                updateToolbarState();
                requestAnimationFrame(animate);

                const savedVSizes = getCookie('split-v-sizes');
                const savedHSizes = getCookie('split-h-sizes');
                const initialVSizes = savedVSizes ? JSON.parse(savedVSizes) : [30, 70];
                const initialHSizes = savedHSizes ? JSON.parse(savedHSizes) : [75, 25];

                lastHSizes = initialHSizes;
                lastVSizes = initialVSizes;

                horizontalSplit = Split(['#left-panel', '#right-panel'], {
                    sizes: initialVSizes,
                    minSize: [400, 500],
                    gutterSize: 8,
                    onDragEnd: function (sizes) {
                        setCookie('split-v-sizes', JSON.stringify(sizes), 365);
                        lastVSizes = sizes;
                    }
                });

                verticalSplit = Split(['#right-panel-top', '#right-panel-bottom'], {
                    direction: 'vertical',
                    sizes: initialHSizes,
                    minSize: [200, 0],
                    gutterSize: 8,
                    onDragEnd: function (sizes) {
                        setCookie('split-h-sizes', JSON.stringify(sizes), 365);
                        lastHSizes = sizes;
                    }
                });
            }

            init();
        });
    </script>
</body>

</html>