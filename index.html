<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Effect Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <template id="initial-config">
        <meta title="Effect Class" />
        <meta description="Built with Effect Builder (https://joseamirandavelez.github.io/EffectBuilder/), by Jose Miranda" />
        <meta publisher="Jose Miranda" />
        <meta property="enableAnimation" label="Enable Animation" type="boolean" default="true" />
        <meta property="obj1_shape" label="Strimer: Shape" type="combobox" values="rectangle,circle,ring" default="rectangle" />
        <meta property="obj1_x" label="Strimer: X Position" type="number" min="0" max="1280" default="0" />
        <meta property="obj1_y" label="Strimer: Y Position" type="number" min="0" max="800" default="0" />
        <meta property="obj1_width" label="Strimer: Width/Outer Diameter" type="number" min="10" max="1280" default="640" />
        <meta property="obj1_height" label="Strimer: Height" type="number" min="10" max="800" default="400" />
        <meta property="obj1_innerDiameter" label="Strimer: Inner Diameter" type="number" min="5" max="1270" default="200" />
        <meta property="obj1_numberOfSegments" label="Strimer: Segments" type="number" min="1" max="50" default="8" />
        <meta property="obj1_angularWidth" label="Strimer: Segment Angle" type="number" min="1" max="90" default="20" />
        <meta property="obj1_rotationSpeed" label="Strimer: Rotation Speed" type="number" min="-100" max="100" default="0" />
        <meta property="obj1_animationSpeed" label="Strimer: Animation Speed" type="number" min="1" max="50" default="32" />
        <meta property="obj1_animationMode" label="Strimer: Animation Mode" type="combobox" values="loop,bounce,bounce-reversed,bounce-random" default="bounce-random" />
        <meta property="obj1_scrollDir" label="Strimer: Scroll Direction" type="combobox" values="right,left,up,down" default="right" />
        <meta property="obj1_gradType" label="Strimer: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="linear" />
        <meta property="obj1_useSharpGradient" label="Strimer: Use Sharp Gradient" type="boolean" default="true" />
        <meta property="obj1_gradientStop" label="Strimer: Gradient Stop %" type="number" min="0" max="100" default="50" />
        <meta property="obj1_gradColor1" label="Strimer: Color 1" type="color" default="#00ff00" />
        <meta property="obj1_gradColor2" label="Strimer: Color 2" type="color" default="#d400ff" />
        <meta property="obj1_cycleColors" label="Strimer: Cycle Colors" type="boolean" default="false" />
        <meta property="obj1_cycleSpeed" label="Strimer: Color Cycle Speed" type="number" min="1" max="10" default="10" />
        <meta property="obj1_numberOfRows" label="Strimer: Number of Rows" type="number" min="1" max="100" default="8" />
        <meta property="obj1_numberOfColumns" label="Strimer: Number of Columns" type="number" min="1" max="100" default="1" />
        <meta property="obj1_phaseOffset" label="Strimer: Phase Offset" type="number" min="0" max="100" default="35" />
        <meta property="obj2_shape" label="Matrix: Shape" type="combobox" values="rectangle,circle,ring" default="rectangle" />
        <meta property="obj2_x" label="Matrix: X Position" type="number" min="0" max="1280" default="0" />
        <meta property="obj2_y" label="Matrix: Y Position" type="number" min="0" max="800" default="400" />
        <meta property="obj2_width" label="Matrix: Width/Outer Diameter" type="number" min="10" max="1280" default="640" />
        <meta property="obj2_height" label="Matrix: Height" type="number" min="10" max="800" default="400" />
        <meta property="obj2_innerDiameter" label="Matrix: Inner Diameter" type="number" min="5" max="1270" default="200" />
        <meta property="obj2_numberOfSegments" label="Matrix: Segments" type="number" min="1" max="50" default="12" />
        <meta property="obj2_angularWidth" label="Matrix: Segment Angle" type="number" min="1" max="90" default="20" />
        <meta property="obj2_rotationSpeed" label="Matrix: Rotation Speed" type="number" min="-100" max="100" default="0" />
        <meta property="obj2_animationSpeed" label="Matrix: Animation Speed" type="number" min="1" max="50" default="10" />
        <meta property="obj2_animationMode" label="Matrix: Animation Mode" type="combobox" values="loop,bounce,bounce-reversed,bounce-random" default="loop" />
        <meta property="obj2_scrollDir" label="Matrix: Scroll Direction" type="combobox" values="right,left,up,down" default="right" />
        <meta property="obj2_gradType" label="Matrix: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="random" />
        <meta property="obj2_useSharpGradient" label="Matrix: Use Sharp Gradient" type="boolean" default="false" />
        <meta property="obj2_gradientStop" label="Matrix: Gradient Stop %" type="number" min="0" max="100" default="50" />
        <meta property="obj2_gradColor1" label="Matrix: Color 1" type="color" default="#00ff00" />
        <meta property="obj2_gradColor2" label="Matrix: Color 2" type="color" default="#d400ff" />
        <meta property="obj2_cycleColors" label="Matrix: Cycle Colors" type="boolean" default="false" />
        <meta property="obj2_cycleSpeed" label="Matrix: Color Cycle Speed" type="number" min="1" max="10" default="10" />
        <meta property="obj2_numberOfRows" label="Matrix: Number of Rows" type="number" min="1" max="100" default="16" />
        <meta property="obj2_numberOfColumns" label="Matrix: Number of Columns" type="number" min="1" max="100" default="16" />
        <meta property="obj2_phaseOffset" label="Matrix: Phase Offset" type="number" min="0" max="100" default="10" />
        <meta property="obj3_shape" label="Top Fan Center: Shape" type="combobox" values="rectangle,circle,ring" default="circle" />
        <meta property="obj3_x" label="Top Fan Center: X Position" type="number" min="0" max="1280" default="1060" />
        <meta property="obj3_y" label="Top Fan Center: Y Position" type="number" min="0" max="800" default="101" />
        <meta property="obj3_width" label="Top Fan Center: Width/Outer Diameter" type="number" min="10" max="1280" default="112" />
        <meta property="obj3_height" label="Top Fan Center: Height" type="number" min="10" max="800" default="112" />
        <meta property="obj3_innerDiameter" label="Top Fan Center: Inner Diameter" type="number" min="5" max="1270" default="100" />
        <meta property="obj3_numberOfSegments" label="Top Fan Center: Segments" type="number" min="1" max="50" default="12" />
        <meta property="obj3_angularWidth" label="Top Fan Center: Segment Angle" type="number" min="1" max="90" default="15" />
        <meta property="obj3_rotationSpeed" label="Top Fan Center: Rotation Speed" type="number" min="-100" max="100" default="0" />
        <meta property="obj3_animationSpeed" label="Top Fan Center: Animation Speed" type="number" min="1" max="50" default="5" />
        <meta property="obj3_animationMode" label="Top Fan Center: Animation Mode" type="combobox" values="loop,bounce,bounce-reversed,bounce-random" default="loop" />
        <meta property="obj3_scrollDir" label="Top Fan Center: Scroll Direction" type="combobox" values="right,left,up,down" default="left" />
        <meta property="obj3_gradType" label="Top Fan Center: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="radial" />
        <meta property="obj3_useSharpGradient" label="Top Fan Center: Use Sharp Gradient" type="boolean" default="true" />
        <meta property="obj3_gradientStop" label="Top Fan Center: Gradient Stop %" type="number" min="0" max="100" default="100" />
        <meta property="obj3_gradColor1" label="Top Fan Center: Color 1" type="color" default="#00ff00" />
        <meta property="obj3_gradColor2" label="Top Fan Center: Color 2" type="color" default="#d400ff" />
        <meta property="obj3_cycleColors" label="Top Fan Center: Cycle Colors" type="boolean" default="false" />
        <meta property="obj3_cycleSpeed" label="Top Fan Center: Color Cycle Speed" type="number" min="1" max="10" default="10" />
        <meta property="obj3_numberOfRows" label="Top Fan Center: Number of Rows" type="number" min="1" max="100" default="1" />
        <meta property="obj3_numberOfColumns" label="Top Fan Center: Number of Columns" type="number" min="1" max="100" default="1" />
        <meta property="obj3_phaseOffset" label="Top Fan Center: Phase Offset" type="number" min="0" max="100" default="10" />
        <meta property="obj4_shape" label="Top Fan Ring: Shape" type="combobox" values="rectangle,circle,ring" default="ring" />
        <meta property="obj4_x" label="Top Fan Ring: X Position" type="number" min="0" max="1280" default="966" />
        <meta property="obj4_y" label="Top Fan Ring: Y Position" type="number" min="0" max="800" default="7" />
        <meta property="obj4_width" label="Top Fan Ring: Width/Outer Diameter" type="number" min="10" max="1280" default="300" />
        <meta property="obj4_height" label="Top Fan Ring: Height" type="number" min="10" max="800" default="300" />
        <meta property="obj4_innerDiameter" label="Top Fan Ring: Inner Diameter" type="number" min="5" max="1270" default="200" />
        <meta property="obj4_numberOfSegments" label="Top Fan Ring: Segments" type="number" min="1" max="50" default="6" />
        <meta property="obj4_angularWidth" label="Top Fan Ring: Segment Angle" type="number" min="1" max="90" default="40" />
        <meta property="obj4_rotationSpeed" label="Top Fan Ring: Rotation Speed" type="number" min="-100" max="100" default="10" />
        <meta property="obj4_animationSpeed" label="Top Fan Ring: Animation Speed" type="number" min="1" max="50" default="2" />
        <meta property="obj4_animationMode" label="Top Fan Ring: Animation Mode" type="combobox" values="loop,bounce,bounce-reversed,bounce-random" default="loop" />
        <meta property="obj4_scrollDir" label="Top Fan Ring: Scroll Direction" type="combobox" values="right,left,up,down" default="down" />
        <meta property="obj4_gradType" label="Top Fan Ring: Fill Type" type="combobox" values="solid,linear,radial,alternating" default="alternating" />
        <meta property="obj4_useSharpGradient" label="Top Fan Ring: Use Sharp Gradient" type="boolean" default="false" />
        <meta property="obj4_gradientStop" label="Top Fan Ring: Gradient Stop %" type="number" min="0" max="100" default="51" />
        <meta property="obj4_gradColor1" label="Top Fan Ring: Color 1" type="color" default="#00ff00" />
        <meta property="obj4_gradColor2" label="Top Fan Ring: Color 2" type="color" default="#d400ff" />
        <meta property="obj4_cycleColors" label="Top Fan Ring: Cycle Colors" type="boolean" default="false" />
        <meta property="obj4_cycleSpeed" label="Top Fan Ring: Color Cycle Speed" type="number" min="1" max="10" default="10" />
        <meta property="obj4_numberOfRows" label="Top Fan Ring: Number of Rows" type="number" min="1" max="100" default="1" />
        <meta property="obj4_numberOfColumns" label="Top Fan Ring: Number of Columns" type="number" min="1" max="100" default="1" />
        <meta property="obj4_phaseOffset" label="Top Fan Ring: Phase Offset" type="number" min="0" max="100" default="10" />
        <meta property="obj5_shape" label="Bottom Fan Center: Shape" type="combobox" values="rectangle,circle,ring" default="circle" />
        <meta property="obj5_x" label="Bottom Fan Center: X Position" type="number" min="0" max="1280" default="1052" />
        <meta property="obj5_y" label="Bottom Fan Center: Y Position" type="number" min="0" max="800" default="444" />
        <meta property="obj5_width" label="Bottom Fan Center: Width/Outer Diameter" type="number" min="10" max="1280" default="112" />
        <meta property="obj5_height" label="Bottom Fan Center: Height" type="number" min="10" max="800" default="112" />
        <meta property="obj5_innerDiameter" label="Bottom Fan Center: Inner Diameter" type="number" min="5" max="1270" default="100" />
        <meta property="obj5_numberOfSegments" label="Bottom Fan Center: Segments" type="number" min="1" max="50" default="12" />
        <meta property="obj5_angularWidth" label="Bottom Fan Center: Segment Angle" type="number" min="1" max="90" default="15" />
        <meta property="obj5_rotationSpeed" label="Bottom Fan Center: Rotation Speed" type="number" min="-100" max="100" default="0" />
        <meta property="obj5_animationSpeed" label="Bottom Fan Center: Animation Speed" type="number" min="1" max="50" default="5" />
        <meta property="obj5_animationMode" label="Bottom Fan Center: Animation Mode" type="combobox" values="loop,bounce,bounce-reversed,bounce-random" default="loop" />
        <meta property="obj5_scrollDir" label="Bottom Fan Center: Scroll Direction" type="combobox" values="right,left,up,down" default="left" />
        <meta property="obj5_gradType" label="Bottom Fan Center: Fill Type" type="combobox" values="solid,linear,radial,alternating,random" default="radial" />
        <meta property="obj5_useSharpGradient" label="Bottom Fan Center: Use Sharp Gradient" type="boolean" default="true" />
        <meta property="obj5_gradientStop" label="Bottom Fan Center: Gradient Stop %" type="number" min="0" max="100" default="100" />
        <meta property="obj5_gradColor1" label="Bottom Fan Center: Color 1" type="color" default="#00ff00" />
        <meta property="obj5_gradColor2" label="Bottom Fan Center: Color 2" type="color" default="#d400ff" />
        <meta property="obj5_cycleColors" label="Bottom Fan Center: Cycle Colors" type="boolean" default="false" />
        <meta property="obj5_cycleSpeed" label="Bottom Fan Center: Color Cycle Speed" type="number" min="1" max="10" default="10" />
        <meta property="obj5_numberOfRows" label="Bottom Fan Center: Number of Rows" type="number" min="1" max="100" default="1" />
        <meta property="obj5_numberOfColumns" label="Bottom Fan Center: Number of Columns" type="number" min="1" max="100" default="1" />
        <meta property="obj5_phaseOffset" label="Bottom Fan Center: Phase Offset" type="number" min="0" max="100" default="10" />
        <meta property="obj6_shape" label="Bottom Fan Ring: Shape" type="combobox" values="rectangle,circle,ring" default="ring" />
        <meta property="obj6_x" label="Bottom Fan Ring: X Position" type="number" min="0" max="1280" default="958" />
        <meta property="obj6_y" label="Bottom Fan Ring: Y Position" type="number" min="0" max="800" default="350" />
        <meta property="obj6_width" label="Bottom Fan Ring: Width/Outer Diameter" type="number" min="10" max="1280" default="300" />
        <meta property="obj6_height" label="Bottom Fan Ring: Height" type="number" min="10" max="800" default="300" />
        <meta property="obj6_innerDiameter" label="Bottom Fan Ring: Inner Diameter" type="number" min="5" max="1270" default="200" />
        <meta property="obj6_numberOfSegments" label="Bottom Fan Ring: Segments" type="number" min="1" max="50" default="6" />
        <meta property="obj6_angularWidth" label="Bottom Fan Ring: Segment Angle" type="number" min="1" max="90" default="40" />
        <meta property="obj6_rotationSpeed" label="Bottom Fan Ring: Rotation Speed" type="number" min="-100" max="100" default="-10" />
        <meta property="obj6_animationSpeed" label="Bottom Fan Ring: Animation Speed" type="number" min="1" max="50" default="2" />
        <meta property="obj6_animationMode" label="Bottom Fan Ring: Animation Mode" type="combobox" values="loop,bounce,bounce-reversed,bounce-random" default="loop" />
        <meta property="obj6_scrollDir" label="Bottom Fan Ring: Scroll Direction" type="combobox" values="right,left,up,down" default="down" />
        <meta property="obj6_gradType" label="Bottom Fan Ring: Fill Type" type="combobox" values="solid,linear,radial,alternating" default="alternating" />
        <meta property="obj6_useSharpGradient" label="Bottom Fan Ring: Use Sharp Gradient" type="boolean" default="false" />
        <meta property="obj6_gradientStop" label="Bottom Fan Ring: Gradient Stop %" type="number" min="0" max="100" default="51" />
        <meta property="obj6_gradColor1" label="Bottom Fan Ring: Color 1" type="color" default="#00ff00" />
        <meta property="obj6_gradColor2" label="Bottom Fan Ring: Color 2" type="color" default="#d400ff" />
        <meta property="obj6_cycleColors" label="Bottom Fan Ring: Cycle Colors" type="boolean" default="false" />
        <meta property="obj6_cycleSpeed" label="Bottom Fan Ring: Color Cycle Speed" type="number" min="1" max="10" default="10" />
        <meta property="obj6_numberOfRows" label="Bottom Fan Ring: Number of Rows" type="number" min="1" max="100" default="1" />
        <meta property="obj6_numberOfColumns" label="Bottom Fan Ring: Number of Columns" type="number" min="1" max="100" default="1" />
        <meta property="obj6_phaseOffset" label="Bottom Fan Ring: Phase Offset" type="number" min="0" max="100" default="10" />
    </template>

    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        #canvas-container {
            position: relative;
            background-color: #222;
            aspect-ratio: 1280 / 800;
            cursor: default;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
        }

        #signalCanvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .legend-button {
            background: none;
            border: none;
            color: inherit;
            padding: 0;
            width: 100%;
            text-align: left;
            transition: color 0.2s ease;
        }

        .legend-button:not(.collapsed)::after {
            transform: rotate(-180deg);
        }

        .legend-button::after {
            content: '\f282';
            font-family: 'bootstrap-icons';
            display: inline-block;
            transition: transform 0.2s ease-in-out;
            float: right;
        }

        .object-name:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--bs-primary);
        }

        .gutter {
            background-color: var(--bs-tertiary-bg);
            transition: background-color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gutter:hover {
            background-color: var(--bs-primary);
        }

        .gutter i {
            color: var(--bs-secondary-color);
            font-size: 1.25rem;
            transition: color 0.2s ease-in-out;
        }

        .gutter:hover i {
            color: var(--bs-light);
        }

        .gutter.gutter-horizontal {
            cursor: ew-resize;
        }

        .gutter.gutter-vertical {
            cursor: ns-resize;
        }

        #main-split {
            display: flex;
            flex-direction: row;
        }

        .editable-name-area {
            padding: 2px 6px;
            border-radius: 5px;
            transition: background-color 0.2s ease-in-out;
        }

        .editable-name-area:hover {
            cursor: text;
            background-color: var(--bs-tertiary-bg);
        }

        .editable-name-area .bi-pencil-fill {
            opacity: 0.5;
            transition: opacity 0.2s ease-in-out;
        }

        .editable-name-area:hover .bi-pencil-fill {
            opacity: 1;
        }

        .form-range::-webkit-slider-runnable-track {
            background-color: var(--bs-border-color);
        }

        .form-range::-moz-range-track {
            background-color: var(--bs-border-color);
        }
    </style>
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WS7MGSDJSB"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-WS7MGSDJSB');
</script>

<body class="d-flex flex-column vh-100">
    <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Interactive Effect Builder v1.0</a>
            <div class="d-flex">
                <div class="btn-group" role="group" aria-label="Button group with nested dropdown">
                    <div class="btn-group" role="group">
                        <button class="btn btn-outline-info" type="button" id="theme-dropdown-button" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi" id="theme-icon"></i>
                        </button>
                        <ul class="dropdown-menu">
                            <li><button class="dropdown-item d-flex align-items-center" type="button" data-bs-theme-value="light">
                                    <i class="bi bi-sun-fill me-2"></i>Light<i class="bi bi-check2 ms-auto d-none"></i>
                                </button></li>
                            <li><button class="dropdown-item d-flex align-items-center" type="button" data-bs-theme-value="dark">
                                    <i class="bi bi-moon-stars-fill me-2"></i>Dark<i class="bi bi-check2 ms-auto d-none"></i>
                                </button></li>
                            <li><button class="dropdown-item d-flex align-items-center" type="button" data-bs-theme-value="auto">
                                    <i class="bi bi-circle-half me-2"></i>Auto<i class="bi bi-check2 ms-auto d-none"></i>
                                </button></li>
                        </ul>
                    </div>
                    <button class="btn btn-outline-info" id="help-btn" data-bs-toggle="modal" data-bs-target="#help-modal"><i class="bi bi-question-circle"></i> Help</button>
                    <button class="btn btn-outline-info" id="about-btn" data-bs-toggle="modal" data-bs-target="#about-modal"><i class="bi bi-info-circle"></i> About</button>
                    <button class="btn btn-outline-primary" id="save-ws-btn" data-bs-toggle="tooltip" title="Save Workspace to Browser Storage"><i class="bi bi-save"></i> Save</button>
                    <button class="btn btn-outline-secondary" id="load-ws-btn" data-bs-toggle="tooltip" title="Load Workspace from Browser Storage"><i class="bi bi-folder2-open"></i> Load</button>
                    <button class="btn btn-outline-success" id="export-btn" data-bs-toggle="tooltip" title="Export complete HTML file"><i class="bi bi-download"></i> Export</button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid flex-grow-1 overflow-hidden p-0">
        <div class="h-100" id="main-split">
            <div id="left-panel" class="h-100 p-3 border-end bg-body-tertiary" style="overflow: auto;">
                <div class="h-100 d-flex flex-column">
                    <div class="flex-grow-1 overflow-auto pe-2">
                        <h4 class="text-body-emphasis">Controls</h4>
                        <form id="controls-form"></form>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-success w-100" id="add-object-btn" data-bs-toggle="tooltip" title="Add a new default object to the scene"><i class="bi bi-plus-circle"></i> Add New
                            Object</button>
                    </div>
                </div>
            </div>

            <div id="right-panel" class="d-flex flex-column h-100">
                <div id="right-panel-top" class="d-flex flex-column" style="overflow: auto; min-height: 0;">
                    <div class="p-0">
                        <div id="toolbar" class="bg-body-tertiary p-2 rounded d-flex flex-wrap">
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-secondary" id="constrain-btn" data-bs-toggle="tooltip" title="Toggle Constrain to Canvas"><i class="bi bi-magnet-fill"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-secondary" data-action="align-screen-left" data-bs-toggle="tooltip" title="Align Left to Screen"><i class="bi bi-align-start"></i></button>
                                <button type="button" class="btn btn-secondary" data-action="align-screen-h-center" data-bs-toggle="tooltip" title="Align Horizontal Center to Screen"><i class="bi bi-align-center"></i></button>
                                <button type="button" class="btn btn-secondary" data-action="align-screen-right" data-bs-toggle="tooltip" title="Align Right to Screen"><i class="bi bi-align-end"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-secondary" data-action="align-screen-top" data-bs-toggle="tooltip" title="Align Top to Screen"><i class="bi bi-align-top"></i></button>
                                <button type="button" class="btn btn-secondary" data-action="align-screen-v-center" data-bs-toggle="tooltip" title="Align Vertical Center to Screen"><i class="bi bi-align-middle"></i></button>
                                <button type="button" class="btn btn-secondary" data-action="align-screen-bottom" data-bs-toggle="tooltip" title="Align Bottom to Screen"><i class="bi bi-align-bottom"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-secondary" data-action="match-width" data-bs-toggle="tooltip" title="Match Width of First Selected"><i class="bi bi-arrows-expand-vertical"></i> W</button>
                                <button type="button" class="btn btn-secondary" data-action="match-height" data-bs-toggle="tooltip" title="Match Height of First Selected"><i class="bi bi-arrows-expand"></i> H</button>
                                <button type="button" class="btn btn-secondary" data-action="match-both" data-bs-toggle="tooltip" title="Match Size of First Selected"><i class="bi bi-fullscreen"></i></button>
                                <button type="button" class="btn btn-secondary" data-action="fit-canvas" data-bs-toggle="tooltip" title="Fit to Canvas"><i class="bi bi-arrows-fullscreen"></i></button>
                            </div>
                        </div>
                    </div>
                    <div class="flex-grow-1 bg-body-tertiary" style="min-height: 0; position: relative;">
                        <div id="canvas-container" class="mx-auto border border-secondary">
                            <canvas id="signalCanvas"></canvas>
                        </div>
                    </div>
                </div>
                <div id="right-panel-bottom" class="output-panel d-flex flex-column p-3 border-top bg-body-tertiary">
                    <h5 class="text-body-emphasis mb-2">Generated Script Header</h5>

                    <div class="d-flex flex-grow-1">
                        <textarea id="output-script" class="form-control flex-grow-1" readonly></textarea>
                        <button class="btn btn-primary ms-2" id="copy-btn" ...>
                            <i class="bi bi-clipboard"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="copy-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="5000">
            <div class="toast-header bg-success text-white">
                <strong class="me-auto">Success</strong>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body">
                Script header copied to clipboard!
            </div>
        </div>
    </div>

    <div class="modal fade" id="load-project-modal" tabindex="-1" aria-labelledby="loadProjectModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="loadProjectModalLabel">Load Project</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Select a project to load. This will overwrite your current workspace.</p>
                    <ul class="list-group" id="load-project-list"></ul>
                </div>
            </div>
        </div>
    </div>
    <div class="modal fade" id="save-project-modal" tabindex="-1" aria-labelledby="saveProjectModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="saveProjectModalLabel">Save Project</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="save-project-name-input" class="form-label">Project Name:</label>
                        <input type="text" class="form-control" id="save-project-name-input" placeholder="Enter a name for your project...">
                    </div>
                    <hr>
                    <p>Existing Projects:</p>
                    <ul class="list-group" id="save-project-existing-list">
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirm-save-btn">Save Project</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal fade" id="notification-modal" tabindex="-1" aria-labelledby="notificationModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="notificationModalLabel">Success</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="notification-modal-body">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal fade" id="confirm-overwrite-modal" tabindex="-1" aria-labelledby="confirmOverwriteModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="confirmOverwriteModalLabel">Confirm Overwrite</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="confirm-overwrite-modal-body">
                    A project with this name already exists. Do you want to overwrite it?
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirm-overwrite-btn">Overwrite</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="help-modal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="helpModalLabel"><i class="bi bi-question-circle me-2"></i>How to Use the
                        Effect Builder</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <h6 class="text-info">The Controls Panel (Left)</h6>
                    <p>This is where you manage all the objects in your scene.</p>
                    <ul class="list-unstyled">
                        <li><strong>Add New Object:</strong> Use the green button at the bottom to add a new shape to
                            the canvas.</li>
                        <li><strong>Object Panels:</strong> Each object gets its own collapsible panel. Click the
                            object's name to expand or collapse its properties.</li>
                        <li><strong>Rename:</strong> Click directly on an object's name (e.g., "Object 1") to edit it.
                        </li>
                        <li><strong>Reorder:</strong> Click and drag the <i class="bi bi-grip-vertical"></i> icon to
                            change the rendering order of the objects.</li>
                        <li><strong>Lock/Unlock:</strong> Use the <i class="bi bi-unlock-fill"></i> / <i class="bi bi-lock-fill"></i> button to prevent an object from being moved or resized on
                            the canvas.</li>
                        <li><strong>Duplicate/Delete:</strong> Use the menu button (<i class="bi bi-list"></i>) to
                            access options for duplicating or deleting an object.</li>
                    </ul>

                    <h6 class="text-info mt-4">The Canvas (Center)</h6>
                    <p>This is the visual editor where you can directly manipulate objects.</p>
                    <ul class="list-unstyled">
                        <li><strong>Select:</strong> Click on an object to select it. Its properties will appear in the
                            Controls Panel.</li>
                        <li><strong>Multi-Select:</strong> Hold <kbd>Shift</kbd> or <kbd>Ctrl</kbd> while clicking to
                            select multiple objects.</li>
                        <li><strong>Drag:</strong> Click and drag a selected object to move it.</li>
                        <li><strong>Resize:</strong> Click and drag the handles on the corners and sides of a selected
                            object to resize it.</li>
                    </ul>

                    <h6 class="text-info mt-4">The Code Panel (Bottom Right)</h6>
                    <p>This panel shows the generated HTML meta tags that represent your effect. This is the code you
                        would copy and use in another project.</p>
                    <ul class="list-unstyled">
                        <li><strong>Copy to Clipboard:</strong> Use this button to copy all the generated code.</li>
                    </ul>

                    <h6 class="text-info mt-4">Main Toolbar (Top)</h6>
                    <ul class="list-unstyled">
                        <li><strong>Save:</strong> Opens a dialog to save your entire workspace (all objects and
                            settings) to your browser's local storage.</li>
                        <li><strong>Load:</strong> Opens a dialog to load a previously saved workspace.</li>
                        <li><strong>Export:</strong> Generates and downloads a complete, standalone HTML file of your
                            effect.</li>
                    </ul>
                    <h6 class="text-info mt-4">How to install the effect in SignalRGB</h6>
                    <ul class="list-unstyled">
                        <li>Move the html file generated by this tool to your 'Documents\WhirlwindFX\Effects' folder.
                            Preferably within a folder with the same name as the file for organization.</li>
                        <li>Restart SignalRGB</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Got it!</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="about-modal" tabindex="-1" aria-labelledby="aboutModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="aboutModalLabel"><i class="bi bi-info-circle me-2"></i>About This Tool
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <h6>Interactive Effect Builder</h6>
                    <img src="srgbieb_crop.png" class="img-fluid rounded mb-3">
                    <p>This tool is designed to help developers create and customize complex visual effects for
                        SignalRGB using a simple graphical interface. The output is a set of standard HTML meta tags
                        that can be easily integrated into the <a href="https://github.com/joseamirandavelez/EffectClass">EffectClass</a> effect template. The
                        tool can also export the whole effect for you.</p>

                    <p class="small text-body-secondary mt-4">
                        <strong>Disclaimer:</strong> This tool is an independent project and is not affiliated with,
                        endorsed by, or in any way officially connected with the SignalRGB software or its respective
                        owners. The use of the SignalRGB name is for descriptive purposes only.
                    </p>

                    <hr>

                    <div class="d-flex justify-content-between align-items-center">
                        <p class="mb-0"><strong>Developer:</strong> Jose Miranda</p>
                        <a href="#" data-bs-toggle="modal" data-bs-target="#terms-modal">Terms of Usage</a>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="terms-modal" tabindex="-1" aria-labelledby="termsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="termsModalLabel"><i class="bi bi-file-text me-2"></i>Terms of Usage</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>By using this Interactive Effect Builder (the "Tool"), you agree to the following terms:</p>

                    <h6 class="mt-4">1. No Warranty</h6>
                    <p>This Tool is provided "as-is", without any warranties of any kind, express or implied. The
                        developer makes no guarantees regarding its functionality, reliability, or suitability for any
                        particular purpose.</p>

                    <h6 class="mt-4">2. Limitation of Liability</h6>
                    <p>In no event shall the developer be liable for any claim, damages, or other liability arising from
                        the use of, or inability to use, the Tool.</p>

                    <h6 class="mt-4">3. User Responsibility</h6>
                    <p>You are solely responsible for the effects you create and their use. It is your responsibility to
                        ensure they comply with the terms of service of any platform or application they are used with,
                        including SignalRGB.</p>

                    <h6 class="mt-4">4. License</h6>
                    <p>This Tool is free to use, modify, and distribute. Attribution is appreciated but not required.
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">I Understand</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/split.js/dist/split.min.js"></script>

    <script>
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function lerpColor(a, b, amount) {
            const amt = Math.max(0, Math.min(1, amount));
            const ah = parseInt(a.slice(1), 16),
                ar = ah >> 16,
                ag = (ah >> 8) & 0xff,
                ab = ah & 0xff,
                bh = parseInt(b.slice(1), 16),
                br = bh >> 16,
                bg = (bh >> 8) & 0xff,
                bb = bh & 0xff,
                rr = Math.round(ar + amt * (br - ar)),
                rg = Math.round(ag + amt * (bg - ag)),
                rb = Math.round(ab + amt * (bb - ab));
            return '#' + (rr << 16 | rg << 8 | rb).toString(16).padStart(6, '0');
        }

        function getPatternColor(t, c1, c2) {
            t = (t % 1.0 + 1.0) % 1.0;
            const isHsl = c1.startsWith('hsl');
            if (isHsl) {
                const hue1 = parseFloat(c1.match(/hsl\((\d+\.?\d*)/)[1]);
                const hue2 = parseFloat(c2.match(/hsl\((\d+\.?\d*)/)[1]);
                let finalHue;
                if (t < 0.5) {
                    finalHue = hue1 + (t / 0.5) * (hue2 - hue1);
                } else {
                    finalHue = hue2 + ((t - 0.5) / 0.5) * (hue1 - hue2);
                }
                return `hsl(${finalHue % 360}, 100%, 50%)`;
            } else {
                if (t < 0.5) return lerpColor(c1, c2, t / 0.5);
                else return lerpColor(c2, c1, (t - 0.5) / 0.5);
            }
        }

        class Shape {
            constructor({
                id, name, shape, x, y, width, height, gradient, gradType,
                gradientDirection, scrollDirection, cycleColors, cycleSpeed, animationSpeed, ctx,
                innerDiameter, angularWidth, numberOfSegments, rotationSpeed, useSharpGradient, gradientStop, locked,
                numberOfRows, numberOfColumns, phaseOffset, animationMode
            }) {
                this.id = id;
                this.name = name || `Object ${id}`;
                this.shape = shape;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.gradient = gradient || { color1: '#000000', color2: '#000000' };
                this.gradType = gradType || 'solid';
                this.gradientDirection = gradientDirection || 'horizontal';
                this.scrollDirection = scrollDirection || 'right';
                this.cycleColors = cycleColors || false;
                this.cycleSpeed = cycleSpeed || 0;
                this.animationSpeed = animationSpeed || 0;
                this.animationMode = animationMode || 'loop';
                this.isReversing = false;
                this.animationState = 'scrolling';
                this.waitTimer = 0;
                this.ctx = ctx;
                this.hue1 = 0;
                this.hue2 = 90;
                this.scrollOffset = 0;
                this.innerDiameter = innerDiameter;
                this.angularWidth = angularWidth;
                this.numberOfSegments = numberOfSegments;
                this.rotationSpeed = rotationSpeed || 0;
                this.rotationAngle = 0;
                this.useSharpGradient = useSharpGradient !== undefined ? useSharpGradient : false;
                this.gradientStop = gradientStop !== undefined ? parseFloat(gradientStop) : 50;
                this.locked = locked || false;
                this.numberOfRows = numberOfRows || 1;
                this.numberOfColumns = numberOfColumns || 1;
                this.phaseOffset = phaseOffset || 10;
                this.cellOrder = [];
                this._shuffleCellOrder();
                this.handleSize = 8;
                this.handles = [
                    { name: 'top-left', cursor: 'nwse-resize' }, { name: 'top', cursor: 'ns-resize' }, { name: 'top-right', cursor: 'nesw-resize' },
                    { name: 'left', cursor: 'ew-resize' }, { name: 'right', cursor: 'ew-resize' },
                    { name: 'bottom-left', cursor: 'nesw-resize' }, { name: 'bottom', cursor: 'ns-resize' }, { name: 'bottom-right', cursor: 'nwse-resize' }
                ];
                this.randomColorTimer = 0;
                this.cellColors = [];
            }

            _shuffleCellOrder() {
                const totalCells = this.numberOfRows * this.numberOfColumns;
                this.cellOrder = Array.from({ length: totalCells }, (_, i) => i);
                for (let i = this.cellOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cellOrder[i], this.cellOrder[j]] = [this.cellOrder[j], this.cellOrder[i]];
                }
            }

            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }

            getHandlePositions() {
                const h2 = this.handleSize / 2;
                return {
                    'top-left': { x: this.x - h2, y: this.y - h2 },
                    'top': { x: this.x + this.width / 2 - h2, y: this.y - h2 },
                    'top-right': { x: this.x + this.width - h2, y: this.y - h2 },
                    'left': { x: this.x - h2, y: this.y + this.height / 2 - h2 },
                    'right': { x: this.x + this.width - h2, y: this.y + this.height / 2 - h2 },
                    'bottom-left': { x: this.x - h2, y: this.y + this.height - h2 },
                    'bottom': { x: this.x + this.width / 2 - h2, y: this.y + this.height - h2 },
                    'bottom-right': { x: this.x + this.width - h2, y: this.y + this.height - h2 }
                };
            }

            getHandleAtPoint(px, py) {
                const handlePositions = this.getHandlePositions();
                if (this.shape === 'ring') {
                    for (const handle of this.handles) {
                        const pos = handlePositions[handle.name];
                        if (px >= pos.x && px <= pos.x + this.handleSize && py >= pos.y && py <= pos.y + this.handleSize) {
                            return handle;
                        }
                    }
                    return null;
                }
                const localPoint = this.getLocalPoint(px, py);
                for (const handle of this.handles) {
                    const pos = handlePositions[handle.name];
                    if (localPoint.x >= pos.x && localPoint.x <= pos.x + this.handleSize && localPoint.y >= pos.y && localPoint.y <= pos.y + this.handleSize) {
                        return handle;
                    }
                }
                return null;
            }

            getLocalPoint(px, py) {
                const center = this.getCenter();
                const angle = -this.rotationAngle;
                const s = Math.sin(angle);
                const c = Math.cos(angle);
                let tempX = px - center.x;
                let tempY = py - center.y;
                const rotatedX = tempX * c - tempY * s;
                const rotatedY = tempX * s + tempY * c;
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            }

            getWorldCoordsOfCorner(handleName) {
                const handlePositions = this.getHandlePositions();
                const h2 = this.handleSize / 2;
                const localCorner = { x: handlePositions[handleName].x + h2, y: handlePositions[handleName].y + h2 };
                if (this.shape === 'ring') {
                    return localCorner;
                }
                const center = this.getCenter();
                const angle = this.rotationAngle;
                const s = Math.sin(angle);
                const c = Math.cos(angle);
                let tempX = localCorner.x - center.x;
                let tempY = localCorner.y - center.y;
                const rotatedX = tempX * c - tempY * s;
                const rotatedY = tempX * s + tempY * c;
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            }

            updateAnimationState() {
                if (this.cycleColors) {
                    this.hue1 += this.cycleSpeed;
                    this.hue2 += this.cycleSpeed;
                }

                if (this.gradType !== 'solid' && this.gradType !== 'alternating' && this.gradType !== 'random') {
                    const increment = this.animationSpeed * 0.01;
                    const isBounceMode = this.animationMode.includes('bounce');

                    if (isBounceMode) {
                        if (this.animationState === 'waiting') {
                            this.waitTimer--;
                            if (this.waitTimer <= 0) {
                                this.isReversing = !this.isReversing;
                                this.animationState = 'scrolling';

                                if (this.animationMode === 'bounce-random') {
                                    this._shuffleCellOrder();
                                }
                            }
                        } else if (this.animationState === 'scrolling') {
                            const bandWidth = this.gradientStop / 100.0;

                            if (this.isReversing) {
                                this.scrollOffset -= increment;
                                const lastCellIndex = Math.max(0, (this.numberOfRows * this.numberOfColumns) - 1);
                                const phaseIncrement = this.phaseOffset / 100.0;
                                const slowestCellTailPosition = this.scrollOffset + (lastCellIndex * phaseIncrement) + bandWidth;

                                if (slowestCellTailPosition <= 0.0) {
                                    this.scrollOffset = 0.0 - bandWidth - (lastCellIndex * phaseIncrement);
                                    this.animationState = 'waiting';
                                    this.waitTimer = 30;
                                }
                            } else { // Moving forward
                                this.scrollOffset += increment;
                                const forwardBoundary = 1.0;
                                if (this.scrollOffset >= forwardBoundary) {
                                    this.scrollOffset = forwardBoundary;
                                    this.animationState = 'waiting';
                                    this.waitTimer = 30;
                                }
                            }
                        }
                    } else { // Default 'loop' mode
                        const directionMultiplier = (this.scrollDirection === 'right' || this.scrollDirection === 'down') ? 1 : -1;
                        this.scrollOffset += increment * directionMultiplier;
                        this.scrollOffset = (this.scrollOffset % 1.0 + 1.0) % 1.0;
                    }
                }

                this.rotationAngle += (this.rotationSpeed / 1000);
            }

            createFillStyle(phase = 0) {
                let phaseIndex = phase;
                if (this.animationMode === 'bounce-random') {
                    if (this.cellOrder && this.cellOrder.length > phase) {
                        phaseIndex = this.cellOrder[phase];
                    }
                } else if (this.animationMode === 'bounce-reversed' && this.isReversing) {
                    const lastCellIndex = Math.max(0, (this.numberOfRows * this.numberOfColumns) - 1);
                    phaseIndex = lastCellIndex - phase;
                }

                const phaseIncrement = this.phaseOffset / 100.0;
                const effectiveScrollOffset = this.scrollOffset + phaseIndex * phaseIncrement;

                const p = this.animationMode === 'loop' ?
                    (effectiveScrollOffset % 1.0 + 1.0) % 1.0 :
                    effectiveScrollOffset;
                const c1 = this.cycleColors ? `hsl(${(this.hue1 + phase * this.phaseOffset) % 360}, 100%, 50%)` : this.gradient.color1;
                const c2 = this.cycleColors ? `hsl(${(this.hue2 + phase * this.phaseOffset) % 360}, 100%, 50%)` : this.gradient.color2;
                const isLinear = this.gradType && this.gradType.includes('linear');
                const isRadial = this.gradType && this.gradType.includes('radial');
                if (this.gradType === 'alternating') {
                    return (phase % 2 === 0) ? c1 : c2;
                }
                if (isLinear) {
                    let grad;
                    if (this.gradientDirection === 'horizontal') {
                        grad = this.ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
                    } else {
                        grad = this.ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                    }
                    if (this.useSharpGradient) {
                        const stopRatio = this.gradientStop / 100.0;
                        if (this.animationMode === 'loop') {
                            const p1 = p;
                            const p2 = p1 + stopRatio;
                            if (p2 > 1.0) {
                                const wrapped_p2 = p2 - 1.0;
                                grad.addColorStop(0, c1);
                                grad.addColorStop(wrapped_p2, c1);
                                grad.addColorStop(wrapped_p2, c2);
                                grad.addColorStop(p1, c2);
                                grad.addColorStop(p1, c1);
                                grad.addColorStop(1, c1);
                            } else {
                                grad.addColorStop(0, c2);
                                grad.addColorStop(p1, c2);
                                grad.addColorStop(p1, c1);
                                grad.addColorStop(p2, c1);
                                grad.addColorStop(p2, c2);
                                grad.addColorStop(1, c2);
                            }
                        } else {
                            const p1 = p;
                            const p2 = p1 + stopRatio;
                            const clamped_p1 = Math.max(0, Math.min(1, p1));
                            const clamped_p2 = Math.max(0, Math.min(1, p2));
                            grad.addColorStop(0, c2);
                            if (clamped_p1 > 0) grad.addColorStop(clamped_p1, c2);
                            if (clamped_p1 < clamped_p2) {
                                grad.addColorStop(clamped_p1, c1);
                                grad.addColorStop(clamped_p2, c1);
                            }
                            if (clamped_p2 < 1) grad.addColorStop(clamped_p2, c2);
                            grad.addColorStop(1, c2);
                        }
                    } else {
                        const stops = [];
                        stops.push({ pos: 0, color: getPatternColor(0 - p, c1, c2) });
                        for (let i = -2; i <= 2; i++) {
                            const c1_pos = i + p;
                            const c2_pos = i + 0.5 + p;
                            if (c1_pos > 0 && c1_pos < 1) stops.push({ pos: c1_pos, color: c1 });
                            if (c2_pos > 0 && c2_pos < 1) stops.push({ pos: c2_pos, color: c2 });
                        }
                        stops.push({ pos: 1, color: getPatternColor(1 - p, c1, c2) });
                        const uniqueStops = stops.sort((a, b) => a.pos - b.pos).filter((stop, index, self) => index === 0 || stop.pos > self[index - 1].pos);
                        uniqueStops.forEach(stop => grad.addColorStop(stop.pos, stop.color));
                    }
                    return grad;
                } else if (isRadial) {
                    const centerX = this.x + this.width / 2;
                    const centerY = this.y + this.height / 2;
                    const maxRadius = Math.max(this.width, this.height) / 2;
                    const grad = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
                    const radialP = (p % 1.0 + 1.0) % 1.0;
                    const wave = 1 - Math.abs(2 * radialP - 1);
                    if (this.useSharpGradient) {
                        const stopPoint = (this.gradientStop / 100) * wave;
                        grad.addColorStop(0, c1);
                        grad.addColorStop(stopPoint, c1);
                        grad.addColorStop(Math.min(1, stopPoint + 0.001), c2);
                        grad.addColorStop(1, c2);
                    } else {
                        const gradientStopPosition = this.gradientStop / 100.0;
                        const midPoint = gradientStopPosition * wave;
                        grad.addColorStop(0, c1);
                        grad.addColorStop(midPoint, c2);
                        grad.addColorStop(1, c1);
                    }
                    return grad;
                }
                return c1 || 'black';
            }

            draw(enableAnimation, isSelected) {
                this.ctx.save();
                if (enableAnimation) {
                    this.updateAnimationState();
                }
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                this.ctx.save();
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(this.rotationAngle);
                this.ctx.translate(-centerX, -centerY);
                if (this.shape === 'ring') {
                    const outerRadius = this.width / 2;
                    const innerRadius = this.innerDiameter / 2;
                    const angleStep = (2 * Math.PI) / this.numberOfSegments;
                    const segmentAngleRad = (this.angularWidth * Math.PI) / 180;
                    if (innerRadius >= 0 && innerRadius < outerRadius && this.numberOfSegments > 0) {
                        const isAlternating = this.gradType === 'alternating';
                        const c1 = this.cycleColors ? `hsl(${this.hue1 % 360}, 100%, 50%)` : this.gradient.color1;
                        const c2 = this.cycleColors ? `hsl(${this.hue2 % 360}, 100%, 50%)` : this.gradient.color2;
                        const genericFill = isAlternating ? null : this.createFillStyle();
                        for (let i = 0; i < this.numberOfSegments; i++) {
                            this.ctx.beginPath();
                            const startAngle = i * angleStep;
                            const endAngle = startAngle + segmentAngleRad;
                            this.ctx.moveTo(centerX + Math.cos(startAngle) * outerRadius, centerY + Math.sin(startAngle) * outerRadius);
                            this.ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
                            this.ctx.lineTo(centerX + Math.cos(endAngle) * innerRadius, centerY + Math.sin(endAngle) * innerRadius);
                            this.ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
                            this.ctx.closePath();
                            if (isAlternating) {
                                this.ctx.fillStyle = (i % 2 === 0) ? c1 : c2;
                            } else {
                                this.ctx.fillStyle = genericFill;
                            }
                            this.ctx.fill();
                        }
                    }
                } else if (this.shape === 'rectangle' && (this.numberOfRows > 1 || this.numberOfColumns > 1)) {
                    const cellWidth = this.width / this.numberOfColumns;
                    const cellHeight = this.height / this.numberOfRows;
                    const isRandom = this.gradType === 'random';
                    const c1 = this.cycleColors ? `hsl(${this.hue1 % 360}, 100%, 50%)` : this.gradient.color1;
                    const c2 = this.cycleColors ? `hsl(${this.hue2 % 360}, 100%, 50%)` : this.gradient.color2;
                    if (isRandom && enableAnimation) { // BUG FIX: Added 'enableAnimation' check
                        this.randomColorTimer -= 1;
                        if (this.randomColorTimer <= 0) {
                            this.cellColors = [];
                            const rawSpeed = this.animationSpeed * 25;
                            this.randomColorTimer = Math.max(1, 200 / rawSpeed);
                        }
                    }
                    for (let row = 0; row < this.numberOfRows; row++) {
                        for (let col = 0; col < this.numberOfColumns; col++) {
                            const cellX = this.x + col * cellWidth;
                            const cellY = this.y + row * cellHeight;
                            const cellIndex = row * this.numberOfColumns + col;
                            if (isRandom) {
                                if (!this.cellColors[cellIndex]) {
                                    this.cellColors[cellIndex] = Math.random() < 0.5 ? c1 : c2;
                                }
                                this.ctx.fillStyle = this.cellColors[cellIndex];
                                this.ctx.fillRect(cellX, cellY, cellWidth, cellHeight);
                            } else {
                                this.ctx.save();
                                this.ctx.beginPath();
                                this.ctx.rect(cellX, cellY, cellWidth, cellHeight);
                                this.ctx.clip();
                                this.ctx.fillStyle = this.createFillStyle(cellIndex);
                                this.ctx.fillRect(this.x, this.y, this.width, this.height);
                                this.ctx.restore();
                            }
                        }
                    }
                } else {
                    this.ctx.beginPath();
                    switch (this.shape) {
                        case 'rectangle':
                            this.ctx.rect(this.x, this.y, this.width, this.height);
                            break;
                        case 'circle':
                            this.ctx.arc(centerX, centerY, this.width / 2, 0, 2 * Math.PI);
                            break;
                    }
                    this.ctx.fillStyle = this.createFillStyle();
                    this.ctx.fill();
                }
                this.ctx.restore();
                if (isSelected && !this.locked) {
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(this.rotationAngle);
                    this.ctx.translate(-centerX, -centerY);
                    this.ctx.strokeStyle = '#00f6ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(this.x, this.y, this.width, this.height);
                    this.ctx.setLineDash([]);
                    this.ctx.fillStyle = '#00f6ff';
                    const handlePositions = this.getHandlePositions();
                    for (const handle of this.handles) {
                        const pos = handlePositions[handle.name];
                        this.ctx.fillRect(pos.x, pos.y, this.handleSize, this.handleSize);
                    }
                    this.ctx.restore();
                }
                if (this.locked) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.5;
                    this.ctx.fillStyle = 'gray';
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('', centerX, centerY);
                    this.ctx.restore();
                }
                this.ctx.restore();
            }

            isPointInside(px, py) {
                const localPoint = this.getLocalPoint(px, py);
                return (localPoint.x >= this.x && localPoint.x <= this.x + this.width && localPoint.y >= this.y && localPoint.y <= this.y + this.height);
            }

            update(props) {
                const oldRows = this.numberOfRows;
                const oldCols = this.numberOfColumns;

                for (const key in props) {
                    if (props[key] !== undefined) {
                        if (key === 'gradient' && typeof props[key] === 'object' && props[key] !== null) {
                            if (props.gradient.color1 !== undefined) this.gradient.color1 = props.gradient.color1;
                            if (props.gradient.color2 !== undefined) this.gradient.color2 = props.gradient.color2;
                        } else if (this.hasOwnProperty(key)) {
                            this[key] = props[key];
                        }
                    }
                }

                if (this.numberOfRows !== oldRows || this.numberOfColumns !== oldCols) {
                    this._shuffleCellOrder();
                }
            }
        }


        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('signalCanvas');
            const canvasContainer = document.getElementById('canvas-container');
            const ctx = canvas.getContext('2d');
            canvas.width = 1280;
            canvas.height = 800;

            const form = document.getElementById('controls-form');
            const outputScriptArea = document.getElementById('output-script');
            const copyBtn = document.getElementById('copy-btn');
            const copyToastEl = document.getElementById('copy-toast');
            const copyToast = new bootstrap.Toast(copyToastEl);
            const toolbar = document.getElementById('toolbar');
            const addObjectBtn = document.getElementById('add-object-btn');
            const constrainBtn = document.getElementById('constrain-btn');
            const loadProjectModalEl = document.getElementById('load-project-modal');
            const loadProjectModal = new bootstrap.Modal(loadProjectModalEl);
            const loadProjectList = document.getElementById('load-project-list');
            const collapseCodeBtn = document.getElementById('collapse-code-btn');
            const exportBtn = document.getElementById('export-btn');
            const saveProjectModalEl = document.getElementById('save-project-modal');
            const saveProjectModal = new bootstrap.Modal(saveProjectModalEl);
            const saveProjectNameInput = document.getElementById('save-project-name-input');
            const confirmSaveBtn = document.getElementById('confirm-save-btn');
            const existingProjectList = document.getElementById('save-project-existing-list');
            const notificationModalEl = document.getElementById('notification-modal');
            const notificationModal = new bootstrap.Modal(notificationModalEl);
            const notificationModalBody = document.getElementById('notification-modal-body');
            const confirmOverwriteModalEl = document.getElementById('confirm-overwrite-modal');
            const confirmOverwriteModal = new bootstrap.Modal(confirmOverwriteModalEl);
            const confirmOverwriteBtn = document.getElementById('confirm-overwrite-btn');
            let projectToSave = {};
            const helpBtn = document.getElementById('help-btn');
            const aboutBtn = document.getElementById('about-btn');
            const helpModal = new bootstrap.Modal(document.getElementById('help-modal'));
            const aboutModal = new bootstrap.Modal(document.getElementById('about-modal'));

            let configStore = [];
            let objects = [];
            let selectedObjectIds = [];
            let isDragging = false;
            let isResizing = false;
            let activeResizeHandle = null;
            let dragStartX, dragStartY;
            let initialDragState = [];
            let constrainToCanvas = true;
            const projectPrefix = 'effectBuilderProject_';
            let verticalSplit, horizontalSplit;
            let lastHSizes, lastVSizes;
            let isCodePanelCollapsed = false;

            // --- START: Color Mode Switcher Logic ---

            const getStoredTheme = () => localStorage.getItem('theme');
            const setStoredTheme = theme => localStorage.setItem('theme', theme);

            const getPreferredTheme = () => {
                const storedTheme = getStoredTheme();
                if (storedTheme) {
                    return storedTheme;
                }
                return 'dark';
            };

            const setTheme = theme => {
                if (theme === 'auto') {
                    document.documentElement.setAttribute('data-bs-theme', (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'));
                } else {
                    document.documentElement.setAttribute('data-bs-theme', theme);
                }
            };

            const updateThemeSwitcherUI = (theme) => {
                const themeIcon = document.getElementById('theme-icon');
                const themeButtons = document.querySelectorAll('[data-bs-theme-value]');

                if (theme === 'auto') {
                    themeIcon.className = 'bi bi-circle-half';
                } else if (theme === 'dark') {
                    themeIcon.className = 'bi bi-moon-stars-fill';
                } else {
                    themeIcon.className = 'bi bi-sun-fill';
                }

                themeButtons.forEach(button => {
                    const checkmark = button.querySelector('.bi-check2');
                    if (button.getAttribute('data-bs-theme-value') === theme) {
                        button.classList.add('active');
                        checkmark.classList.remove('d-none');
                    } else {
                        button.classList.remove('active');
                        checkmark.classList.add('d-none');
                    }
                });
            };

            const initialTheme = getPreferredTheme();
            setTheme(initialTheme);
            updateThemeSwitcherUI(initialTheme);


            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                if (getPreferredTheme() === 'auto') {
                    setTheme('auto');
                }
            });

            document.querySelectorAll('[data-bs-theme-value]').forEach(button => {
                button.addEventListener('click', () => {
                    const theme = button.getAttribute('data-bs-theme-value');
                    setStoredTheme(theme);
                    setTheme(theme);
                    updateThemeSwitcherUI(theme);
                });
            });

            // --- END: Color Mode Switcher Logic ---


            function showNotification(message) {
                notificationModalBody.textContent = message;
                notificationModal.show();
            }

            // [FIX] This function now correctly handles both meta tag formats.
            function parseMetaToConfig(metaElement) {
                const config = {};

                // Check for the new format first (e.g., <meta description="..." />)
                if (metaElement.hasAttribute('description')) {
                    config.name = 'description';
                    config.default = metaElement.getAttribute('description');
                    config.type = 'text';
                    config.label = 'Description';
                } else if (metaElement.hasAttribute('publisher')) {
                    config.name = 'publisher';
                    config.default = metaElement.getAttribute('publisher');
                    config.type = 'text';
                    config.label = 'Developer Name';
                } else if (metaElement.hasAttribute('title')) {
                    config.name = 'title';
                    config.default = metaElement.getAttribute('title');
                    config.type = 'text';
                    config.label = 'Effect Title';
                } else {
                    // Fallback to the standard property-based format
                    for (const attr of metaElement.attributes) {
                        config[attr.name] = attr.value;
                    }
                }
                return config;
            }

            function groupConfigs(flatConfig) {
                const grouped = { general: [], objects: {} };
                flatConfig.forEach(config => {
                    const key = config.property || config.name;
                    // [FIX] Added a check to prevent error on undefined key
                    if (key && key.startsWith('obj')) {
                        const match = key.match(/^obj(\d+)_/);
                        if (match) {
                            const id = match[1];
                            if (!grouped.objects[id]) grouped.objects[id] = [];
                            grouped.objects[id].push(config);
                        }
                    } else {
                        grouped.general.push(config);
                    }
                });
                return grouped;
            }

            function createFormControl(config) {
                const { property, name, label, type, default: defaultValue, values, min, max } = config;
                const controlId = property || name;
                const formGroup = document.createElement('div');
                formGroup.className = 'mb-3';
                const labelEl = document.createElement('label');
                labelEl.htmlFor = controlId;
                labelEl.className = 'form-label';

                if (label) {
                    labelEl.textContent = label.includes(':') ? label.substring(label.indexOf(':') + 1).trim() : label;
                    labelEl.title = `Controls the ${label.toLowerCase()}`;
                }
                labelEl.dataset.bsToggle = 'tooltip';
                formGroup.appendChild(labelEl);

                if (type === 'number') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'd-flex align-items-center';
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control';
                    input.style.width = '100px';
                    input.name = controlId;
                    input.type = 'number';
                    input.value = defaultValue;
                    if (min) input.min = min;
                    if (max) input.max = max;
                    input.step = '1';
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.className = 'form-range flex-grow-1 ms-2';
                    slider.id = `${controlId}_slider`;
                    slider.name = `${controlId}_slider`;
                    if (min) slider.min = min;
                    if (max) slider.max = max;
                    slider.value = defaultValue;
                    inputGroup.appendChild(input);
                    inputGroup.appendChild(slider);
                    formGroup.appendChild(inputGroup);
                } else if (type === 'text') {
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control';
                    input.name = controlId;
                    input.type = 'text';
                    input.value = defaultValue;
                    formGroup.appendChild(input);
                } else if (type === 'combobox') {
                    const vals = values.split(',');
                    const select = document.createElement('select');
                    select.id = controlId;
                    select.className = 'form-select';
                    select.name = controlId;
                    vals.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val.charAt(0).toUpperCase() + val.slice(1);
                        if (val === defaultValue) option.selected = true;
                        select.appendChild(option);
                    });
                    formGroup.appendChild(select);
                } else if (type === 'boolean') {
                    const checkGroup = document.createElement('div');
                    checkGroup.className = 'form-check form-switch';
                    const check = document.createElement('input');
                    check.id = controlId;
                    check.type = 'checkbox';
                    check.className = 'form-check-input';
                    check.name = controlId;
                    check.checked = (defaultValue === 'true');
                    const checkLabel = document.createElement('label');
                    checkLabel.className = 'form-check-label';
                    checkLabel.htmlFor = controlId;
                    if (label) {
                        checkLabel.textContent = label.includes(':') ? label.substring(label.indexOf(':') + 1).trim() : label;
                    }
                    checkGroup.appendChild(check);
                    checkGroup.appendChild(checkLabel);
                    formGroup.appendChild(checkGroup);
                } else if (type === 'color') {
                    const colorGroup = document.createElement('div');
                    colorGroup.className = 'd-flex align-items-center';
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control form-control-color';
                    input.name = controlId;
                    input.type = 'color';
                    input.value = defaultValue;
                    const hexInput = document.createElement('input');
                    hexInput.type = 'text';
                    hexInput.className = 'form-control ms-2';
                    hexInput.style.width = '100px';
                    hexInput.value = defaultValue;
                    hexInput.id = `${controlId}_hex`;
                    hexInput.name = `${controlId}_hex`;
                    colorGroup.appendChild(input);
                    colorGroup.appendChild(hexInput);
                    formGroup.appendChild(colorGroup);
                }
                return formGroup;
            }

            function renderForm() {
                const existingTooltips = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                existingTooltips.forEach(el => {
                    const tooltip = bootstrap.Tooltip.getInstance(el);
                    if (tooltip) tooltip.dispose();
                });

                const collapseStates = {};
                const generalCollapseEl = form.querySelector('#collapse-general');
                collapseStates.general = generalCollapseEl ? generalCollapseEl.classList.contains('show') : true;

                const allObjectCollapses = form.querySelectorAll('.collapse[id^="collapse-obj-"]');
                allObjectCollapses.forEach(el => {
                    const fieldset = el.closest('fieldset');
                    if (fieldset) {
                        const id = parseInt(fieldset.dataset.objectId, 10);
                        collapseStates[id] = el.classList.contains('show');
                    }
                });

                form.innerHTML = '';

                const grouped = groupConfigs(configStore);

                // --- General Settings Panel ---
                const generalFieldset = document.createElement('fieldset');
                generalFieldset.className = 'border p-2 mb-3 rounded bg-body-secondary';
                const generalHeaderBar = document.createElement('div');
                generalHeaderBar.className = 'd-flex justify-content-between align-items-center w-100 px-2';
                const generalHeaderText = document.createElement('span');
                generalHeaderText.className = 'fs-5 fw-semibold';
                generalHeaderText.textContent = 'General Settings';
                generalHeaderBar.appendChild(generalHeaderText);
                const generalCollapseId = 'collapse-general';
                const generalCollapseButton = document.createElement('button');
                const showGeneral = collapseStates.general;
                generalCollapseButton.className = `btn btn-sm btn-outline-secondary ms-2 legend-button ${showGeneral ? '' : 'collapsed'} d-flex align-items-center justify-content-center p-0`;
                generalCollapseButton.style.width = '28px';
                generalCollapseButton.style.height = '28px';
                generalCollapseButton.type = 'button';
                generalCollapseButton.dataset.bsToggle = 'collapse';
                generalCollapseButton.dataset.bsTarget = `#${generalCollapseId}`;
                generalCollapseButton.setAttribute('aria-expanded', showGeneral);
                generalHeaderBar.appendChild(generalCollapseButton);
                const generalCollapseWrapper = document.createElement('div');
                generalCollapseWrapper.id = generalCollapseId;
                generalCollapseWrapper.className = `collapse p-3 ${showGeneral ? 'show' : ''}`;
                const generalSeparator = document.createElement('hr');
                generalSeparator.className = 'mt-2 mb-3';
                generalCollapseWrapper.appendChild(generalSeparator);
                grouped.general.forEach(conf => generalCollapseWrapper.appendChild(createFormControl(conf)));
                generalFieldset.appendChild(generalHeaderBar);
                generalFieldset.appendChild(generalCollapseWrapper);
                form.appendChild(generalFieldset);


                // --- Object Panels ---
                objects.forEach(obj => {
                    const id = obj.id;
                    const objectConfigs = grouped.objects[id];
                    if (!objectConfigs) return;

                    const objectName = obj.name || `Object ${id}`;
                    const fieldset = document.createElement('fieldset');
                    fieldset.className = 'border p-2 mb-3 rounded bg-body-secondary';
                    fieldset.dataset.objectId = id;

                    const headerBar = document.createElement('div');
                    headerBar.className = 'd-flex align-items-center w-100 px-2';
                    const dragHandle = document.createElement('div');
                    dragHandle.className = 'drag-handle me-2 text-body-secondary';
                    dragHandle.style.cursor = 'grab';
                    dragHandle.innerHTML = '<i class="bi bi-grip-vertical"></i>';
                    headerBar.appendChild(dragHandle);
                    const editableArea = document.createElement('div');
                    editableArea.className = 'editable-name-area d-flex align-items-center';
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'object-name fs-5 fw-semibold';
                    nameSpan.style.minWidth = '0';
                    nameSpan.contentEditable = true;
                    nameSpan.dataset.id = id;
                    nameSpan.textContent = objectName;
                    editableArea.appendChild(nameSpan);
                    const pencilIcon = document.createElement('i');
                    pencilIcon.className = 'bi bi-pencil-fill ms-2';
                    pencilIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        nameSpan.focus();
                        const range = document.createRange();
                        const selection = window.getSelection();
                        range.selectNodeContents(nameSpan);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    });
                    editableArea.appendChild(pencilIcon);
                    headerBar.appendChild(editableArea);
                    const controlsGroup = document.createElement('div');
                    controlsGroup.className = 'd-flex align-items-center flex-shrink-0 ms-auto';
                    const lockButton = document.createElement('button');
                    const isLocked = obj.locked || false;
                    lockButton.className = `btn btn-sm btn-lock ${isLocked ? 'btn-warning' : 'btn-outline-secondary'} d-flex align-items-center justify-content-center p-0 ms-2`;
                    lockButton.style.width = '28px';
                    lockButton.style.height = '28px';
                    lockButton.type = 'button';
                    lockButton.dataset.id = id;
                    lockButton.dataset.bsToggle = 'tooltip';
                    lockButton.title = isLocked ? 'Unlock Object' : 'Lock Object';
                    lockButton.innerHTML = `<i class="bi ${isLocked ? 'bi-lock-fill' : 'bi-unlock-fill'}"></i>`;
                    controlsGroup.appendChild(lockButton);
                    const dropdown = document.createElement('div');
                    dropdown.className = 'dropdown';
                    dropdown.innerHTML = `<button class="btn btn-sm btn-outline-secondary d-flex align-items-center justify-content-center p-0" style="width: 28px; height: 28px;" type="button" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-list fs-5"></i></button><ul class="dropdown-menu dropdown-menu-dark"><li><a class="dropdown-item btn-duplicate" href="#" data-id="${id}"><i class="bi bi-copy me-2"></i>Duplicate</a></li><li><a class="dropdown-item btn-delete text-danger" href="#" data-id="${id}"><i class="bi bi-trash me-2"></i>Delete</a></li></ul>`;
                    controlsGroup.appendChild(dropdown);
                    const collapseId = `collapse-obj-${id}`;
                    const collapseButton = document.createElement('button');
                    const showObject = collapseStates[id] !== false;
                    collapseButton.className = `btn btn-sm btn-outline-secondary ms-2 legend-button ${showObject ? '' : 'collapsed'} d-flex align-items-center justify-content-center p-0`;
                    collapseButton.style.width = '28px';
                    collapseButton.style.height = '28px';
                    collapseButton.type = 'button';
                    collapseButton.dataset.bsToggle = 'collapse';
                    collapseButton.dataset.bsTarget = `#${collapseId}`;
                    collapseButton.setAttribute('aria-expanded', showObject);
                    controlsGroup.appendChild(collapseButton);
                    headerBar.appendChild(controlsGroup);

                    const collapseWrapper = document.createElement('div');
                    collapseWrapper.id = collapseId;
                    collapseWrapper.className = `collapse p-3 ${showObject ? 'show' : ''}`;
                    const separator = document.createElement('hr');
                    separator.className = 'mt-2 mb-3';
                    collapseWrapper.appendChild(separator);

                    const groups = {
                        'Transform & Shape': ['shape', 'x', 'y', 'width', 'height', 'rotationSpeed'],
                        'Fill Style': ['gradType', 'useSharpGradient', 'gradientStop', 'gradColor1', 'gradColor2'],
                        'Animation': ['animationMode', 'animationSpeed', 'scrollDir', 'cycleColors', 'cycleSpeed']
                    };

                    const shapeConf = objectConfigs.find(c => c.property.endsWith('_shape'));
                    const currentShape = shapeConf ? shapeConf.default : 'rectangle';

                    for (const groupName in groups) {
                        const groupContainer = document.createElement('div');
                        groupContainer.className = 'control-group mb-4';
                        const groupHeader = document.createElement('h6');
                        groupHeader.className = 'text-body-secondary border-bottom pb-1 mb-3';
                        groupHeader.textContent = groupName;
                        groupContainer.appendChild(groupHeader);
                        const propsInGroup = groups[groupName];
                        objectConfigs
                            .filter(conf => {
                                if (!conf.property) return false;
                                const propName = conf.property.substring(conf.property.indexOf('_') + 1);
                                return propsInGroup.includes(propName);
                            })
                            .forEach(conf => groupContainer.appendChild(createFormControl(conf)));
                        if (groupContainer.children.length > 1) {
                            collapseWrapper.appendChild(groupContainer);
                        }
                    }

                    const ringSettings = ['innerDiameter', 'numberOfSegments', 'angularWidth'];
                    const gridSettings = ['numberOfRows', 'numberOfColumns', 'phaseOffset'];

                    const ringGroup = document.createElement('div');
                    ringGroup.className = 'control-group mb-4 ring-settings-group';
                    ringGroup.style.display = currentShape === 'ring' ? 'block' : 'none';
                    const ringHeader = document.createElement('h6');
                    ringHeader.className = 'text-body-secondary border-bottom pb-1 mb-3';
                    ringHeader.textContent = 'Ring Settings';
                    ringGroup.appendChild(ringHeader);
                    objectConfigs.filter(c => ringSettings.includes(c.property.substring(c.property.indexOf('_') + 1))).forEach(c => ringGroup.appendChild(createFormControl(c)));
                    collapseWrapper.appendChild(ringGroup);

                    const gridGroup = document.createElement('div');
                    gridGroup.className = 'control-group mb-4 grid-settings-group';
                    gridGroup.style.display = currentShape === 'rectangle' ? 'block' : 'none';
                    const gridHeader = document.createElement('h6');
                    gridHeader.className = 'text-body-secondary border-bottom pb-1 mb-3';
                    gridHeader.textContent = 'Grid Settings';
                    gridGroup.appendChild(gridHeader);
                    objectConfigs.filter(c => gridSettings.includes(c.property.substring(c.property.indexOf('_') + 1))).forEach(c => gridGroup.appendChild(createFormControl(c)));
                    collapseWrapper.appendChild(gridGroup);


                    fieldset.appendChild(headerBar);
                    fieldset.appendChild(collapseWrapper);
                    form.appendChild(fieldset);
                });

                setFormValues(getControlValues());
                new bootstrap.Tooltip(document.body, { selector: "[data-bs-toggle='tooltip']", trigger: 'hover' });

                const sortable = Sortable.get(form);
                if (sortable) {
                    sortable.option('store', {
                        get: function () {
                            return objects.map(obj => obj.id.toString());
                        },
                        set: function (sortable) { }
                    });
                }
            }

            /**
             * Re-numbers all object IDs and their corresponding properties in the configStore
             * based on the current order of the `objects` array. This ensures data consistency
             * after deleting or reordering objects.
             */
            function syncAndRenumberState() {
                const oldObjects = [...objects];
                const oldConfigs = [...configStore];

                const generalConfigs = oldConfigs.filter(c => !(c.property || c.name).startsWith('obj'));

                let newConfigStore = [...generalConfigs];
                let newObjects = [];

                // Iterate through the objects in their CURRENT visual order
                oldObjects.forEach((obj, index) => {
                    const newId = index + 1;
                    const oldId = obj.id;

                    // Find the configs associated with the old ID from the original config store
                    const configsToUpdate = oldConfigs.filter(c => c.property && c.property.startsWith(`obj${oldId}_`));

                    // Update the object's ID itself
                    obj.id = newId;

                    // Update its name if it follows the default "Object X" pattern
                    if (obj.name.startsWith('Object ')) {
                        obj.name = `Object ${newId}`;
                    }
                    newObjects.push(obj);

                    // Renumber the properties and labels in its configs
                    const renumberedConfigs = configsToUpdate.map(conf => {
                        const newConf = { ...conf };
                        newConf.property = conf.property.replace(`obj${oldId}_`, `obj${newId}_`);

                        const labelParts = conf.label.split(':');
                        if (labelParts.length > 1) {
                            // Use the object's current name, which might have been user-edited
                            newConf.label = `${obj.name}:${labelParts.slice(1).join(':')}`;
                        }
                        return newConf;
                    });

                    newConfigStore.push(...renumberedConfigs);
                });

                // Commit the changes to the global state
                objects = newObjects;
                configStore = newConfigStore;

                // Re-render everything with the new, consistent state
                renderForm();
                updateAll();
                drawFrame();
            }

            /**
             * Initializes the Sortable.js library on the controls form to allow
             * drag-and-drop reordering of object panels.
             */
            function initializeSortable() {
                const formEl = document.getElementById('controls-form');
                new Sortable(formEl, {
                    animation: 150,
                    handle: '.drag-handle',
                    draggable: 'fieldset[data-object-id]',
                    onEnd: function (evt) {
                        if (evt.oldIndex === evt.newIndex) return;

                        // Get the new order of object IDs from the DOM
                        const fieldsets = Array.from(formEl.querySelectorAll('fieldset[data-object-id]'));
                        const newOrderedIds = fieldsets.map(fieldset => parseInt(fieldset.dataset.objectId, 10));

                        // Reorder the main `objects` array to match the new visual order
                        const reorderedObjects = newOrderedIds.map(id => objects.find(o => o.id === id)).filter(Boolean);
                        objects = reorderedObjects;

                        // Now, call the function to re-number all IDs and properties based on this new order
                        syncAndRenumberState();
                    }
                });
            }


            function getControlValues() {
                const formData = new FormData(form);
                const data = {};
                configStore.forEach(conf => {
                    const key = conf.property || conf.name;
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            data[key] = el.checked;
                        } else if (el.type === 'number') {
                            data[key] = parseFloat(formData.get(key) || el.value);
                        } else {
                            data[key] = formData.get(key) || el.value;
                        }
                    }
                });
                return data;
            }

            function setFormValues(data) {
                for (const key in data) {
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = data[key];
                        } else {
                            el.value = data[key];
                        }
                    }
                }
                updateAll();
            }

            function buildStatesFromConfig() {
                const values = getControlValues();
                const grouped = groupConfigs(configStore);
                const finalStates = [];

                objects.forEach(obj => {
                    const id = obj.id;
                    if (!grouped.objects[id]) return;

                    const existingObject = obj;
                    const config = {
                        id: parseInt(id),
                        gradient: {},
                        name: existingObject.name,
                        locked: existingObject.locked
                    };

                    grouped.objects[id].forEach(conf => {
                        let key = conf.property.replace(`obj${id}_`, '');
                        let value = values[conf.property];
                        const type = conf.type;
                        if (type === 'number') value = parseFloat(value);
                        else if (type === 'boolean') value = (value === true || value === 'true');

                        if (key.startsWith('gradColor')) {
                            config.gradient[key.replace('grad', '').toLowerCase()] = value;
                        } else if (key === 'scrollDir') {
                            config.scrollDirection = value;
                        } else {
                            config[key] = value;
                        }
                    });

                    config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    config.cycleSpeed = (config.cycleSpeed || 0) / 50.0;
                    const speed = config.animationSpeed || 0;
                    config.animationSpeed = speed / 10.0;
                    if (config.shape === 'ring') {
                        config.height = config.width;
                    }
                    finalStates.push(config);
                });

                return finalStates;
            }

            // [FIX] This function now correctly generates both meta tag formats.
            function generateOutputScript() {
                const values = getControlValues();
                let scriptHTML = '';
                configStore.forEach(config => {
                    const propOrName = config.property || config.name;
                    if (!propOrName) return;

                    const value = values[propOrName];
                    let line = '';

                    // Check if it's a general setting like 'title', 'description', or 'publisher'
                    if (config.name && !config.property) {
                        // Use the new format: <meta name="value"/>
                        line = `<meta ${config.name}="${value}" />\n`;
                    } else {
                        // It's an object property, use the old format with all attributes
                        const attrs = Object.keys(config)
                            .filter(attr => attr !== 'default')
                            .map(attrName => `${attrName}="${config[attrName]}"`)
                            .join(' ');
                        line = `<meta ${attrs} default="${value}" />\n`;
                    }
                    scriptHTML += line;
                });
                outputScriptArea.value = scriptHTML.trim();
            }

            form.addEventListener('blur', (e) => {
                if (e.target.classList.contains('object-name')) {
                    const id = parseInt(e.target.dataset.id, 10);
                    const newName = e.target.textContent || 'Unnamed';
                    const obj = objects.find(o => o.id === id);
                    if (obj) {
                        obj.name = newName;
                        configStore.forEach(conf => {
                            if (conf.property && conf.property.startsWith(`obj${id}_`)) {
                                const labelParts = conf.label.split(':');
                                conf.label = `${newName}:${labelParts[1]}`;
                            }
                        });
                        generateOutputScript();
                    }
                }
            }, true);

            function getCanvasCoordinates(event) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                return { x, y };
            }

            function updateToolbarState() {
                const multiSelectButtons = toolbar.querySelectorAll('[data-action^="match-"]');
                const singleSelectButtons = toolbar.querySelectorAll('[data-action^="align-screen-"], [data-action="fit-canvas"]');
                singleSelectButtons.forEach(btn => btn.disabled = selectedObjectIds.length === 0);
                multiSelectButtons.forEach(btn => btn.disabled = selectedObjectIds.length < 2);
            }

            function updateFormFromShapes() {
                objects.forEach(obj => {
                    const prefix = `obj${obj.id}_`;
                    const fields = ['x', 'y', 'width', 'height'];
                    fields.forEach(field => {
                        const input = form.elements[`${prefix}${field}`];
                        if (input) {
                            input.value = Math.round(obj[field]);
                            const slider = form.elements[`${prefix}${field}_slider`];
                            if (slider) { slider.value = Math.round(obj[field]); }
                        }
                    });
                });
                generateOutputScript();
            }

            function drawFrame() {
                const values = getControlValues();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const enableAnimation = values['enableAnimation'] === true;
                objects.forEach(obj => {
                    const isSelected = selectedObjectIds.includes(obj.id);
                    obj.draw(enableAnimation, isSelected);
                });
            }

            function animate() {
                const values = getControlValues();
                if (values.enableAnimation || isDragging || isResizing) {
                    drawFrame();
                }
                requestAnimationFrame(animate);
            }

            function updateShapesFromForm() {
                const newStates = buildStatesFromConfig();
                const newObjects = [];
                newStates.forEach(state => {
                    const existingObj = objects.find(o => o.id === state.id);
                    if (existingObj) {
                        existingObj.update(state);
                        newObjects.push(existingObj);
                    } else {
                        newObjects.push(new Shape({ ...state, ctx }));
                    }
                });
                objects = newObjects;
            }

            function updateAll() {
                updateShapesFromForm();
                generateOutputScript();
            }

            function syncPanelsWithSelection() {
                const allCollapses = form.querySelectorAll('.collapse');
                allCollapses.forEach(el => {
                    const instance = bootstrap.Collapse.getInstance(el) || new bootstrap.Collapse(el, { toggle: false });
                    const fieldset = el.closest('fieldset');
                    if (!fieldset) return;
                    const id = parseInt(fieldset.dataset.objectId, 10);
                    if (selectedObjectIds.length === 1 && selectedObjectIds[0] === id) {
                        instance.show();
                    } else {
                        instance.hide();
                    }
                });
            }

            function createInitialObjects() {
                const grouped = groupConfigs(configStore);
                const initialStates = [];
                Object.keys(grouped.objects).forEach(id => {
                    const config = { id: parseInt(id), gradient: {} };
                    const representativeConfig = grouped.objects[id][0];
                    if (representativeConfig && representativeConfig.label.includes(':')) {
                        config.name = representativeConfig.label.split(':')[0];
                    }

                    grouped.objects[id].forEach(conf => {
                        const key = conf.property.replace(`obj${id}_`, '');
                        let value = conf.default;
                        const type = conf.type;
                        if (type === 'number') value = parseFloat(value);
                        else if (type === 'boolean') value = (value === 'true');
                        if (key.startsWith('gradColor')) {
                            config.gradient[key.replace('grad', '').toLowerCase()] = value;
                        } else if (key === 'scrollDir') {
                            config.scrollDirection = value;
                        } else {
                            config[key] = value;
                        }
                    });
                    config.gradType = config.gradType || 'solid';
                    config.gradient = config.gradient.color1 ? config.gradient : { color1: '#000000', color2: '#000000' };
                    config.useSharpGradient = config.useSharpGradient !== undefined ? config.useSharpGradient : false;
                    config.gradientStop = config.gradientStop !== undefined ? parseFloat(config.gradientStop) : 50;
                    config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    config.cycleSpeed = (config.cycleSpeed || 0) / 50.0;
                    const speed = config.animationSpeed || 0;
                    config.animationSpeed = speed / 10.0;
                    if (config.shape === 'ring') {
                        config.height = config.width;
                    }
                    initialStates.push(config);
                });
                objects = initialStates.map(state => new Shape({ ...state, ctx }));
            }

            function loadWorkspace(workspace) {
                configStore = workspace.configs;
                createInitialObjects();

                if (workspace.objects) {
                    workspace.objects.forEach(savedObj => {
                        const obj = objects.find(o => o.id === savedObj.id);
                        if (obj) {
                            obj.name = savedObj.name;
                            obj.locked = savedObj.locked || false;
                        }
                    });
                }
                renderForm();

                for (const config of configStore) {
                    const key = config.property || config.name;
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = (config.default === true || config.default === 'true');
                        } else {
                            el.value = config.default;
                        }
                        if (el.type === 'number') {
                            const slider = document.getElementById(`${el.id}_slider`);
                            if (slider) slider.value = el.value;
                        }
                        if (el.type === 'color') {
                            const hexInput = document.getElementById(`${el.id}_hex`);
                            if (hexInput) hexInput.value = el.value;
                        }
                    }
                }
                updateAll();
                drawFrame();
            }

            function getOppositeHandle(handleName) {
                let opposite = handleName;
                if (handleName.includes('top')) {
                    opposite = opposite.replace('top', 'bottom');
                } else if (handleName.includes('bottom')) {
                    opposite = opposite.replace('bottom', 'top');
                }
                if (handleName.includes('left')) {
                    opposite = opposite.replace('left', 'right');
                } else if (handleName.includes('right')) {
                    opposite = opposite.replace('right', 'left');
                }
                return opposite;
            }

            function getDefaultObjectConfig(newId) {
                return [
                    { property: `obj${newId}_shape`, label: `Object ${newId}: Shape`, type: 'combobox', default: 'rectangle', values: 'rectangle,circle,ring' },
                    { property: `obj${newId}_x`, label: `Object ${newId}: X Position`, type: 'number', default: '10', min: '0', max: '1280' },
                    { property: `obj${newId}_y`, label: `Object ${newId}: Y Position`, type: 'number', default: '10', min: '0', max: '800' },
                    { property: `obj${newId}_width`, label: `Object ${newId}: Width/Outer Diameter`, type: 'number', default: '200', min: '10', max: '1280' },
                    { property: `obj${newId}_height`, label: `Object ${newId}: Height`, type: 'number', default: '150', min: '10', max: '800' },
                    { property: `obj${newId}_innerDiameter`, label: `Object ${newId}: Inner Diameter`, type: 'number', default: '100', min: '5', max: '1270' },
                    { property: `obj${newId}_numberOfSegments`, label: `Object ${newId}: Segments`, type: 'number', default: '12', min: '1', max: '50' },
                    { property: `obj${newId}_angularWidth`, label: `Object ${newId}: Segment Angle`, type: 'number', default: '20', min: '1', max: '90' },
                    { property: `obj${newId}_rotationSpeed`, label: `Object ${newId}: Rotation Speed`, type: 'number', default: '0', min: '-100', max: '100' },
                    { property: `obj${newId}_animationSpeed`, label: `Object ${newId}: Animation Speed`, type: 'number', default: '2', min: '1', max: '50' },
                    { property: `obj${newId}_animationMode`, label: `Object ${newId}: Animation Mode`, type: 'combobox', values: 'loop,bounce,bounce-reversed,bounce-random', default: 'loop' },
                    { property: `obj${newId}_scrollDir`, label: `Object ${newId}: Scroll Direction`, type: 'combobox', default: 'right', values: 'right,left,up,down' },
                    { property: `obj${newId}_gradType`, label: `Object ${newId}: Fill Type`, type: 'combobox', default: 'linear', values: 'solid,linear,radial,alternating,random' },
                    { property: `obj${newId}_useSharpGradient`, label: `Object ${newId}: Use Sharp Gradient`, type: 'boolean', default: 'false' },
                    { property: `obj${newId}_gradientStop`, label: `Object ${newId}: Gradient Stop %`, type: 'number', default: '50', min: '0', max: '100' },
                    { property: `obj${newId}_gradColor1`, label: `Object ${newId}: Color 1`, type: 'color', default: '#cccccc' },
                    { property: `obj${newId}_gradColor2`, label: `Object ${newId}: Color 2`, type: 'color', default: '#888888' },
                    { property: `obj${newId}_cycleColors`, label: `Object ${newId}: Cycle Colors`, type: 'boolean', default: 'false' },
                    { property: `obj${newId}_cycleSpeed`, label: `Object ${newId}: Color Cycle Speed`, type: 'number', default: '1', min: '1', max: '10' },
                    { property: `obj${newId}_numberOfRows`, label: `Object ${newId}: Number of Rows`, type: 'number', default: '1', min: '1', max: '100' },
                    { property: `obj${newId}_numberOfColumns`, label: `Object ${newId}: Number of Columns`, type: 'number', default: '1', min: '1', max: '100' },
                    { property: `obj${newId}_phaseOffset`, label: `Object ${newId}: Phase Offset`, type: 'number', default: '10', min: '0', max: '100' }
                ];
            }

            async function exportFile() {
                const exportButton = document.getElementById('export-btn');
                exportButton.disabled = true;
                exportButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exporting...';

                try {
                    // 1. Get the dynamic parts from the builder's current state.
                    const effectTitle = getControlValues()['title'] || 'MyEffect';
                    const safeFilename = effectTitle.replace(/[\s\/\\?%*:|"<>]/g, '_'); // Sanitize filename
                    const metaTags = document.getElementById('output-script').value;
                    const imageUrl = 'https://joseamirandavelez.github.io/EffectBuilder/srgbieb_crop.png';
                    const imageExtension = imageUrl.split('.').pop() || 'png';


                    // 2. Fetch the image data as a blob
                    const imageResponse = await fetch(imageUrl);
                    if (!imageResponse.ok) {
                        throw new Error(`Failed to fetch image: ${imageResponse.statusText}`);
                    }
                    const imageBlob = await imageResponse.blob();

                    // 3. Define the static HTML and CSS parts.
                    const styleContent =
                        '    canvas {\n' +
                        '      width: 100%;\n' +
                        '      height: 100%;\n' +
                        '      position: absolute;\n' +
                        '      top: 50%;\n' +
                        '      left: 50%;\n' +
                        '      transform: translate(-50%, -50%);\n' +
                        '      background-color: #222222;\n' +
                        '    }\n' +
                        '    body {\n' +
                        '      background-color: #111111;\n' +
                        '      overflow: hidden;\n' +
                        '      margin: 0;\n' +
                        '    }\n';

                    const bodyContent =
                        '<body>\n' +
                        '  <canvas id="signalCanvas"></canvas>\n' +
                        '</body>';

                    // 4. Get the source code of the required functions and class using .toString().
                    const lerpColorString = lerpColor.toString();
                    const getPatternColorString = getPatternColor.toString();
                    const shapeClassString = Shape.toString();

                    // 5. Construct the self-contained initialization script.
                    const exportedScript =
                        'document.addEventListener(\'DOMContentLoaded\', function () {\n' +
                        '  const canvas = document.getElementById(\'signalCanvas\');\n' +
                        '  const ctx = canvas.getContext(\'2d\');\n' +
                        '  canvas.width = 1280;\n' +
                        '  canvas.height = 800;\n\n' +
                        '  let objects = [];\n\n' +
                        '  // --- Injected Functions & Class Definitions from Builder ---\n' +
                        '  ' + lerpColorString + '\n\n' +
                        '  ' + getPatternColorString + '\n\n' +
                        '  ' + shapeClassString + '\n\n' +
                        '  // --- Standalone Initialization & Animation Loop ---\n' +
                        // BUG FIX: Rewrote createInitialObjects to be more robust.
                        '  function createInitialObjects() {\n' +
                        '    const objectIds = [];\n' +
                        '    for (const key in window) {\n' +
                        '      if (Object.prototype.hasOwnProperty.call(window, key) && key.startsWith(\'obj\') && key.endsWith(\'_shape\')) {\n' +
                        '        const match = key.match(/^obj(\\\d+)_/);\n' +
                        '        if (match && match[1]) {\n' +
                        '          const id = match[1];\n' +
                        '          if (!objectIds.includes(id)) {\n' +
                        '            objectIds.push(id);\n' +
                        '          }\n' +
                        '        }\n' +
                        '      }\n' +
                        '    }\n' +
                        '    objectIds.sort((a, b) => a - b);\n' +
                        '    objects = objectIds.map(id => new Shape({ id: parseInt(id), ctx: ctx }));\n' +
                        '  }\n\n' +
                        '  function drawFrame() {\n' +
                        '    ctx.clearRect(0, 0, canvas.width, canvas.height);\n' +
                        '    const shouldAnimate = window.enableAnimation;\n\n' +
                        '    objects.forEach(obj => {\n' +
                        '      const id = obj.id;\n' +
                        '      obj.update({\n' +
                        '        shape: window[\'obj\' + id + \'_shape\'],\n' +
                        '        x: window[\'obj\' + id + \'_x\'],\n' +
                        '        y: window[\'obj\' + id + \'_y\'],\n' +
                        '        width: window[\'obj\' + id + \'_width\'],\n' +
                        '        height: window[\'obj\' + id + \'_height\'],\n' +
                        '        innerDiameter: window[\'obj\' + id + \'_innerDiameter\'],\n' +
                        '        numberOfSegments: window[\'obj\' + id + \'_numberOfSegments\'],\n' +
                        '        angularWidth: window[\'obj\' + id + \'_angularWidth\'],\n' +
                        '        rotationSpeed: window[\'obj\' + id + \'_rotationSpeed\'],\n' +
                        '        animationSpeed: (window[\'obj\' + id + \'_animationSpeed\'] || 0) / 10.0,\n' +
                        '        animationMode: window[\'obj\' + id + \'_animationMode\'],\n' +
                        '        scrollDirection: window[\'obj\' + id + \'_scrollDir\'],\n' +
                        '        gradType: window[\'obj\' + id + \'_gradType\'],\n' +
                        '        useSharpGradient: window[\'obj\' + id + \'_useSharpGradient\'],\n' +
                        '        gradientStop: parseFloat(window[\'obj\' + id + \'_gradientStop\']),\n' +
                        '        gradient: {\n' +
                        '          color1: window[\'obj\' + id + \'_gradColor1\'],\n' +
                        '          color2: window[\'obj\' + id + \'_gradColor2\']\n' +
                        '        },\n' +
                        '        cycleColors: window[\'obj\' + id + \'_cycleColors\'],\n' +
                        '        cycleSpeed: (window[\'obj\' + id + \'_cycleSpeed\'] || 0) / 50.0,\n' +
                        '        numberOfRows: window[\'obj\' + id + \'_numberOfRows\'],\n' +
                        '        numberOfColumns: window[\'obj\' + id + \'_numberOfColumns\'],\n' +
                        '        phaseOffset: window[\'obj\' + id + \'_phaseOffset\'],\n' +
                        '      });\n\n' +
                        '      obj.draw(shouldAnimate);\n' +
                        '    });\n' +
                        '  }\n\n' +
                        '  function animate() {\n' +
                        '    drawFrame();\n' +
                        '    requestAnimationFrame(animate);\n' +
                        '  }\n\n' +
                        '  function init() {\n' +
                        '    if (typeof window.areGlobalsSetup === \'undefined\') {\n' +
                        '      const metaElements = Array.from(document.querySelectorAll(\'head > meta\'));\n' +
                        '      metaElements.forEach(meta => {\n' +
                        '        const key = meta.getAttribute(\'property\') || meta.getAttribute(\'name\') || Object.keys(meta.attributes).find(attr => ![\'label\', \'type\', \'default\', \'values\', \'min\', \'max\'].includes(attr.name));\n' +
                        '        if (key) {\n' +
                        '          let value = meta.getAttribute(\'default\') || meta.getAttribute(key);\n' +
                        '          const type = meta.getAttribute(\'type\');\n' +
                        '          if (type === \'number\') { window[key] = parseFloat(value); }\n' +
                        '          else if (type === \'boolean\') { window[key] = (value === \'true\'); }\n' +
                        '          else { window[key] = value; }\n' +
                        '        }\n' +
                        '      });\n' +
                        '      window.areGlobalsSetup = true;\n' +
                        '    }\n' +
                        '    createInitialObjects();\n' +
                        '    animate();\n' +
                        '  }\n\n' +
                        '  init();\n' +
                        '});';

                    // 6. Assemble the final HTML file content.
                    const finalHtml = '<!DOCTYPE html>\n' +
                        '<html lang="en">\n' +
                        '<head>\n' +
                        '  <meta charset="UTF-8">\n' +
                        '  <title>' + effectTitle + '</title>\n' +
                        metaTags + '\n' +
                        '  <style>\n' +
                        '  ' + styleContent.trim() + '\n' +
                        '  </style>\n' +
                        '</head>\n' +
                        bodyContent.trim() + '\n' +
                        '<script>\n' +
                        '  ' + exportedScript.trim() + '\n' +
                        '<' + '/script>\n' + // Break up closing tag to prevent parsing error
                        '</html>';

                    // 7. Create a ZIP file with JSZip
                    const zip = new JSZip();
                    zip.file(`${safeFilename}.html`, finalHtml);
                    zip.file(`${safeFilename}.${imageExtension}`, imageBlob);

                    // 8. Generate and download the ZIP file.
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(zipBlob);
                    link.download = `${safeFilename}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                } catch (error) {
                    console.error('Export failed:', error);
                    if (typeof showNotification === 'function') {
                        showNotification('Export failed: ' + error.message);
                    } else {
                        alert('Export failed: ' + error.message);
                    }
                } finally {
                    exportButton.disabled = false;
                    exportButton.innerHTML = '<i class="bi bi-download"></i> Export';
                }
            }


            form.addEventListener('input', (e) => {
                const target = e.target;
                if (target.type === 'number' && document.getElementById(`${target.id}_slider`)) {
                    document.getElementById(`${target.id}_slider`).value = target.value;
                } else if (target.type === 'range' && target.id.endsWith('_slider')) {
                    const numberInputId = target.id.replace('_slider', '');
                    document.getElementById(numberInputId).value = target.value;
                }

                if (target.type === 'color' && document.getElementById(`${target.id}_hex`)) {
                    document.getElementById(`${target.id}_hex`).value = target.value;
                }
                if (target.type === 'text' && target.id.endsWith('_hex')) {
                    const colorPickerId = target.id.replace('_hex', '');
                    const colorPicker = document.getElementById(colorPickerId);
                    if (colorPicker && /^#[0-9A-F]{6}$/i.test(target.value)) {
                        colorPicker.value = target.value;
                    }
                }

                if (target.name && target.name.includes('_shape')) {
                    const objectId = target.name.match(/obj(\d+)_/)[1];
                    const shapeValue = target.value;
                    const fieldset = form.querySelector(`fieldset[data-object-id="${objectId}"]`);
                    if (fieldset) {
                        const ringControls = fieldset.querySelector('.ring-settings-group');
                        const gridControls = fieldset.querySelector('.grid-settings-group');
                        const heightControl = fieldset.querySelector(`[id*="obj${objectId}_height"]`).closest('.mb-3');

                        if (ringControls) ringControls.style.display = shapeValue === 'ring' ? 'block' : 'none';
                        if (gridControls) gridControls.style.display = shapeValue === 'rectangle' ? 'block' : 'none';
                        if (heightControl) heightControl.style.display = shapeValue === 'rectangle' ? 'block' : 'none';
                    }
                }

                updateAll();
            });

            form.addEventListener('click', (e) => {
                const fieldset = e.target.closest('fieldset[data-object-id]');
                const isInteractive = e.target.closest('button, a, input, [contenteditable="true"]');

                if (fieldset && !isInteractive) {
                    const idToSelect = parseInt(fieldset.dataset.objectId, 10);
                    if (!(selectedObjectIds.length === 1 && selectedObjectIds[0] === idToSelect)) {
                        selectedObjectIds = [idToSelect];
                        updateToolbarState();
                        syncPanelsWithSelection();
                        drawFrame();
                    }
                }

                if (e.target.classList.contains('object-name')) {
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }
                const deleteBtn = e.target.closest('.btn-delete');
                const duplicateBtn = e.target.closest('.btn-duplicate');
                const lockBtn = e.target.closest('.btn-lock');

                if (lockBtn) {
                    e.preventDefault();
                    const id = parseInt(lockBtn.dataset.id, 10);
                    const obj = objects.find(o => o.id === id);
                    if (obj) {
                        obj.locked = !obj.locked;
                        const icon = lockBtn.querySelector('i');
                        lockBtn.classList.toggle('btn-warning', obj.locked);
                        lockBtn.classList.toggle('btn-outline-secondary', !obj.locked);
                        icon.className = `bi ${obj.locked ? 'bi-lock-fill' : 'bi-unlock-fill'}`;
                        const tooltip = bootstrap.Tooltip.getInstance(lockBtn);
                        if (tooltip) {
                            tooltip.setContent({ '.tooltip-inner': obj.locked ? 'Unlock Object' : 'Lock Object' });
                        }
                        drawFrame();
                    }
                }

                if (deleteBtn) {
                    e.preventDefault();
                    const idToDelete = parseInt(deleteBtn.dataset.id, 10);

                    selectedObjectIds = selectedObjectIds.filter(id => id !== idToDelete);
                    configStore = configStore.filter(conf => !(conf.property || conf.name).startsWith(`obj${idToDelete}_`));
                    objects = objects.filter(o => o.id !== idToDelete);

                    syncAndRenumberState();
                }
                if (duplicateBtn) {
                    e.preventDefault();

                    const values = getControlValues();
                    configStore = configStore.map(conf => {
                        const key = conf.property || conf.name;
                        if (values[key] !== undefined) {
                            if (conf.type === 'boolean') {
                                conf.default = String(values[key]);
                            } else {
                                conf.default = values[key];
                            }
                        }
                        return conf;
                    });

                    const newId = (objects.reduce((maxId, o) => Math.max(maxId, o.id), 0)) + 1;
                    const idToCopy = duplicateBtn.dataset.id;
                    const configsToCopy = configStore.filter(conf => (conf.property || conf.name).startsWith(`obj${idToCopy}_`));
                    const newConfigs = configsToCopy.map(conf => {
                        const newConf = { ...conf };
                        const propOrName = conf.property || conf.name;
                        newConf.property = propOrName.replace(`obj${idToCopy}_`, `obj${newId}_`);
                        newConf.label = newConf.label.replace(/Object \d+/, `Object ${newId}`);
                        return newConf;
                    });

                    configStore.push(...newConfigs);
                    renderForm();
                    updateAll();
                }
            });

            copyBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(outputScriptArea.value).then(() => {
                    showNotification("Script header copied to clipboard!");
                });
            });

            document.getElementById('save-ws-btn').addEventListener('click', () => {
                saveProjectNameInput.value = '';
                existingProjectList.innerHTML = '';
                let hasProjects = false;
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(projectPrefix)) {
                        hasProjects = true;
                        const projectName = key.replace(projectPrefix, '');
                        const li = document.createElement('li');
                        li.className = 'list-group-item list-group-item-action';
                        li.textContent = projectName;
                        li.style.cursor = 'pointer';
                        li.addEventListener('click', () => {
                            saveProjectNameInput.value = projectName;
                        });

                        existingProjectList.appendChild(li);
                    }
                }
                if (!hasProjects) {
                    existingProjectList.innerHTML = '<li class="list-group-item disabled">No saved projects yet.</li>';
                }
                saveProjectModal.show();
            });

            confirmSaveBtn.addEventListener('click', () => {
                const name = saveProjectNameInput.value.trim();
                if (!name) {
                    showNotification("Please enter a project name.");
                    return;
                }

                const key = `${projectPrefix}${name}`;
                const currentValues = getControlValues();
                const configsToSave = configStore.map(conf => {
                    const newConf = { ...conf };
                    const propOrName = newConf.property || newConf.name;
                    if (currentValues[propOrName] !== undefined) {
                        newConf.default = currentValues[propOrName];
                    }
                    return newConf;
                });

                projectToSave = {
                    key: key,
                    name: name,
                    workspace: {
                        configs: configsToSave,
                        objects: objects.map(o => ({ id: o.id, name: o.name, locked: o.locked }))
                    }
                };

                saveProjectModal.hide();

                if (localStorage.getItem(key)) {
                    setTimeout(() => confirmOverwriteModal.show(), 300);
                } else {
                    localStorage.setItem(projectToSave.key, JSON.stringify(projectToSave.workspace));
                    setTimeout(() => showNotification(`Project "${projectToSave.name}" saved!`), 300);
                }
            });

            confirmOverwriteBtn.addEventListener('click', () => {
                if (projectToSave.key) {
                    localStorage.setItem(projectToSave.key, JSON.stringify(projectToSave.workspace));
                    confirmOverwriteModal.hide();
                    setTimeout(() => showNotification(`Project "${projectToSave.name}" saved!`), 300);
                }
            });

            document.getElementById('load-ws-btn').addEventListener('click', () => {
                loadProjectList.innerHTML = '';
                let hasProjects = false;
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(projectPrefix)) {
                        hasProjects = true;
                        const projectName = key.replace(projectPrefix, '');
                        const li = document.createElement('li');
                        li.className = 'list-group-item d-flex justify-content-between align-items-center';
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = projectName;
                        nameSpan.style.cursor = "pointer";
                        nameSpan.className = "flex-grow-1";
                        nameSpan.onclick = () => {
                            const savedData = localStorage.getItem(key);
                            if (savedData) {
                                loadWorkspace(JSON.parse(savedData));
                                loadProjectModal.hide();
                            }
                        };
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-sm btn-outline-danger';
                        deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            if (confirm(`Are you sure you want to delete project "${projectName}"?`)) {
                                localStorage.removeItem(key);
                                document.getElementById('load-ws-btn').click();
                            }
                        };
                        li.appendChild(nameSpan);
                        li.appendChild(deleteBtn);
                        loadProjectList.appendChild(li);
                    }
                }
                if (!hasProjects) {
                    loadProjectList.innerHTML = '<li class="list-group-item disabled">No saved projects found.</li>';
                }
                loadProjectModal.show();
            });

            toolbar.addEventListener('click', e => {
                const button = e.target.closest('button');
                if (!button || button.disabled || button.id === 'constrain-btn') return;
                const action = button.dataset.action;
                if (!action || selectedObjectIds.length === 0) return;
                const selected = selectedObjectIds.map(id => objects.find(o => o.id === id)).filter(o => o);
                if (selected.length === 0) return;
                const anchor = selected[0];
                switch (action) {
                    case 'align-screen-left': selected.forEach(o => o.x = 0); break;
                    case 'align-screen-right': selected.forEach(o => o.x = canvas.width - o.width); break;
                    case 'align-screen-h-center': selected.forEach(o => o.x = (canvas.width - o.width) / 2); break;
                    case 'align-screen-top': selected.forEach(o => o.y = 0); break;
                    case 'align-screen-bottom': selected.forEach(o => o.y = canvas.height - o.height); break;
                    case 'align-screen-v-center': selected.forEach(o => o.y = (canvas.height - o.height) / 2); break;
                    case 'match-width': selected.slice(1).forEach(o => o.width = anchor.width); break;
                    case 'match-height': selected.slice(1).forEach(o => o.height = anchor.height); break;
                    case 'match-both': selected.slice(1).forEach(o => { o.width = anchor.width; o.height = anchor.height; }); break;
                    case 'fit-canvas':
                        selected.forEach(o => {
                            o.x = 0;
                            o.y = 0;
                            o.width = canvas.width;
                            o.height = canvas.height;
                        });
                        break;
                }
                updateFormFromShapes();
            });

            addObjectBtn.addEventListener('click', () => {
                const newId = (objects.reduce((maxId, o) => Math.max(maxId, o.id), 0)) + 1;
                const newConfigs = getDefaultObjectConfig(newId);
                configStore.push(...newConfigs);
                createInitialObjects();
                renderForm();
                updateAll();
            });

            constrainBtn.addEventListener('click', () => {
                constrainToCanvas = !constrainToCanvas;
                constrainBtn.classList.toggle('btn-primary', constrainToCanvas);
                constrainBtn.classList.toggle('btn-outline-secondary', !constrainToCanvas);
            });

            canvasContainer.addEventListener('mousedown', e => {
                const { x, y } = getCanvasCoordinates(e);
                if (selectedObjectIds.length === 1) {
                    const selectedObject = objects.find(o => o.id === selectedObjectIds[0]);
                    if (selectedObject && !selectedObject.locked) {
                        const handle = selectedObject.getHandleAtPoint(x, y);
                        if (handle) {
                            isResizing = true;
                            isDragging = false;
                            activeResizeHandle = handle.name;
                            const oppositeHandleName = getOppositeHandle(handle.name);
                            initialDragState = [{ id: selectedObject.id, x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, rotationAngle: selectedObject.rotationAngle, anchorPoint: selectedObject.getWorldCoordsOfCorner(oppositeHandleName), oppositeHandleName: oppositeHandleName }];
                            return;
                        }
                    }
                }
                let hitObject = null;
                for (let i = objects.length - 1; i >= 0; i--) {
                    if (objects[i].isPointInside(x, y) && !objects[i].locked) {
                        hitObject = objects[i];
                        break;
                    }
                }
                if (hitObject) {
                    isDragging = true;
                    const hitObjectId = hitObject.id;
                    if (e.shiftKey || e.ctrlKey || e.metaKey) {
                        if (selectedObjectIds.includes(hitObjectId)) {
                            selectedObjectIds = selectedObjectIds.filter(id => id !== hitObjectId);
                        } else {
                            selectedObjectIds.push(hitObjectId);
                        }
                    } else {
                        if (!selectedObjectIds.includes(hitObjectId)) {
                            selectedObjectIds = [hitObjectId];
                        }
                    }
                } else {
                    selectedObjectIds = [];
                }
                if (isDragging && selectedObjectIds.length > 0) {
                    dragStartX = x;
                    dragStartY = y;
                    initialDragState = selectedObjectIds.map(id => {
                        const obj = objects.find(o => o.id === id);
                        return { id, x: obj.x, y: obj.y };
                    });
                } else {
                    isDragging = false;
                }
                updateToolbarState();
                syncPanelsWithSelection();
            });

            canvasContainer.addEventListener('mousemove', e => {
                e.preventDefault();
                const { x, y } = getCanvasCoordinates(e);
                if (isResizing) {
                    const obj = objects.find(o => o.id === selectedObjectIds[0]);
                    const initial = initialDragState[0];
                    const dx = x - dragStartX;
                    const dy = y - dragStartY;

                    let localDx = dx;
                    let localDy = dy;

                    if (obj.shape !== 'ring') {
                        const angle = initial.rotationAngle;
                        const s = Math.sin(angle);
                        const c = Math.cos(angle);
                        localDx = dx * c + dy * s;
                        localDy = -dx * s + dy * c;
                    }

                    if (activeResizeHandle.includes('right')) {
                        obj.width = Math.max(50, initial.width + localDx);
                    }
                    if (activeResizeHandle.includes('left')) {
                        obj.width = Math.max(50, initial.width - localDx);
                    }
                    if (activeResizeHandle.includes('bottom')) {
                        obj.height = Math.max(50, initial.height + localDy);
                    }
                    if (activeResizeHandle.includes('top')) {
                        obj.height = Math.max(50, initial.height - localDy);
                    }
                    if (obj.shape === 'circle' || obj.shape === 'ring') {
                        obj.height = obj.width;
                    }
                    const newAnchorPoint = obj.getWorldCoordsOfCorner(initial.oppositeHandleName);
                    const offsetX = initial.anchorPoint.x - newAnchorPoint.x;
                    const offsetY = initial.anchorPoint.y - newAnchorPoint.y;
                    obj.x += offsetX;
                    obj.y += offsetY;
                    updateFormFromShapes();
                } else if (isDragging) {
                    initialDragState.forEach(initial => {
                        const obj = objects.find(o => o.id === initial.id);
                        if (obj) {
                            const dx = x - dragStartX;
                            const dy = y - dragStartY;
                            let newX = initial.x + dx;
                            let newY = initial.y + dy;
                            if (constrainToCanvas) {
                                newX = Math.max(0, Math.min(newX, canvas.width - obj.width));
                                newY = Math.max(0, Math.min(newY, canvas.height - obj.height));
                            }
                            obj.x = newX;
                            obj.y = newY;
                        }
                    });
                    updateFormFromShapes();
                } else {
                    canvasContainer.style.cursor = 'default';
                    if (selectedObjectIds.length === 1) {
                        const selectedObject = objects.find(o => o.id === selectedObjectIds[0]);
                        if (selectedObject && !selectedObject.locked) {
                            const handle = selectedObject.getHandleAtPoint(x, y);
                            if (handle) {
                                canvasContainer.style.cursor = handle.cursor;
                            } else if (selectedObject.isPointInside(x, y)) {
                                canvasContainer.style.cursor = 'move';
                            }
                        }
                    }
                }
            });
            canvasContainer.addEventListener('mouseup', () => {
                if (isResizing) { updateAll(); }
                isDragging = false;
                isResizing = false;
                activeResizeHandle = null;
            });
            canvasContainer.addEventListener('mouseleave', () => {
                isDragging = false;
                isResizing = false;
                activeResizeHandle = null;
                canvasContainer.style.cursor = 'default';
            });

            exportBtn.addEventListener('click', exportFile);

            function init() {
                const template = document.getElementById('initial-config');
                const metaElements = Array.from(template.content.querySelectorAll('meta'));
                configStore = metaElements.map(parseMetaToConfig);

                const objectIds = [...new Set(
                    configStore
                        .filter(c => c.property && c.property.startsWith('obj'))
                        .map(c => c.property.match(/obj(\d+)_/)[1])
                )];

                objectIds.forEach(id => {
                    const animModeConf = configStore.find(c => c.property === `obj${id}_animationMode`);
                    const newValues = 'loop,bounce,bounce-reversed,bounce-random';
                    if (animModeConf) {
                        animModeConf.values = newValues;
                    } else {
                        const getLabelPrefix = () => {
                            const shapeConf = configStore.find(c => c.property === `obj${id}_shape`);
                            return shapeConf ? shapeConf.label.split(':')[0] : `Object ${id}`;
                        };
                        configStore.push({ property: `obj${id}_animationMode`, label: `${getLabelPrefix()}: Animation Mode`, type: 'combobox', values: newValues, default: 'loop' });
                    }
                });

                createInitialObjects();
                renderForm();
                updateAll();
                new bootstrap.Tooltip(document.body, { selector: "[data-bs-toggle='tooltip']", trigger: 'hover' });
                updateToolbarState();
                requestAnimationFrame(animate);

                const savedVSizes = getCookie('split-v-sizes');
                const savedHSizes = getCookie('split-h-sizes');
                const initialVSizes = savedVSizes ? JSON.parse(savedVSizes) : [30, 70];
                const initialHSizes = savedHSizes ? JSON.parse(savedHSizes) : [75, 25];

                lastHSizes = initialHSizes;
                lastVSizes = initialVSizes;

                horizontalSplit = Split(['#left-panel', '#right-panel'], {
                    sizes: initialVSizes,
                    minSize: [400, 500],
                    gutterSize: 12,
                    gutter: (index, direction) => {
                        const gutter = document.createElement('div');
                        gutter.className = `gutter gutter-${direction}`;
                        const icon = document.createElement('i');
                        icon.className = 'bi bi-three-dots-vertical';
                        gutter.appendChild(icon);
                        return gutter;
                    },
                    onDragEnd: function (sizes) {
                        setCookie('split-v-sizes', JSON.stringify(sizes), 365);
                        lastVSizes = sizes;
                    }
                });

                verticalSplit = Split(['#right-panel-top', '#right-panel-bottom'], {
                    direction: 'vertical',
                    sizes: initialHSizes,
                    minSize: [200, 150],
                    gutterSize: 12,
                    gutter: (index, direction) => {
                        const gutter = document.createElement('div');
                        gutter.className = `gutter gutter-${direction}`;
                        const icon = document.createElement('i');
                        icon.className = 'bi bi-three-dots';
                        gutter.appendChild(icon);
                        return gutter;
                    },
                    onDragEnd: function (sizes) {
                        setCookie('split-h-sizes', JSON.stringify(sizes), 365);
                        lastHSizes = sizes;
                    }
                });

                initializeSortable();
            }


            init();
        });
    </script>
</body>

</html>