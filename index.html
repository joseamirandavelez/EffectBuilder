<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Effect Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

    <template id="initial-config">
        <meta name="title" label="Title" type="text" default="Effect Class">
        <meta name="description" label="Description" type="text"
            default="This class aims to help developers design their own effects in an easy and efficient way.">
        <meta name="publisher" label="Developer Name" type="text" default="Jose Miranda">
        <meta property="enableAnimation" label="Enable Animation" type="boolean" default="true">
        <meta property="obj1_shape" label="Object 1: Shape" type="combobox" default="rectangle"
            values="rectangle,circle,ring">
        <meta property="obj1_x" label="Object 1: X Position" type="number" default="50" min="0" max="1280">
        <meta property="obj1_y" label="Object 1: Y Position" type="number" default="50" min="0" max="800">
        <meta property="obj1_width" label="Object 1: Width/Outer Diameter" type="number" default="640" min="10"
            max="1280">
        <meta property="obj1_height" label="Object 1: Height" type="number" default="400" min="10" max="800">
        <meta property="obj1_innerDiameter" label="Object 1: Inner Diameter" type="number" default="200" min="5"
            max="1270">
        <meta property="obj1_numberOfSegments" label="Object 1: Segments" type="number" default="12" min="1" max="50">
        <meta property="obj1_angularWidth" label="Object 1: Segment Angle" type="number" default="20" min="1" max="90">
        <meta property="obj1_rotationSpeed" label="Object 1: Rotation Speed" type="number" default="0" min="-100"
            max="100">
        <meta property="obj1_animationSpeed" label="Object 1: Animation Speed" type="number" default="2" min="1"
            max="50">
        <meta property="obj1_scrollDir" label="Object 1: Scroll Direction" type="combobox" default="right"
            values="right,left,up,down">
        <meta property="obj1_gradType" label="Object 1: Fill Type" type="combobox" default="linear"
            values="solid,linear,radial,alternating">
        <meta property="obj1_useSharpGradient" label="Object 1: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj1_gradientStop" label="Object 1: Gradient Stop %" type="number" default="50" min="0"
            max="100">
        <meta property="obj1_gradColor1" label="Object 1: Color 1" type="color" default="#ff0000">
        <meta property="obj1_gradColor2" label="Object 1: Color 2" type="color" default="#ffff00">
        <meta property="obj1_cycleColors" label="Object 1: Cycle Colors" type="boolean" default="false">
        <meta property="obj1_cycleSpeed" label="Object 1: Color Cycle Speed" type="number" default="1" min="1" max="10">
        <meta property="obj2_shape" label="Object 2: Shape" type="combobox" default="circle"
            values="rectangle,circle,ring">
        <meta property="obj2_x" label="Object 2: X Position" type="number" default="800" min="0" max="1280">
        <meta property="obj2_y" label="Object 2: Y Position" type="number" default="100" min="0" max="800">
        <meta property="obj2_width" label="Object 2: Width/Outer Diameter" type="number" default="200" min="10"
            max="1280">
        <meta property="obj2_height" label="Object 2: Height" type="number" default="200" min="10" max="800">
        <meta property="obj2_innerDiameter" label="Object 2: Inner Diameter" type="number" default="100" min="5"
            max="1270">
        <meta property="obj2_numberOfSegments" label="Object 2: Segments" type="number" default="12" min="1" max="50">
        <meta property="obj2_angularWidth" label="Object 2: Segment Angle" type="number" default="15" min="1" max="90">
        <meta property="obj2_rotationSpeed" label="Object 2: Rotation Speed" type="number" default="0" min="-100"
            max="100">
        <meta property="obj2_animationSpeed" label="Object 2: Animation Speed" type="number" default="5" min="1"
            max="50">
        <meta property="obj2_scrollDir" label="Object 2: Scroll Direction" type="combobox" default="left"
            values="right,left,up,down">
        <meta property="obj2_gradType" label="Object 2: Fill Type" type="combobox" default="radial"
            values="solid,linear,radial,alternating">
        <meta property="obj2_useSharpGradient" label="Object 2: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj2_gradientStop" label="Object 2: Gradient Stop %" type="number" default="50" min="0"
            max="100">
        <meta property="obj2_gradColor1" label="Object 2: Color 1" type="color" default="#800080">
        <meta property="obj2_gradColor2" label="Object 2: Color 2" type="color" default="#0000ff">
        <meta property="obj2_cycleColors" label="Object 2: Cycle Colors" type="boolean" default="true">
        <meta property="obj2_cycleSpeed" label="Object 2: Color Cycle Speed" type="number" default="5" min="1" max="10">
        <meta property="obj3_shape" label="Object 3: Shape" type="combobox" default="ring"
            values="rectangle,circle,ring">
        <meta property="obj3_x" label="Object 3: X Position" type="number" default="800" min="0" max="1280">
        <meta property="obj3_y" label="Object 3: Y Position" type="number" default="450" min="0" max="800">
        <meta property="obj3_width" label="Object 3: Width/Outer Diameter" type="number" default="300" min="10"
            max="1280">
        <meta property="obj3_height" label="Object 3: Height" type="number" default="300" min="10" max="800">
        <meta property="obj3_innerDiameter" label="Object 3: Inner Diameter" type="number" default="200" min="5"
            max="1270">
        <meta property="obj3_numberOfSegments" label="Object 3: Segments" type="number" default="12" min="1" max="50">
        <meta property="obj3_angularWidth" label="Object 3: Segment Angle" type="number" default="20" min="1" max="90">
        <meta property="obj3_rotationSpeed" label="Object 3: Rotation Speed" type="number" default="10" min="-100"
            max="100">
        <meta property="obj3_animationSpeed" label="Object 3: Animation Speed" type="number" default="2" min="1"
            max="50">
        <meta property="obj3_scrollDir" label="Object 3: Scroll Direction" type="combobox" default="down"
            values="right,left,up,down">
        <meta property="obj3_gradType" label="Object 3: Fill Type" type="combobox" default="alternating"
            values="solid,linear,radial,alternating">
        <meta property="obj3_useSharpGradient" label="Object 3: Use Sharp Gradient" type="boolean" default="false">
        <meta property="obj3_gradientStop" label="Object 3: Gradient Stop %" type="number" default="50" min="0"
            max="100">
        <meta property="obj3_gradColor1" label="Object 3: Color 1" type="color" default="#00ff00">
        <meta property="obj3_gradColor2" label="Object 3: Color 2" type="color" default="#00ffff">
        <meta property="obj3_cycleColors" label="Object 3: Cycle Colors" type="boolean" default="true">
        <meta property="obj3_cycleSpeed" label="Object 3: Color Cycle Speed" type="number" default="2" min="1" max="10">
    </template>

    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background-color: #1a1a1a;
            color: #f8f9fa;
        }

        .form-control,
        .form-select,
        .form-control:disabled {
            background-color: #2d3748;
            color: #e2e8f0;
            border-color: #4a5568;
            transition: all 0.2s ease;
        }

        .form-control:focus,
        .form-select:focus {
            background-color: #4a5568;
            color: #e2e8f0;
            border-color: #3182ce;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.3);
        }

        .form-control-color {
            width: 80px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #4a5568;
            cursor: pointer;
        }

        .form-control-color::-webkit-color-swatch {
            border-radius: 6px;
            border: none;
        }

        .input-group .form-control[type="number"] {
            width: 100px;
            border-radius: 8px 0 0 8px;
            background-color: #2d3748;
            border-right: none;
        }

        .input-group .form-range {
            background-color: transparent;
            border: none;
            padding: 0 10px;
            accent-color: #3182ce;
        }

        .input-group .form-range::-webkit-slider-thumb {
            background-color: #3182ce;
            border: 2px solid #e2e8f0;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
        }

        .form-select {
            border-radius: 8px;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23e2e8f0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
        }

        .form-check-input {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background-color: #2d3748;
            border: 2px solid #4a5568;
            cursor: pointer;
        }

        .form-check-input:checked {
            background-color: #3182ce;
            border-color: #3182ce;
        }

        #canvas-container {
            position: relative;
            background-color: #222;
            aspect-ratio: 1280 / 800;
            cursor: default;

            /* New sizing logic for robust aspect ratio scaling */
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
        }

        #signalCanvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .output-panel {
            /* The min-height property is now controlled by the splitter */
        }

        #output-script {
            font-family: monospace;
            white-space: pre;
            background-color: #222;
            color: #f8f9fa;
        }

        .toast-container,
        .modal {
            z-index: 1090;
        }

        .legend-button {
            background: none;
            border: none;
            color: #e2e8f0;
            padding: 0;
            font-size: 1.2rem;
            font-weight: 600;
            width: 100%;
            text-align: left;
            transition: color 0.2s ease;
        }

        .legend-button:hover {
            color: #3182ce;
        }

        .legend-button:not(.collapsed)::after {
            transform: rotate(-180deg);
        }

        .legend-button::after {
            content: '\f282';
            font-family: 'bootstrap-icons';
            display: inline-block;
            transition: transform 0.2s ease-in-out;
            float: right;
        }

        .toolbar {
            background-color: #212529;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toolbar .btn {
            color: #e2e8f0;
            border-radius: 6px;
            transition: background-color 0.2s ease;
        }

        .toolbar .btn:hover {
            background-color: #4a5568;
        }

        .object-name {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            background-color: #2d3748;
            transition: background-color 0.2s ease;
        }

        .object-name:focus {
            background-color: #4a5568;
            outline: none;
            box-shadow: 0 0 0 2px #3182ce;
        }

        #load-project-list .list-group-item {
            cursor: pointer;
            background-color: #2d3748;
            border-color: #4a5568;
            transition: background-color 0.2s ease;
        }

        #load-project-list .list-group-item:hover {
            background-color: #4a5568;
        }

        .gutter {
            background-color: #4a5568;
            background-repeat: no-repeat;
            background-position: 50%;
        }

        .gutter.gutter-horizontal {
            cursor: ew-resize;
        }

        .gutter.gutter-vertical {
            cursor: ns-resize;
        }

        #main-split {
            display: flex;
            flex-direction: row;
        }

        .generated-script-header {
            margin-bottom: 5px;
        }
    </style>
</head>

<body class="d-flex flex-column vh-100">

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Interactive Effect Builder</a>
            <div class="d-flex">
                <div class="d-flex">
                    <button class="btn btn-outline-primary me-2" id="save-ws-btn" data-bs-toggle="tooltip"
                        title="Save Workspace to Browser Storage"><i class="bi bi-save"></i> Save</button>
                    <button class="btn btn-outline-secondary me-2" id="load-ws-btn" data-bs-toggle="tooltip"
                        title="Load Workspace from Browser Storage"><i class="bi bi-folder2-open"></i> Load</button>
                    <button class="btn btn-outline-success" id="export-btn" data-bs-toggle="tooltip"
                        title="Export complete HTML file"><i class="bi bi-download"></i> Export</button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid flex-grow-1 overflow-hidden">
        <div class="h-100" id="main-split">
            <div id="left-panel" class="h-100 py-3 border-end border-secondary" style="overflow: auto;">
                <div class="h-100 d-flex flex-column">
                    <div class="flex-grow-1 overflow-auto pe-2">
                        <h4 class="text-gray-100">Controls</h4>
                        <form id="controls-form"></form>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-success w-100" id="add-object-btn" data-bs-toggle="tooltip"
                            title="Add a new default object to the scene"><i class="bi bi-plus-circle"></i> Add New
                            Object</button>
                    </div>
                </div>
            </div>

            <div id="right-panel" class="d-flex flex-column h-100">
                <div id="right-panel-top" class="d-flex flex-column" style="overflow: auto; min-height: 0;">
                    <div class="p-3">
                        <div id="toolbar" class="toolbar d-flex flex-wrap">
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-primary" id="constrain-btn"
                                    data-bs-toggle="tooltip" title="Toggle Constrain to Canvas"><i
                                        class="bi bi-magnet-fill"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-left"
                                    data-bs-toggle="tooltip" title="Align Left to Screen"><i
                                        class="bi bi-align-start"></i></button>
                                <button type="button" class="btn btn-outline-secondary"
                                    data-action="align-screen-h-center" data-bs-toggle="tooltip"
                                    title="Align Horizontal Center to Screen"><i
                                        class="bi bi-align-center"></i></button>
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-right"
                                    data-bs-toggle="tooltip" title="Align Right to Screen"><i
                                        class="bi bi-align-end"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-outline-secondary" data-action="align-screen-top"
                                    data-bs-toggle="tooltip" title="Align Top to Screen"><i
                                        class="bi bi-align-top"></i></button>
                                <button type="button" class="btn btn-outline-secondary"
                                    data-action="align-screen-v-center" data-bs-toggle="tooltip"
                                    title="Align Vertical Center to Screen"><i class="bi bi-align-middle"></i></button>
                                <button type="button" class="btn btn-outline-secondary"
                                    data-action="align-screen-bottom" data-bs-toggle="tooltip"
                                    title="Align Bottom to Screen"><i class="bi bi-align-bottom"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm me-2 mb-1" role="group">
                                <button type="button" class="btn btn-outline-warning" data-action="match-width"
                                    data-bs-toggle="tooltip" title="Match Width of First Selected"><i
                                        class="bi bi-arrows-expand-vertical"></i> W</button>
                                <button type="button" class="btn btn-outline-warning" data-action="match-height"
                                    data-bs-toggle="tooltip" title="Match Height of First Selected"><i
                                        class="bi bi-arrows-expand"></i> H</button>
                                <button type="button" class="btn btn-outline-warning" data-action="match-both"
                                    data-bs-toggle="tooltip" title="Match Size of First Selected"><i
                                        class="bi bi-fullscreen"></i></button>
                            </div>
                            <div class="btn-group btn-group-sm ms-auto mb-1" role="group">
                                <button type="button" class="btn btn-outline-secondary" id="collapse-code-btn"
                                    data-bs-toggle="tooltip" title="Toggle Code Panel">
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="flex-grow-1 p-3" style="min-height: 0; position: relative;">
                        <div id="canvas-container">
                            <canvas id="signalCanvas"></canvas>
                        </div>
                    </div>
                </div>
                <div id="right-panel-bottom" class="output-panel d-flex flex-column p-3 border-top border-secondary">
                    <h5 class="text-gray-100 generated-script-header">Generated Script Header</h5>
                    <textarea id="output-script" class="form-control flex-grow-1" readonly></textarea>
                    <button class="btn btn-primary mt-2" id="copy-btn" data-bs-toggle="tooltip"
                        title="Copy the generated meta tags to your clipboard"> <i class="bi bi-clipboard"></i> Copy to
                        Clipboard </button>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="copy-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-autohide="true"
            data-bs-delay="5000">
            <div class="toast-header bg-success text-white">
                <strong class="me-auto">Success</strong>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"
                    aria-label="Close"></button>
            </div>
            <div class="toast-body">
                Script header copied to clipboard!
            </div>
        </div>
    </div>

    <div class="modal fade" id="load-project-modal" tabindex="-1" aria-labelledby="loadProjectModalLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-white">
                <div class="modal-header">
                    <h5 class="modal-title" id="loadProjectModalLabel">Load Project</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"
                        aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Select a project to load. This will overwrite your current workspace.</p>
                    <ul class="list-group" id="load-project-list"></ul>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/split.js/dist/split.min.js"></script>

    <script>
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        class Shape {
            constructor({
                id, name, shape, x, y, width, height, gradient, gradType,
                gradientDirection, scrollDirection, cycleColors, cycleSpeed, animationSpeed, ctx,
                innerDiameter, angularWidth, numberOfSegments, rotationSpeed, useSharpGradient, gradientStop
            }) {
                this.id = id;
                this.name = name || `Object ${id}`;
                this.shape = shape;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.gradient = gradient || { color1: '#000000', color2: '#000000' };
                this.gradType = gradType || 'solid';
                this.gradientDirection = gradientDirection || 'horizontal';
                this.scrollDirection = scrollDirection || 'right';
                this.cycleColors = cycleColors || false;
                this.cycleSpeed = cycleSpeed || 0;
                this.animationSpeed = animationSpeed || 0;
                this.ctx = ctx;
                this.hue1 = 0;
                this.hue2 = 90;
                this.scrollOffset = 0;
                this.innerDiameter = innerDiameter;
                this.angularWidth = angularWidth;
                this.numberOfSegments = numberOfSegments;
                this.rotationSpeed = rotationSpeed || 0;
                this.rotationAngle = 0;
                this.useSharpGradient = useSharpGradient !== undefined ? useSharpGradient : false;
                this.gradientStop = gradientStop !== undefined ? parseFloat(gradientStop) : 50;
                this.handleSize = 8;
                this.handles = [
                    { name: 'top-left', cursor: 'nwse-resize' }, { name: 'top', cursor: 'ns-resize' }, { name: 'top-right', cursor: 'nesw-resize' },
                    { name: 'left', cursor: 'ew-resize' }, { name: 'right', cursor: 'ew-resize' },
                    { name: 'bottom-left', cursor: 'nesw-resize' }, { name: 'bottom', cursor: 'ns-resize' }, { name: 'bottom-right', cursor: 'nwse-resize' }
                ];
            }

            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }
            getHandlePositions() {
                const h2 = this.handleSize / 2;
                return {
                    'top-left': { x: this.x - h2, y: this.y - h2 },
                    'top': { x: this.x + this.width / 2 - h2, y: this.y - h2 },
                    'top-right': { x: this.x + this.width - h2, y: this.y - h2 },
                    'left': { x: this.x - h2, y: this.y + this.height / 2 - h2 },
                    'right': { x: this.x + this.width - h2, y: this.y + this.height / 2 - h2 },
                    'bottom-left': { x: this.x - h2, y: this.y + this.height - h2 },
                    'bottom': { x: this.x + this.width / 2 - h2, y: this.y + this.height - h2 },
                    'bottom-right': { x: this.x + this.width - h2, y: this.y + this.height - h2 }
                };
            }
            getHandleAtPoint(px, py) {
                const handlePositions = this.getHandlePositions();
                if (this.shape === 'ring') {
                    for (const handle of this.handles) {
                        const pos = handlePositions[handle.name];
                        if (px >= pos.x && px <= pos.x + this.handleSize && py >= pos.y && py <= pos.y + this.handleSize) {
                            return handle;
                        }
                    }
                    return null;
                }
                const localPoint = this.getLocalPoint(px, py);
                for (const handle of this.handles) {
                    const pos = handlePositions[handle.name];
                    if (localPoint.x >= pos.x && localPoint.x <= pos.x + this.handleSize && localPoint.y >= pos.y && localPoint.y <= pos.y + this.handleSize) {
                        return handle;
                    }
                }
                return null;
            }
            getLocalPoint(px, py) {
                const center = this.getCenter();
                const angle = -this.rotationAngle;
                const s = Math.sin(angle);
                const c = Math.cos(angle);
                let tempX = px - center.x;
                let tempY = py - center.y;
                const rotatedX = tempX * c - tempY * s;
                const rotatedY = tempX * s + tempY * c;
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            }
            getWorldCoordsOfCorner(handleName) {
                const handlePositions = this.getHandlePositions();
                const h2 = this.handleSize / 2;
                const localCorner = { x: handlePositions[handleName].x + h2, y: handlePositions[handleName].y + h2 };

                if (this.shape === 'ring') {
                    return localCorner;
                }

                const center = this.getCenter();
                const angle = this.rotationAngle;
                const s = Math.sin(angle);
                const c = Math.cos(angle);
                let tempX = localCorner.x - center.x;
                let tempY = localCorner.y - center.y;
                const rotatedX = tempX * c - tempY * s;
                const rotatedY = tempX * s + tempY * c;
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            }

            updateAnimationState() {
                if (this.cycleColors) {
                    this.hue1 += this.cycleSpeed;
                    this.hue2 += this.cycleSpeed;
                }
                if (this.gradType !== 'solid' && this.gradType !== 'alternating') {
                    const directionMultiplier = this.gradType.includes('radial') ? 1 : ((this.scrollDirection === 'left' || this.scrollDirection === 'up') ? 1 : -1);
                    this.scrollOffset += this.animationSpeed * directionMultiplier * 0.02;
                    this.scrollOffset = (this.scrollOffset % 2 + 2) % 2;
                }
                this.rotationAngle += (this.rotationSpeed / 1000);
            }

            createFillStyle() {
                const c1 = this.cycleColors ? `hsl(${(this.hue1 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color1;
                const c2 = this.cycleColors ? `hsl(${(this.hue2 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color2;
                const isLinear = this.gradType && this.gradType.includes('linear');
                const isRadial = this.gradType && this.gradType.includes('radial');

                if (this.gradType === 'alternating') {
                    return c2;
                }

                if (isLinear || isRadial) {
                    let grad;
                    if (isLinear) {
                        const patternCanvas = document.createElement('canvas');
                        const patternCtx = patternCanvas.getContext('2d');
                        if (this.gradientDirection === 'horizontal') {
                            patternCanvas.width = this.width > 0 ? this.width : 1;
                            patternCanvas.height = 1;
                            grad = patternCtx.createLinearGradient(0, 0, this.width, 0);
                        } else {
                            patternCanvas.width = 1;
                            patternCanvas.height = this.height > 0 ? this.height : 1;
                            grad = patternCtx.createLinearGradient(0, 0, 0, this.height);
                        }
                        grad.isPattern = true;
                        grad.patternCanvas = patternCanvas;
                        grad.patternCtx = patternCtx;
                    } else if (isRadial) {
                        const centerX = this.x + this.width / 2;
                        const centerY = this.y + this.height / 2;
                        const maxRadius = Math.max(this.width, this.height) / 2;
                        grad = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
                    }
                    if (grad) {
                        if (this.useSharpGradient) {
                            const clampedStop = Math.max(1, Math.min(99, this.gradientStop)) / 100;
                            const stopPoint = isRadial ? clampedStop * Math.abs(this.scrollOffset - 1) : clampedStop;
                            grad.addColorStop(0, c1);
                            grad.addColorStop(stopPoint, c1);
                            grad.addColorStop(stopPoint + 0.001, c2);
                            grad.addColorStop(1, c2);
                        } else {
                            grad.addColorStop(0, c1);
                            grad.addColorStop(isRadial ? 0.5 * Math.abs(this.scrollOffset - 1) : 0.5, c2);
                            grad.addColorStop(1, c1);
                        }
                        if (grad.isPattern) {
                            grad.patternCtx.fillStyle = grad;
                            grad.patternCtx.fillRect(0, 0, grad.patternCanvas.width, grad.patternCanvas.height);
                            return this.ctx.createPattern(grad.patternCanvas, 'repeat');
                        }
                        return grad;
                    }
                }
                return c1 || 'black';
            }

            draw(enableAnimation, isSelected) {
                this.ctx.save();
                if (enableAnimation) {
                    this.updateAnimationState();
                }

                this.ctx.save();
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(this.rotationAngle);
                this.ctx.translate(-centerX, -centerY);

                if (this.gradType !== 'alternating') {
                    if (this.gradType === 'solid') {
                        this.ctx.fillStyle = this.cycleColors ? `hsl(${(this.hue1 * 180 / Math.PI) % 360}, 100%, 50%)` : this.gradient.color1;
                    } else {
                        this.ctx.fillStyle = this.gradient ? this.createFillStyle() : 'black';
                    }
                }

                this.ctx.save();
                let scrollX = 0;
                let scrollY = 0;
                if (this.gradType.includes('linear')) {
                    scrollX = (this.gradientDirection === 'horizontal') ? -this.scrollOffset * this.width * 0.5 : 0;
                    scrollY = (this.gradientDirection === 'vertical') ? -this.scrollOffset * this.height * 0.5 : 0;
                    this.ctx.translate(scrollX, scrollY);
                }

                switch (this.shape) {
                    case 'rectangle':
                        this.ctx.fillRect(this.x - scrollX, this.y - scrollY, this.width, this.height);
                        break;
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(this.x + this.width / 2 - scrollX, this.y + this.height / 2 - scrollY, this.width / 2, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    case 'ring': {
                        const outerRadius = this.width / 2;
                        const innerRadius = this.innerDiameter / 2;
                        if (innerRadius >= 0 && innerRadius < outerRadius && this.numberOfSegments > 0) {
                            const anglePerSlot = (Math.PI * 2) / this.numberOfSegments;
                            const segmentAngleRad = Math.min(this.angularWidth * (Math.PI / 180), anglePerSlot);
                            const angleOffset = (anglePerSlot - segmentAngleRad) / 2;

                            if (this.gradType === 'alternating') {
                                for (let i = 0; i < this.numberOfSegments; i++) {
                                    this.ctx.fillStyle = (i % 2 === 0) ? this.gradient.color1 : this.gradient.color2;
                                    this.ctx.beginPath();
                                    const startAngle = (i * anglePerSlot) + angleOffset;
                                    const endAngle = startAngle + segmentAngleRad;
                                    this.ctx.moveTo(centerX + innerRadius * Math.cos(startAngle), centerY + innerRadius * Math.sin(startAngle));
                                    this.ctx.arc(centerX, centerY, innerRadius, startAngle, endAngle);
                                    this.ctx.lineTo(centerX + outerRadius * Math.cos(endAngle), centerY + outerRadius * Math.sin(endAngle));
                                    this.ctx.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
                                    this.ctx.closePath();
                                    this.ctx.fill();
                                }
                            } else {
                                this.ctx.beginPath();
                                for (let i = 0; i < this.numberOfSegments; i++) {
                                    const startAngle = (i * anglePerSlot) + angleOffset;
                                    const endAngle = startAngle + segmentAngleRad;
                                    this.ctx.moveTo(centerX + innerRadius * Math.cos(startAngle) - scrollX, centerY + innerRadius * Math.sin(startAngle) - scrollY);
                                    this.ctx.arc(centerX - scrollX, centerY - scrollY, innerRadius, startAngle, endAngle);
                                    this.ctx.lineTo(centerX + outerRadius * Math.cos(endAngle) - scrollX, centerY + outerRadius * Math.sin(endAngle) - scrollY);
                                    this.ctx.arc(centerX - scrollX, centerY - scrollY, outerRadius, endAngle, startAngle, true);
                                    this.ctx.closePath();
                                }
                                this.ctx.fill();
                            }
                        }
                        break;
                    }
                }
                this.ctx.restore();
                this.ctx.restore();

                if (isSelected) {
                    this.ctx.save();
                    if (this.shape !== 'ring') {
                        this.ctx.translate(centerX, centerY);
                        this.ctx.rotate(this.rotationAngle);
                        this.ctx.translate(-centerX, -centerY);
                    }
                    this.ctx.strokeStyle = '#00f6ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(this.x, this.y, this.width, this.height);
                    this.ctx.setLineDash([]);
                    this.ctx.fillStyle = '#00f6ff';
                    const handlePositions = this.getHandlePositions();
                    for (const handle of this.handles) {
                        const pos = handlePositions[handle.name];
                        this.ctx.fillRect(pos.x, pos.y, this.handleSize, this.handleSize);
                    }
                    this.ctx.restore();
                }
                this.ctx.restore();
            }

            isPointInside(px, py) {
                const localPoint = this.getLocalPoint(px, py);
                return (localPoint.x >= this.x && localPoint.x <= this.x + this.width && localPoint.y >= this.y && localPoint.y <= this.y + this.height);
            }

            update(props) {
                for (const key in props) {
                    if (props[key] !== undefined) {
                        if (key === 'gradient' && typeof props[key] === 'object' && props[key] !== null) {
                            if (props.gradient.color1 !== undefined) this.gradient.color1 = props.gradient.color1;
                            if (props.gradient.color2 !== undefined) this.gradient.color2 = props.gradient.color2;
                        } else if (this.hasOwnProperty(key)) {
                            this[key] = props[key];
                        }
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // --- Canvas and DOM element references ---
            const canvas = document.getElementById('signalCanvas');
            const canvasContainer = document.getElementById('canvas-container');
            const ctx = canvas.getContext('2d');
            canvas.width = 1280;
            canvas.height = 800;

            const form = document.getElementById('controls-form');
            const outputScriptArea = document.getElementById('output-script');
            const copyBtn = document.getElementById('copy-btn');
            const copyToastEl = document.getElementById('copy-toast');
            const copyToast = new bootstrap.Toast(copyToastEl);
            const toolbar = document.getElementById('toolbar');
            const addObjectBtn = document.getElementById('add-object-btn');
            const constrainBtn = document.getElementById('constrain-btn');
            const loadProjectModalEl = document.getElementById('load-project-modal');
            const loadProjectModal = new bootstrap.Modal(loadProjectModalEl);
            const loadProjectList = document.getElementById('load-project-list');
            const collapseCodeBtn = document.getElementById('collapse-code-btn');
            const exportBtn = document.getElementById('export-btn');

            // --- State Variables ---
            let configStore = [];
            let objects = [];
            let selectedObjectIds = [];

            let isDragging = false;
            let isResizing = false;
            let activeResizeHandle = null;
            let dragStartX, dragStartY;
            let initialDragState = [];
            let constrainToCanvas = true;
            const projectPrefix = 'effectBuilderProject_';
            let verticalSplit, horizontalSplit;
            let lastHSizes, lastVSizes;
            let isCodePanelCollapsed = false;

            // --- Helper Functions ---
            function parseMetaToConfig(metaElement) {
                const config = {};
                for (const attr of metaElement.attributes) {
                    config[attr.name] = attr.value;
                }
                return config;
            }

            function groupConfigs(flatConfig) {
                const grouped = { general: [], objects: {} };
                flatConfig.forEach(config => {
                    const key = config.property || config.name;
                    if (key.startsWith('obj')) {
                        const match = key.match(/^obj(\d+)_/);
                        const id = match[1];
                        if (!grouped.objects[id]) grouped.objects[id] = [];
                        grouped.objects[id].push(config);
                    } else {
                        grouped.general.push(config);
                    }
                });
                return grouped;
            }

            function createFormControl(config) {
                const { property, name, label, type, default: defaultValue, values, min, max } = config;
                const controlId = property || name;
                const formGroup = document.createElement('div');
                formGroup.className = 'mb-3';
                const labelEl = document.createElement('label');
                labelEl.htmlFor = controlId;
                labelEl.className = 'block text-sm font-medium text-gray-300';
                labelEl.textContent = label.substring(label.indexOf(':') + 1).trim() || label;
                labelEl.dataset.bsToggle = 'tooltip';
                labelEl.title = `Controls the ${label.toLowerCase()}`;
                formGroup.appendChild(labelEl);

                if (type === 'number') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'flex items-center space-x-2';
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control w-24 bg-gray-700 text-gray-200 border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500';
                    input.name = controlId;
                    input.type = 'number';
                    input.value = defaultValue;
                    if (min) input.min = min;
                    if (max) input.max = max;
                    input.step = '1';
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.className = 'form-range flex-1 bg-transparent';
                    slider.id = `${controlId}_slider`;
                    slider.name = `${controlId}_slider`;
                    if (min) slider.min = min;
                    if (max) slider.max = max;
                    slider.value = defaultValue;
                    inputGroup.appendChild(input);
                    inputGroup.appendChild(slider);
                    formGroup.appendChild(inputGroup);
                } else if (type === 'text') {
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control w-full bg-gray-700 text-gray-200 border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500';
                    input.name = controlId;
                    input.type = 'text';
                    input.value = defaultValue;
                    formGroup.appendChild(input);
                } else if (type === 'combobox') {
                    const vals = values.split(',');
                    const select = document.createElement('select');
                    select.id = controlId;
                    select.className = 'form-select w-full bg-gray-700 text-gray-200 border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500';
                    select.name = controlId;
                    vals.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val.charAt(0).toUpperCase() + val.slice(1);
                        if (val === defaultValue) option.selected = true;
                        select.appendChild(option);
                    });
                    formGroup.appendChild(select);
                } else if (type === 'boolean') {
                    const checkGroup = document.createElement('div');
                    checkGroup.className = 'form-check form-switch';
                    const check = document.createElement('input');
                    check.id = controlId;
                    check.type = 'checkbox';
                    check.className = 'form-check-input';
                    check.name = controlId;
                    check.checked = (defaultValue === 'true');
                    const checkLabel = document.createElement('label');
                    checkLabel.className = 'form-check-label';
                    checkLabel.htmlFor = controlId;
                    checkLabel.textContent = label.substring(label.indexOf(':') + 1).trim() || label;
                    checkGroup.appendChild(check);
                    checkGroup.appendChild(checkLabel);
                    formGroup.appendChild(checkGroup);
                } else if (type === 'color') {
                    const colorGroup = document.createElement('div');
                    colorGroup.className = 'd-flex align-items-center';
                    const input = document.createElement('input');
                    input.id = controlId;
                    input.className = 'form-control form-control-color';
                    input.name = controlId;
                    input.type = 'color';
                    input.value = defaultValue;
                    const hexInput = document.createElement('input');
                    hexInput.type = 'text';
                    hexInput.className = 'form-control ms-2';
                    hexInput.style.width = '100px';
                    hexInput.value = defaultValue;
                    hexInput.id = `${controlId}_hex`;
                    hexInput.name = `${controlId}_hex`;
                    colorGroup.appendChild(input);
                    colorGroup.appendChild(hexInput);
                    formGroup.appendChild(colorGroup);
                }
                return formGroup;
            }

            function renderForm() {
                const existingTooltips = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                existingTooltips.forEach(el => {
                    const tooltip = bootstrap.Tooltip.getInstance(el);
                    if (tooltip) tooltip.dispose();
                });

                const grouped = groupConfigs(configStore);
                form.innerHTML = '';

                const generalFieldset = document.createElement('fieldset');
                generalFieldset.className = 'border border-gray-600 p-4 mb-4 rounded-lg';
                const generalLegend = document.createElement('legend');
                generalLegend.className = 'float-none w-auto px-2 text-lg font-semibold text-gray-100';
                generalLegend.textContent = 'General Settings';
                generalFieldset.appendChild(generalLegend);
                grouped.general.forEach(conf => generalFieldset.appendChild(createFormControl(conf)));
                form.appendChild(generalFieldset);

                Object.keys(grouped.objects).sort((a, b) => a - b).forEach(id => {
                    const objectForName = objects.find(o => o.id == id);
                    const objectName = objectForName ? objectForName.name : `Object ${id}`;
                    const objectConfigs = grouped.objects[id];
                    const fieldset = document.createElement('fieldset');
                    fieldset.className = 'border border-gray-600 p-3 mb-4 rounded-lg';
                    fieldset.dataset.objectId = id;

                    const legendContainer = document.createElement('legend');
                    legendContainer.className = 'float-none w-auto px-2 d-flex justify-content-between align-items-center w-100';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'object-name text-lg font-semibold text-gray-100 flex-grow-1 me-2';
                    nameSpan.style.minWidth = '0';
                    nameSpan.contentEditable = true;
                    nameSpan.dataset.id = id;
                    nameSpan.textContent = objectName;
                    legendContainer.appendChild(nameSpan);

                    const controlsGroup = document.createElement('div');
                    controlsGroup.className = 'd-flex align-items-center flex-shrink-0';

                    const dropdown = document.createElement('div');
                    dropdown.className = 'dropdown';
                    dropdown.innerHTML = `<button class="btn btn-sm btn-outline-secondary d-flex align-items-center justify-content-center p-0" style="width: 28px; height: 28px;" type="button" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-list fs-5"></i></button><ul class="dropdown-menu dropdown-menu-dark"><li><a class="dropdown-item btn-duplicate" href="#" data-id="${id}"><i class="bi bi-copy me-2"></i>Duplicate</a></li><li><a class="dropdown-item btn-delete text-danger" href="#" data-id="${id}"><i class="bi bi-trash me-2"></i>Delete</a></li></ul>`;
                    controlsGroup.appendChild(dropdown);

                    const collapseId = `collapse-obj-${id}`;
                    const collapseButton = document.createElement('button');
                    collapseButton.className = 'btn btn-sm btn-outline-secondary ms-2 legend-button collapsed d-flex align-items-center justify-content-center p-0';
                    collapseButton.style.width = '28px';
                    collapseButton.style.height = '28px';
                    collapseButton.type = 'button';
                    collapseButton.dataset.bsToggle = 'collapse';
                    collapseButton.dataset.bsTarget = `#${collapseId}`;
                    collapseButton.setAttribute('aria-expanded', 'false');
                    controlsGroup.appendChild(collapseButton);
                    legendContainer.appendChild(controlsGroup);

                    const collapseWrapper = document.createElement('div');
                    collapseWrapper.id = collapseId;
                    collapseWrapper.className = 'collapse p-3';

                    const groups = {
                        'Shape & Position': ['shape', 'x', 'y', 'width', 'height'],
                        'Ring Properties': ['innerDiameter', 'numberOfSegments', 'angularWidth'],
                        'Fill & Color': ['gradType', 'useSharpGradient', 'gradientStop', 'gradColor1', 'gradColor2'],
                        'Animation': ['rotationSpeed', 'animationSpeed', 'scrollDir', 'cycleColors', 'cycleSpeed']
                    };

                    for (const groupName in groups) {
                        const groupContainer = document.createElement('div');
                        groupContainer.className = 'control-group mb-4';
                        const groupHeader = document.createElement('h6');
                        groupHeader.className = 'text-gray-400 text-sm font-bold border-bottom border-gray-600 pb-1 mb-3';
                        groupHeader.textContent = groupName;
                        groupContainer.appendChild(groupHeader);

                        const propsInGroup = groups[groupName];
                        objectConfigs
                            .filter(conf => propsInGroup.some(p => conf.property.includes(p)))
                            .forEach(conf => groupContainer.appendChild(createFormControl(conf)));

                        if (groupContainer.children.length > 1) {
                            collapseWrapper.appendChild(groupContainer);
                        }
                    }

                    fieldset.appendChild(legendContainer);
                    fieldset.appendChild(collapseWrapper);
                    form.appendChild(fieldset);
                });

                setFormValues(getControlValues());
                new bootstrap.Tooltip(document.body, { selector: "[data-bs-toggle='tooltip']", trigger: 'hover' });
            }

            function rebuildFromState() {
                const grouped = groupConfigs(configStore);
                const newConfigStore = [...grouped.general];
                let newId = 1;
                const newObjects = [];
                Object.keys(grouped.objects).sort((a, b) => a - b).forEach(oldId => {
                    const configsForOldId = grouped.objects[oldId];
                    const oldObject = objects.find(o => o.id == oldId);
                    if (oldObject) { oldObject.id = newId; newObjects.push(oldObject); }
                    configsForOldId.forEach(conf => {
                        const newConf = { ...conf };
                        const propOrName = newConf.property || newConf.name;
                        newConf[propOrName.startsWith('obj') ? 'property' : 'name'] = propOrName.replace(/obj\d+_/, `obj${newId}_`);
                        newConf.label = conf.label.replace(/Object \d+/, `Object ${newId}`);
                        newConfigStore.push(newConf);
                    });
                    newId++;
                });
                configStore = newConfigStore;
                objects = newObjects;
                renderForm();
                updateAll();
                drawFrame(); // Ensure canvas is updated
            }

            function getControlValues() {
                const formData = new FormData(form);
                const data = {};
                configStore.forEach(conf => {
                    const key = conf.property || conf.name;
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            data[key] = el.checked;
                        } else if (el.type === 'number') {
                            data[key] = parseFloat(formData.get(key) || el.value);
                        } else {
                            data[key] = formData.get(key) || el.value;
                        }
                    }
                });
                return data;
            }

            function setFormValues(data) {
                for (const key in data) {
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = data[key];
                        } else {
                            el.value = data[key];
                        }
                    }
                }
                updateAll();
            }

            function buildStatesFromConfig() {
                const values = getControlValues();
                const grouped = groupConfigs(configStore);
                const finalStates = [];
                Object.keys(grouped.objects).forEach(id => {
                    const existingObject = objects.find(o => o.id == id);
                    const config = { id: parseInt(id), gradient: {}, name: existingObject ? existingObject.name : `Object ${id}` };
                    grouped.objects[id].forEach(conf => {
                        let key = conf.property.replace(`obj${id}_`, '');
                        let value = values[conf.property];
                        const type = conf.type;
                        if (type === 'number') value = parseFloat(value);
                        else if (type === 'boolean') value = (value === true || value === 'true');

                        if (key.startsWith('gradColor')) {
                            config.gradient[key.replace('grad', '').toLowerCase()] = value;
                        } else if (key === 'scrollDir') {
                            config.scrollDirection = value;
                        } else {
                            config[key] = value;
                        }
                    });
                    config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    config.cycleSpeed = (config.cycleSpeed || 0) / 100.0;
                    const speed = config.animationSpeed || 0;
                    const gradType = config.gradType || 'solid';
                    config.animationSpeed = (gradType.includes('radial')) ? speed / 50.0 : speed / 10.0;
                    if (config.shape === 'ring') {
                        config.height = config.width;
                    }
                    finalStates.push(config);
                });
                return finalStates;
            }

            function generateOutputScript() {
                const values = getControlValues();
                let scriptHTML = '';
                configStore.forEach(config => {
                    const propOrName = config.property || config.name;
                    const value = values[propOrName];
                    let line = `<meta ${propOrName.startsWith('obj') ? 'property' : 'name'}="${propOrName}"`;
                    Object.keys(config).forEach(attrName => {
                        if (attrName !== 'property' && attrName !== 'name' && attrName !== 'default' && attrName !== 'class') {
                            line += ` ${attrName}="${config[attrName]}"`;
                        }
                    });
                    line += ` default="${value}">\n`;
                    scriptHTML += line;
                });
                outputScriptArea.value = scriptHTML.trim();
            }

            function getCanvasCoordinates(event) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                return { x, y };
            }

            function updateToolbarState() {
                const multiSelectButtons = toolbar.querySelectorAll('[data-action^="match-"]');
                const singleSelectButtons = toolbar.querySelectorAll('[data-action^="align-screen-"]');
                singleSelectButtons.forEach(btn => btn.disabled = selectedObjectIds.length === 0);
                multiSelectButtons.forEach(btn => btn.disabled = selectedObjectIds.length < 2);
            }

            function updateFormFromShapes() {
                objects.forEach(obj => {
                    const prefix = `obj${obj.id}_`;
                    const fields = ['x', 'y', 'width', 'height'];
                    fields.forEach(field => {
                        const input = form.elements[`${prefix}${field}`];
                        if (input) {
                            input.value = Math.round(obj[field]);
                            const slider = form.elements[`${prefix}${field}_slider`];
                            if (slider) { slider.value = Math.round(obj[field]); }
                        }
                    });
                });
                generateOutputScript();
            }

            function drawFrame() {
                const values = getControlValues();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const enableAnimation = values['enableAnimation'] === true;
                objects.forEach(obj => {
                    const isSelected = selectedObjectIds.includes(obj.id);
                    obj.draw(enableAnimation, isSelected);
                });
            }

            function animate() {
                const values = getControlValues();
                if (values.enableAnimation || isDragging || isResizing) {
                    drawFrame();
                }
                requestAnimationFrame(animate);
            }

            function updateShapesFromForm() {
                const values = getControlValues();
                const newStates = buildStatesFromConfig();
                const newObjects = [];
                newStates.forEach(state => {
                    const existingObj = objects.find(o => o.id === state.id);
                    if (existingObj) {
                        existingObj.update(state);
                        newObjects.push(existingObj);
                    } else {
                        newObjects.push(new Shape({ ...state, ctx }));
                    }
                });
                objects = newObjects;
            }

            function updateAll() {
                updateShapesFromForm();
                generateOutputScript();
            }

            function syncPanelsWithSelection() {
                const allCollapses = form.querySelectorAll('.collapse');
                allCollapses.forEach(el => {
                    const instance = bootstrap.Collapse.getInstance(el) || new bootstrap.Collapse(el, { toggle: false });
                    const fieldset = el.closest('fieldset');
                    if (!fieldset) return;
                    const id = parseInt(fieldset.dataset.objectId, 10);
                    if (selectedObjectIds.length === 1 && selectedObjectIds[0] === id) {
                        instance.show();
                    } else {
                        instance.hide();
                    }
                });
            }

            function createInitialObjects() {
                const grouped = groupConfigs(configStore);
                const initialStates = [];
                Object.keys(grouped.objects).forEach(id => {
                    const config = { id: parseInt(id), gradient: {} };
                    grouped.objects[id].forEach(conf => {
                        const key = conf.property.replace(`obj${id}_`, '');
                        let value = conf.default;
                        const type = conf.type;
                        if (type === 'number') value = parseFloat(value);
                        else if (type === 'boolean') value = (value === 'true');
                        if (key.startsWith('gradColor')) {
                            config.gradient[key.replace('grad', '').toLowerCase()] = value;
                        } else if (key === 'scrollDir') {
                            config.scrollDirection = value;
                        } else {
                            config[key] = value;
                        }
                    });
                    config.gradType = config.gradType || 'solid';
                    config.gradient = config.gradient.color1 ? config.gradient : { color1: '#000000', color2: '#000000' };
                    config.useSharpGradient = config.useSharpGradient !== undefined ? config.useSharpGradient : false;
                    config.gradientStop = config.gradientStop !== undefined ? parseFloat(config.gradientStop) : 50;
                    config.gradientDirection = (config.scrollDirection === 'up' || config.scrollDirection === 'down') ? 'vertical' : 'horizontal';
                    config.cycleSpeed = (config.cycleSpeed || 0) / 100.0;
                    const speed = config.animationSpeed || 0;
                    config.animationSpeed = (config.gradType.includes('radial')) ? speed / 100.0 : speed;
                    if (config.shape === 'ring') {
                        config.height = config.width;
                    }
                    initialStates.push(config);
                });
                objects = initialStates.map(state => new Shape({ ...state, ctx }));
            }

            function loadWorkspace(workspace) {
                configStore = workspace.configs;
                createInitialObjects();
                if (workspace.names) {
                    workspace.names.forEach(savedName => {
                        const obj = objects.find(o => o.id === savedName.id);
                        if (obj) { obj.name = savedName.name; }
                    });
                }
                renderForm();
                for (const config of configStore) {
                    const key = config.property || config.name;
                    const el = form.elements[key];
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = config.default === 'true' || config.default === true;
                        } else {
                            el.value = config.default;
                        }
                        if (el.type === 'number') {
                            const slider = document.getElementById(`${el.id}_slider`);
                            if (slider) slider.value = el.value;
                        }
                    }
                }
                updateAll();
                drawFrame();
            }

            function getOppositeHandle(handleName) {
                let opposite = handleName;
                if (handleName.includes('top')) {
                    opposite = opposite.replace('top', 'bottom');
                } else if (handleName.includes('bottom')) {
                    opposite = opposite.replace('bottom', 'top');
                }
                if (handleName.includes('left')) {
                    opposite = opposite.replace('left', 'right');
                } else if (handleName.includes('right')) {
                    opposite = opposite.replace('right', 'left');
                }
                return opposite;
            }

            function getDefaultObjectConfig(newId) {
                return [
                    { property: `obj${newId}_shape`, label: `Object ${newId}: Shape`, type: 'combobox', default: 'rectangle', values: 'rectangle,circle,ring' },
                    { property: `obj${newId}_x`, label: `Object ${newId}: X Position`, type: 'number', default: '10', min: '0', max: '1280' },
                    { property: `obj${newId}_y`, label: `Object ${newId}: Y Position`, type: 'number', default: '10', min: '0', max: '800' },
                    { property: `obj${newId}_width`, label: `Object ${newId}: Width/Outer Diameter`, type: 'number', default: '200', min: '10', max: '1280' },
                    { property: `obj${newId}_height`, label: `Object ${newId}: Height`, type: 'number', default: '150', min: '10', max: '800' },
                    { property: `obj${newId}_innerDiameter`, label: `Object ${newId}: Inner Diameter`, type: 'number', default: '100', min: '5', max: '1270' },
                    { property: `obj${newId}_numberOfSegments`, label: `Object ${newId}: Segments`, type: 'number', default: '12', min: '1', max: '50' },
                    { property: `obj${newId}_angularWidth`, label: `Object ${newId}: Segment Angle`, type: 'number', default: '20', min: '1', max: '90' },
                    { property: `obj${newId}_rotationSpeed`, label: `Object ${newId}: Rotation Speed`, type: 'number', default: '0', min: '-100', max: '100' },
                    { property: `obj${newId}_animationSpeed`, label: `Object ${newId}: Animation Speed`, type: 'number', default: '2', min: '1', max: '50' },
                    { property: `obj${newId}_scrollDir`, label: `Object ${newId}: Scroll Direction`, type: 'combobox', default: 'right', values: 'right,left,up,down' },
                    { property: `obj${newId}_gradType`, label: `Object ${newId}: Fill Type`, type: 'combobox', default: 'linear', values: 'solid,linear,radial,alternating' },
                    { property: `obj${newId}_useSharpGradient`, label: `Object ${newId}: Use Sharp Gradient`, type: 'boolean', default: 'false' },
                    { property: `obj${newId}_gradientStop`, label: `Object ${newId}: Gradient Stop %`, type: 'number', default: '50', min: '0', max: '100' },
                    { property: `obj${newId}_gradColor1`, label: `Object ${newId}: Color 1`, type: 'color', default: '#cccccc' },
                    { property: `obj${newId}_gradColor2`, label: `Object ${newId}: Color 2`, type: 'color', default: '#888888' },
                    { property: `obj${newId}_cycleColors`, label: `Object ${newId}: Cycle Colors`, type: 'boolean', default: 'false' },
                    { property: `obj${newId}_cycleSpeed`, label: `Object ${newId}: Color Cycle Speed`, type: 'number', default: '1', min: '1', max: '10' }
                ];
            }

            async function exportFile() {
                const exportButton = document.getElementById('export-btn');
                exportButton.disabled = true;
                exportButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exporting...';

                // Use the direct "raw" URL for the file content, which is more reliable.
                const templateUrl = 'https://raw.githubusercontent.com/joseamirandavelez/EffectClass/main/EffectClass/EffectClass.html';

                try {
                    // 1. Fetch the template file's raw text content.
                    const response = await fetch(templateUrl);
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.statusText}`);
                    }
                    const templateHtml = await response.text();

                    // 2. Get the new meta tags generated by our app.
                    const newMetaBlock = document.getElementById('output-script').value;

                    // 3. Find and replace the meta tag block in the template.
                    const headRegex = /<head>([\s\S]*?)<\/head>/;
                    const headMatch = templateHtml.match(headRegex);

                    if (!headMatch) {
                        throw new Error("Could not find <head> tag in the template.");
                    }

                    const titleRegex = /<title>([\s\S]*?)<\/title>/;
                    const titleMatch = headMatch[1].match(titleRegex);
                    const titleTag = titleMatch ? titleMatch[0] : '<title>Effect</title>';

                    // 4. Construct the new <head> and the final HTML file content.
                    const newHeadContent = `<head>\n\n    ${titleTag}\n\n    ${newMetaBlock}\n\n</head>`;
                    const finalHtml = templateHtml.replace(headRegex, newHeadContent);

                    // 5. Trigger the download.
                    const blob = new Blob([finalHtml], { type: 'text/html' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    const effectTitle = getControlValues()['title'] || 'MyEffect';
                    link.download = `${effectTitle.replace(/ /g, '_')}.html`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                } catch (error) {
                    console.error('Export failed:', error);
                    alert(`Export failed: ${error.message}`);
                } finally {
                    // Restore the button's original state.
                    exportButton.disabled = false;
                    exportButton.innerHTML = '<i class="bi bi-download"></i> Export';
                }
            }
            // --- Event Listeners ---

            form.addEventListener('input', (e) => {
                const target = e.target;
                if (target.type === 'number' && document.getElementById(`${target.id}_slider`)) {
                    document.getElementById(`${target.id}_slider`).value = target.value;
                } else if (target.type === 'range' && target.id.endsWith('_slider')) {
                    const numberInputId = target.id.replace('_slider', '');
                    document.getElementById(numberInputId).value = target.value;
                }

                if (target.type === 'color' && document.getElementById(`${target.id}_hex`)) {
                    document.getElementById(`${target.id}_hex`).value = target.value;
                }
                if (target.type === 'text' && target.id.endsWith('_hex')) {
                    const colorPickerId = target.id.replace('_hex', '');
                    const colorPicker = document.getElementById(colorPickerId);
                    if (colorPicker && /^#[0-9A-F]{6}$/i.test(target.value)) {
                        colorPicker.value = target.value;
                    }
                }

                if (target.name && target.name.includes('_shape')) {
                    const objectId = target.name.match(/obj(\d+)_/)[1];
                    const shapeValue = target.value;
                    const fieldset = form.querySelector(`fieldset[data-object-id="${objectId}"]`);
                    if (fieldset) {
                        const ringControls = fieldset.querySelector('.control-group:nth-of-type(2)');
                        const heightControl = fieldset.querySelector(`[id*="obj${objectId}_height"]`).closest('.mb-3');
                        if (ringControls) ringControls.style.display = shapeValue === 'ring' ? '' : 'none';
                        if (heightControl) heightControl.style.display = shapeValue === 'rectangle' ? '' : 'none';
                    }
                }

                updateAll();
            });

            form.addEventListener('click', (e) => {
                const fieldset = e.target.closest('fieldset[data-object-id]');
                const isInteractive = e.target.closest('button, a, input, [contenteditable="true"]');

                if (fieldset && !isInteractive) {
                    const idToSelect = parseInt(fieldset.dataset.objectId, 10);
                    if (!(selectedObjectIds.length === 1 && selectedObjectIds[0] === idToSelect)) {
                        selectedObjectIds = [idToSelect];
                        updateToolbarState();
                        syncPanelsWithSelection();
                        drawFrame();
                    }
                }

                if (e.target.classList.contains('object-name')) {
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }
                const deleteBtn = e.target.closest('.btn-delete');
                const duplicateBtn = e.target.closest('.btn-duplicate');
                if (deleteBtn) {
                    e.preventDefault();
                    const idToDelete = parseInt(deleteBtn.dataset.id, 10);
                    selectedObjectIds = selectedObjectIds.filter(id => id !== idToDelete);
                    updateToolbarState();
                    configStore = configStore.filter(conf => !(conf.property || conf.name).startsWith(`obj${idToDelete}_`));
                    objects = objects.filter(o => o.id !== idToDelete);
                    rebuildFromState();
                }
                if (duplicateBtn) {
                    e.preventDefault();
                    const newId = (objects.reduce((maxId, o) => Math.max(maxId, o.id), 0)) + 1;
                    const idToCopy = duplicateBtn.dataset.id;
                    const values = getControlValues();
                    const configsToCopy = configStore.filter(conf => (conf.property || conf.name).startsWith(`obj${idToCopy}_`));
                    const newConfigs = configsToCopy.map(conf => {
                        const newConf = { ...conf };
                        const propOrName = newConf.property || newConf.name;
                        newConf[propOrName.startsWith('obj') ? 'property' : 'name'] = propOrName.replace(`obj${idToCopy}_`, `obj${newId}_`);
                        newConf.label = newConf.label.replace(/Object \d+/, `Object ${newId}`);
                        newConf.default = values[propOrName];
                        return newConf;
                    });
                    configStore.push(...newConfigs);
                    renderForm();
                    updateAll();
                }
            });

            form.addEventListener('blur', (e) => {
                if (e.target.classList.contains('object-name')) {
                    const id = parseInt(e.target.dataset.id, 10);
                    const newName = e.target.textContent || 'Unnamed';
                    const obj = objects.find(o => o.id === id);
                    if (obj) { obj.name = newName; }
                }
            }, true);

            copyBtn.addEventListener('click', () => { navigator.clipboard.writeText(outputScriptArea.value).then(() => { copyToast.show(); }); });
            document.getElementById('save-ws-btn').addEventListener('click', () => {
                const name = prompt("Enter a name for your project:");
                if (!name) return;
                const key = `${projectPrefix}${name}`;
                if (localStorage.getItem(key)) {
                    if (!confirm(`A project named "${name}" already exists. Overwrite?`)) { return; }
                }
                const workspace = {
                    configs: configStore.map(c => ({ ...c, default: getControlValues()[c.property || c.name] })),
                    names: objects.map(o => ({ id: o.id, name: o.name }))
                };
                localStorage.setItem(key, JSON.stringify(workspace));
                alert(`Project "${name}" saved!`);
            });
            document.getElementById('load-ws-btn').addEventListener('click', () => {
                loadProjectList.innerHTML = '';
                let hasProjects = false;
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(projectPrefix)) {
                        hasProjects = true;
                        const projectName = key.replace(projectPrefix, '');
                        const li = document.createElement('li');
                        li.className = 'list-group-item bg-dark text-white d-flex justify-content-between align-items-center';
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = projectName;
                        nameSpan.style.cursor = "pointer";
                        nameSpan.onclick = () => {
                            const savedData = localStorage.getItem(key);
                            if (savedData) {
                                loadWorkspace(JSON.parse(savedData));
                                loadProjectModal.hide();
                            }
                        };
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-sm btn-outline-danger';
                        deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            if (confirm(`Are you sure you want to delete project "${projectName}"?`)) {
                                localStorage.removeItem(key);
                                document.getElementById('load-ws-btn').click();
                            }
                        };
                        li.appendChild(nameSpan);
                        li.appendChild(deleteBtn);
                        loadProjectList.appendChild(li);
                    }
                }
                if (!hasProjects) {
                    loadProjectList.innerHTML = '<li class="list-group-item bg-dark text-white-50">No saved projects found.</li>';
                }
                loadProjectModal.show();
            });
            toolbar.addEventListener('click', e => {
                const button = e.target.closest('button');
                if (!button || button.disabled || button.id === 'constrain-btn') return;
                const action = button.dataset.action;
                if (!action || selectedObjectIds.length === 0) return;
                const selected = selectedObjectIds.map(id => objects.find(o => o.id === id)).filter(o => o);
                if (selected.length === 0) return;
                const anchor = selected[0];
                switch (action) {
                    case 'align-screen-left': selected.forEach(o => o.x = 0); break;
                    case 'align-screen-right': selected.forEach(o => o.x = canvas.width - o.width); break;
                    case 'align-screen-h-center': selected.forEach(o => o.x = (canvas.width - o.width) / 2); break;
                    case 'align-screen-top': selected.forEach(o => o.y = 0); break;
                    case 'align-screen-bottom': selected.forEach(o => o.y = canvas.height - o.height); break;
                    case 'align-screen-v-center': selected.forEach(o => o.y = (canvas.height - o.height) / 2); break;
                    case 'match-width': selected.slice(1).forEach(o => o.width = anchor.width); break;
                    case 'match-height': selected.slice(1).forEach(o => o.height = anchor.height); break;
                    case 'match-both': selected.slice(1).forEach(o => { o.width = anchor.width; o.height = anchor.height; }); break;
                }
                updateFormFromShapes();
            });
            addObjectBtn.addEventListener('click', () => {
                const newId = (objects.reduce((maxId, o) => Math.max(maxId, o.id), 0)) + 1;
                const templateConf = configStore.filter(c => c.property && c.property.startsWith('obj1_'));
                let newConfigs;
                if (templateConf.length === 0) {
                    newConfigs = getDefaultObjectConfig(newId);
                } else {
                    const values = getControlValues();
                    newConfigs = templateConf.map(conf => {
                        const newConf = { ...conf };
                        newConf.property = newConf.property.replace('obj1_', `obj${newId}_`);
                        newConf.label = newConf.label.replace(/Object \d+/, `Object ${newId}`);
                        switch (newConf.property) {
                            case `obj${newId}_x`: newConf.default = '10'; break;
                            case `obj${newId}_y`: newConf.default = '10'; break;
                            case `obj${newId}_width`: newConf.default = '200'; break;
                            case `obj${newId}_height`: newConf.default = '150'; break;
                            case `obj${newId}_shape`: newConf.default = 'rectangle'; break;
                            case `obj${newId}_gradColor1`: newConf.default = '#cccccc'; break;
                            case `obj${newId}_gradColor2`: newConf.default = '#888888'; break;
                            default: newConf.default = values[conf.property];
                        }
                        return newConf;
                    });
                }
                configStore.push(...newConfigs);
                renderForm();
                updateAll();
            });
            constrainBtn.addEventListener('click', () => {
                constrainToCanvas = !constrainToCanvas;
                constrainBtn.classList.toggle('btn-primary', constrainToCanvas);
                constrainBtn.classList.toggle('btn-outline-secondary', !constrainToCanvas);
            });
            canvasContainer.addEventListener('mousedown', e => {
                const { x, y } = getCanvasCoordinates(e);
                if (selectedObjectIds.length === 1) {
                    const selectedObject = objects.find(o => o.id === selectedObjectIds[0]);
                    if (selectedObject) {
                        const handle = selectedObject.getHandleAtPoint(x, y);
                        if (handle) {
                            isResizing = true;
                            isDragging = false;
                            activeResizeHandle = handle.name;
                            const oppositeHandleName = getOppositeHandle(handle.name);
                            initialDragState = [{ id: selectedObject.id, x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, rotationAngle: selectedObject.rotationAngle, anchorPoint: selectedObject.getWorldCoordsOfCorner(oppositeHandleName), oppositeHandleName: oppositeHandleName }];
                            return;
                        }
                    }
                }
                let hitObject = null;
                for (let i = objects.length - 1; i >= 0; i--) {
                    if (objects[i].isPointInside(x, y)) {
                        hitObject = objects[i];
                        break;
                    }
                }
                if (hitObject) {
                    isDragging = true;
                    const hitObjectId = hitObject.id;
                    if (e.shiftKey || e.ctrlKey || e.metaKey) {
                        if (selectedObjectIds.includes(hitObjectId)) {
                            selectedObjectIds = selectedObjectIds.filter(id => id !== hitObjectId);
                        } else {
                            selectedObjectIds.push(hitObjectId);
                        }
                    } else {
                        if (!selectedObjectIds.includes(hitObjectId)) {
                            selectedObjectIds = [hitObjectId];
                        }
                    }
                } else {
                    selectedObjectIds = [];
                }
                if (isDragging && selectedObjectIds.length > 0) {
                    dragStartX = x;
                    dragStartY = y;
                    initialDragState = selectedObjectIds.map(id => {
                        const obj = objects.find(o => o.id === id);
                        return { id, x: obj.x, y: obj.y };
                    });
                } else {
                    isDragging = false;
                }
                updateToolbarState();
                syncPanelsWithSelection();
            });
            canvasContainer.addEventListener('mousemove', e => {
                e.preventDefault();
                const { x, y } = getCanvasCoordinates(e);
                if (isResizing) {
                    const obj = objects.find(o => o.id === selectedObjectIds[0]);
                    const initial = initialDragState[0];
                    const dx = x - dragStartX;
                    const dy = y - dragStartY;

                    let localDx = dx;
                    let localDy = dy;

                    if (obj.shape !== 'ring') {
                        const angle = initial.rotationAngle;
                        const s = Math.sin(angle);
                        const c = Math.cos(angle);
                        localDx = dx * c + dy * s;
                        localDy = -dx * s + dy * c;
                    }

                    if (activeResizeHandle.includes('right')) {
                        obj.width = Math.max(50, initial.width + localDx);
                    }
                    if (activeResizeHandle.includes('left')) {
                        obj.width = Math.max(50, initial.width - localDx);
                    }
                    if (activeResizeHandle.includes('bottom')) {
                        obj.height = Math.max(50, initial.height + localDy);
                    }
                    if (activeResizeHandle.includes('top')) {
                        obj.height = Math.max(50, initial.height - localDy);
                    }
                    if (obj.shape === 'circle' || obj.shape === 'ring') {
                        obj.height = obj.width;
                    }
                    const newAnchorPoint = obj.getWorldCoordsOfCorner(initial.oppositeHandleName);
                    const offsetX = initial.anchorPoint.x - newAnchorPoint.x;
                    const offsetY = initial.anchorPoint.y - newAnchorPoint.y;
                    obj.x += offsetX;
                    obj.y += offsetY;
                    updateFormFromShapes();
                } else if (isDragging) {
                    initialDragState.forEach(initial => {
                        const obj = objects.find(o => o.id === initial.id);
                        if (obj) {
                            const dx = x - dragStartX;
                            const dy = y - dragStartY;
                            let newX = initial.x + dx;
                            let newY = initial.y + dy;
                            if (constrainToCanvas) {
                                newX = Math.max(0, Math.min(newX, canvas.width - obj.width));
                                newY = Math.max(0, Math.min(newY, canvas.height - obj.height));
                            }
                            obj.x = newX;
                            obj.y = newY;
                        }
                    });
                    updateFormFromShapes();
                } else {
                    canvasContainer.style.cursor = 'default';
                    if (selectedObjectIds.length === 1) {
                        const selectedObject = objects.find(o => o.id === selectedObjectIds[0]);
                        if (selectedObject) {
                            const handle = selectedObject.getHandleAtPoint(x, y);
                            if (handle) {
                                canvasContainer.style.cursor = handle.cursor;
                            } else if (selectedObject.isPointInside(x, y)) {
                                canvasContainer.style.cursor = 'move';
                            }
                        }
                    }
                }
            });
            canvasContainer.addEventListener('mouseup', () => {
                if (isResizing) { updateAll(); }
                isDragging = false;
                isResizing = false;
                activeResizeHandle = null;
            });
            canvasContainer.addEventListener('mouseleave', () => {
                isDragging = false;
                isResizing = false;
                activeResizeHandle = null;
                canvasContainer.style.cursor = 'default';
            });

            collapseCodeBtn.addEventListener('click', () => {
                isCodePanelCollapsed = !isCodePanelCollapsed;
                const icon = collapseCodeBtn.querySelector('i');
                if (isCodePanelCollapsed) {
                    verticalSplit.collapse(1);
                    icon.className = 'bi bi-chevron-up';
                } else {
                    verticalSplit.setSizes(lastHSizes);
                    icon.className = 'bi bi-chevron-down';
                }
            });

            exportBtn.addEventListener('click', exportFile);

            function init() {
                const template = document.getElementById('initial-config');
                const metaElements = Array.from(template.content.querySelectorAll('meta'));
                configStore = metaElements.map(parseMetaToConfig);

                createInitialObjects();
                renderForm();
                updateAll();
                new bootstrap.Tooltip(document.body, { selector: "[data-bs-toggle='tooltip']", trigger: 'hover' });
                updateToolbarState();
                requestAnimationFrame(animate);

                const savedVSizes = getCookie('split-v-sizes');
                const savedHSizes = getCookie('split-h-sizes');
                const initialVSizes = savedVSizes ? JSON.parse(savedVSizes) : [30, 70];
                const initialHSizes = savedHSizes ? JSON.parse(savedHSizes) : [75, 25];

                lastHSizes = initialHSizes;
                lastVSizes = initialVSizes;

                horizontalSplit = Split(['#left-panel', '#right-panel'], {
                    sizes: initialVSizes,
                    minSize: [400, 500],
                    gutterSize: 8,
                    onDragEnd: function (sizes) {
                        setCookie('split-v-sizes', JSON.stringify(sizes), 365);
                        lastVSizes = sizes;
                    }
                });

                verticalSplit = Split(['#right-panel-top', '#right-panel-bottom'], {
                    direction: 'vertical',
                    sizes: initialHSizes,
                    minSize: [200, 0],
                    gutterSize: 8,
                    onDragEnd: function (sizes) {
                        setCookie('split-h-sizes', JSON.stringify(sizes), 365);
                        lastHSizes = sizes;
                    }
                });
            }

            init();
        });
    </script>
</body>

</html>